<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Linux CLI Quiz – Cyber Security Kurs</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #0f172a;
        color: #e5e7eb;
        line-height: 1.5;
      }
      header {
        padding: 1rem 1.5rem 0.75rem;
        background: #020617;
        border-bottom: 1px solid #1f2937;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .header-inner {
        max-width: 960px;
        margin: 0 auto;
      }
      h1 {
        margin: 0 0 0.2rem;
        font-size: 1.4rem;
        font-weight: 600;
      }
      .subtitle {
        font-size: 0.9rem;
        color: #9ca3af;
        margin: 0;
      }
      .search-container {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      /* Schmale Badge-Leiste im Header */
      .header-badge-filter {
        margin-top: 0.75rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }
      .header-badge-item {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.35rem 0.65rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        border: 1.5px solid;
        background: rgba(255, 255, 255, 0.05);
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      .header-badge-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      .header-badge-item.active {
        border-width: 2px;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      .header-badge-item.segment-1 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.15),
          rgba(16, 185, 129, 0.1)
        );
      }
      .header-badge-item.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.15),
          rgba(59, 130, 246, 0.1)
        );
      }
      .header-badge-item.segment-3 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.15),
          rgba(124, 58, 237, 0.1)
        );
      }
      .header-badge-item.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.15),
          rgba(217, 119, 6, 0.1)
        );
      }
      .header-badge-item.segment-5 {
        border-color: #f97316;
        color: #fdba74;
        background: linear-gradient(
          135deg,
          rgba(249, 115, 22, 0.15),
          rgba(234, 88, 12, 0.1)
        );
      }
      .header-badge-item.segment-6 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.15),
          rgba(219, 39, 119, 0.1)
        );
      }
      .header-badge-item-wrapper {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .header-badge-quiz-btn {
        padding: 0.35rem 0.65rem;
        border-radius: 999px;
        font-size: 0.7rem;
        font-weight: 600;
        border: 1.5px solid rgba(59, 130, 246, 0.5);
        background: rgba(59, 130, 246, 0.15);
        color: #93c5fd;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      .header-badge-quiz-btn:hover {
        transform: translateY(-1px);
        background: rgba(59, 130, 246, 0.25);
        border-color: rgba(59, 130, 246, 0.7);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
      }
      .header-badge-item.saturated {
        border-width: 2.5px;
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3),
          0 0 20px rgba(34, 197, 94, 0.5);
        animation: badgeGlow 2s ease-in-out infinite;
      }
      @keyframes badgeGlow {
        0%, 100% {
          box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3),
            0 0 20px rgba(34, 197, 94, 0.5);
        }
        50% {
          box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.5),
            0 0 30px rgba(34, 197, 94, 0.7);
        }
      }
      .header-badge-item.active.segment-1 {
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.25),
          rgba(16, 185, 129, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.3);
      }
      .header-badge-item.active.segment-2 {
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.25),
          rgba(59, 130, 246, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.3);
      }
      .header-badge-item.active.segment-3 {
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.25),
          rgba(124, 58, 237, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.3);
      }
      .header-badge-item.active.segment-4 {
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.25),
          rgba(217, 119, 6, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
      }
      .header-badge-item.active.segment-5 {
        background: linear-gradient(
          135deg,
          rgba(249, 115, 22, 0.25),
          rgba(234, 88, 12, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.3);
      }
      .header-badge-item.active.segment-6 {
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.25),
          rgba(219, 39, 119, 0.2)
        );
        box-shadow: 0 0 0 2px rgba(236, 72, 153, 0.3);
      }
      .search-input {
        width: 100%;
        padding: 0.6rem 0.9rem;
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 0.6rem;
        color: #e5e7eb;
        font-size: 0.9rem;
        font-family: inherit;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .search-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .search-input::placeholder {
        color: #6b7280;
      }
      .command-card.hidden {
        display: none;
      }

      /* Achievements / Badges */
      .achievements-container {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        align-items: center;
      }
      .achievement-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      .achievement-badge::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .achievement-badge:hover::before {
        opacity: 1;
      }
      .achievement-badge.unlocked {
        animation: badgeUnlock 0.6s ease-out;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .achievement-badge.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
      }
      .achievement-badge.golden {
        border-color: #fbbf24;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.4),
          rgba(245, 158, 11, 0.3)
        );
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
          0 4px 16px rgba(245, 158, 11, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        animation: goldenGlow 2s ease-in-out infinite;
        position: relative;
        overflow: visible;
      }
      .achievement-badge.golden::before {
        content: "";
        position: absolute;
        inset: -2px;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.3),
          transparent 50%,
          rgba(245, 158, 11, 0.3)
        );
        border-radius: 999px;
        z-index: -1;
        animation: goldenShine 3s ease-in-out infinite;
      }
      @keyframes goldenGlow {
        0%,
        100% {
          box-shadow: 0 0 30px rgba(251, 191, 36, 0.7),
            0 4px 16px rgba(245, 158, 11, 0.4);
        }
        50% {
          box-shadow: 0 0 40px rgba(251, 191, 36, 0.9),
            0 6px 20px rgba(245, 158, 11, 0.6);
        }
      }
      @keyframes goldenShine {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.8;
        }
      }
      .achievement-icon {
        font-size: 1rem;
      }
      .achievement-badge.badge-10 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .achievement-badge.badge-20 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .achievement-badge.badge-30 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .achievement-badge.badge-40 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .achievement-badge.badge-50 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .achievement-badge.badge-60 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
        box-shadow: 0 0 25px rgba(251, 191, 36, 0.4);
      }
      @keyframes badgeUnlock {
        0% {
          transform: scale(0.8) rotate(-5deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.15) rotate(5deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }
      .achievement-progress {
        font-size: 0.7rem;
        color: #9ca3af;
        margin-top: 0.3rem;
      }

      /* Haupt-Badge Reihe - Professionelle Ausrichtung mit Grid */
      .main-badges-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
        justify-items: center;
        align-items: stretch;
        width: 100%;
        max-width: 1100px;
        margin: 0 auto;
        padding: 0 0.5rem;
      }

      /* Sub-Badges Reihe - Direkt unter den Haupt-Badges ausgerichtet */
      .sub-badges-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
        justify-items: center;
        align-items: flex-start;
        width: 100%;
        max-width: 1100px;
        margin: 1rem auto 0;
        padding: 0 0.5rem;
      }

      .badge-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
        max-width: 200px;
      }

      .sub-badge-container {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        width: 100%;
        align-items: center;
      }

      /* Haupt-Badge Stil - Professionell ausgerichtet */
      .main-badge {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        padding: 1rem 1.1rem;
        border-radius: 0.85rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.06)
        );
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        position: relative;
        overflow: hidden;
        width: 100%;
        max-width: 200px;
        height: 125px;
        box-sizing: border-box;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .main-badge:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
        border-width: 2.5px;
        z-index: 1;
      }

      .main-badge.active {
        box-shadow: 0 0 32px rgba(59, 130, 246, 0.7),
          0 8px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transform: scale(1.03);
        border-width: 2.5px;
        z-index: 2;
      }

      .main-badge-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
        flex-shrink: 0;
      }

      .main-badge-icon {
        font-size: 1.3rem;
        line-height: 1;
        flex-shrink: 0;
      }

      .main-badge-name {
        font-size: 0.875rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: center;
        line-height: 1.2;
        font-weight: 600;
      }

      /* Ladebalken für Fortschritt */
      .main-badge-progress-bar {
        width: 100%;
        height: 7px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        flex-shrink: 0;
        margin: 0.2rem 0;
      }

      .main-badge-progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          currentColor,
          rgba(255, 255, 255, 0.8)
        );
        border-radius: 4px;
        transition: width 0.5s ease;
        position: relative;
        overflow: hidden;
      }

      .main-badge-progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .main-badge-progress-text {
        font-size: 0.7rem;
        opacity: 0.9;
        white-space: nowrap;
        text-align: center;
        width: 100%;
        font-weight: 500;
        letter-spacing: 0.02em;
        flex-shrink: 0;
        line-height: 1.3;
      }

      /* Progress Container für bessere Ausrichtung */
      .main-badge-progress-container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.35rem;
        flex: 1;
        justify-content: center;
        min-height: 0;
      }

      /* Haupt-Badge Farben */
      .main-badge.badge-voyer {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }

      .main-badge.badge-operator {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }

      .main-badge.badge-connoisseur {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }

      .main-badge.badge-navigator {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }

      .main-badge.badge-morelinux {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }

      /* Unter-Badge Stil (nur visuell, nicht anklickbar) */
      .sub-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid;
        background: rgba(255, 255, 255, 0.05);
        opacity: 0.7;
        pointer-events: none;
        cursor: default;
        width: 100%;
      }

      /* Sub-Badge Farben für Segmente */
      .sub-badge.segment-1 {
        border-color: rgba(167, 139, 250, 0.5);
        color: #c4b5fd;
        background: rgba(167, 139, 250, 0.1);
      }
      .sub-badge.segment-2 {
        border-color: rgba(96, 165, 250, 0.5);
        color: #93c5fd;
        background: rgba(96, 165, 250, 0.1);
      }
      .sub-badge.segment-3 {
        border-color: rgba(52, 211, 153, 0.5);
        color: #6ee7b7;
        background: rgba(52, 211, 153, 0.1);
      }
      .sub-badge.segment-4 {
        border-color: rgba(245, 158, 11, 0.5);
        color: #fcd34d;
        background: rgba(245, 158, 11, 0.1);
      }
      .sub-badge.segment-5 {
        border-color: rgba(236, 72, 153, 0.5);
        color: #f9a8d4;
        background: rgba(236, 72, 153, 0.1);
      }

      /* Legacy Badge-Segmente (für Kompatibilität) */
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.8rem;
        font-weight: 600;
        border: 2px solid;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.05)
        );
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .badge-segment.locked {
        opacity: 0.4;
        filter: grayscale(0.8);
        cursor: not-allowed;
      }
      .badge-segment.ready {
        /* Pulsierende Animation entfernt */
        cursor: pointer;
        opacity: 0.7;
        filter: saturate(0.7);
        transition: all 0.3s ease;
      }

      .badge-segment.ready:hover {
        opacity: 1;
        filter: saturate(1);
        transform: translateY(-2px);
      }
      /* Sättigungsstufen für Fortschritt */
      .badge-segment.progress-0 {
        filter: grayscale(1) saturate(0);
        opacity: 0.4;
      }
      .badge-segment.progress-25 {
        filter: grayscale(0.75) saturate(0.25);
        opacity: 0.6;
      }
      .badge-segment.progress-50 {
        filter: grayscale(0.5) saturate(0.5);
        opacity: 0.8;
      }
      .badge-segment.progress-75 {
        filter: grayscale(0.25) saturate(0.75);
        opacity: 0.9;
      }
      .badge-segment.progress-100 {
        filter: grayscale(0) saturate(1);
        opacity: 1;
      }

      .badge-segment.unlocked {
        opacity: 1;
        filter: none;
        cursor: default;
      }
      .badge-segment.active {
        box-shadow: 0 0 25px rgba(59, 130, 246, 0.6),
          0 4px 12px rgba(0, 0, 0, 0.3);
        transform: scale(1.05);
        border-width: 3px;
      }
      .badge-segment.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
        background: linear-gradient(
          135deg,
          rgba(167, 139, 250, 0.2),
          rgba(124, 58, 237, 0.1)
        );
      }
      .badge-segment.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
        background: linear-gradient(
          135deg,
          rgba(96, 165, 250, 0.2),
          rgba(59, 130, 246, 0.1)
        );
      }
      .badge-segment.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
        background: linear-gradient(
          135deg,
          rgba(52, 211, 153, 0.2),
          rgba(16, 185, 129, 0.1)
        );
      }
      .badge-segment.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
        background: linear-gradient(
          135deg,
          rgba(245, 158, 11, 0.2),
          rgba(217, 119, 6, 0.1)
        );
      }
      .badge-segment.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(219, 39, 119, 0.1)
        );
      }
      .badge-segment.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
        background: linear-gradient(
          135deg,
          rgba(251, 191, 36, 0.2),
          rgba(245, 158, 11, 0.1)
        );
      }
      .badge-segment.ready {
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      .badge-segment.unlocked {
        box-shadow: 0 0 25px rgba(34, 197, 94, 0.4),
          0 4px 12px rgba(0, 0, 0, 0.3);
      }
      @keyframes badgePulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
            0 4px 12px rgba(0, 0, 0, 0.3);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 30px rgba(59, 130, 246, 0.8),
            0 6px 16px rgba(0, 0, 0, 0.4);
        }
      }
      .badge-segment-icon {
        font-size: 1.1rem;
      }
      .badge-segment-progress {
        font-size: 0.7rem;
        opacity: 0.8;
      }

      /* Mini-Badges auf Karten */
      .badge-mini {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        font-size: 0.7rem;
        border: 2px solid;
        background: rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
      }
      .badge-mini.segment-1 {
        border-color: #a78bfa;
        color: #c4b5fd;
      }
      .badge-mini.segment-2 {
        border-color: #60a5fa;
        color: #93c5fd;
      }
      .badge-mini.segment-3 {
        border-color: #34d399;
        color: #6ee7b7;
      }
      .badge-mini.segment-4 {
        border-color: #f59e0b;
        color: #fcd34d;
      }
      .badge-mini.segment-5 {
        border-color: #ec4899;
        color: #f9a8d4;
      }
      .badge-mini.segment-6 {
        border-color: #fbbf24;
        color: #fde68a;
      }

      /* Hotkeys-Kachel */
      .hotkeys-card {
        border: 2px solid #fbbf24;
        background: radial-gradient(
            circle at top left,
            rgba(251, 191, 36, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(245, 158, 11, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
      }
      .hotkeys-card:hover {
        border-color: #fcd34d;
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
        transform: translateY(-2px);
      }

      /* Kali-Tools-Kachel */
      .kali-tools-card {
        border: 2px solid #ef4444;
        background: radial-gradient(
            circle at top left,
            rgba(239, 68, 68, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(220, 38, 38, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
      }
      .kali-tools-card:hover {
        border-color: #f87171;
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        transform: translateY(-2px);
      }

      /* Beginner-Mistakes-Kachel */
      .mistakes-card {
        border: 2px solid #38bdf8;
        background: radial-gradient(
            circle at top left,
            rgba(56, 189, 248, 0.18),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(14, 165, 233, 0.14),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(56, 189, 248, 0.35);
      }
      .mistakes-card:hover {
        border-color: #7dd3fc;
        box-shadow: 0 0 28px rgba(56, 189, 248, 0.5);
        transform: translateY(-2px);
      }

      /* FAQ-Kachel */
      .faq-card {
        border: 2px solid #10b981;
        background: radial-gradient(
            circle at top left,
            rgba(16, 185, 129, 0.18),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(5, 150, 105, 0.14),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.35);
      }
      .faq-card:hover {
        border-color: #34d399;
        box-shadow: 0 0 28px rgba(16, 185, 129, 0.5);
        transform: translateY(-2px);
      }

      /* Modern-Tools-Kachel */
      .modern-tools-card {
        border: 2px solid #a855f7;
        background: radial-gradient(
            circle at top left,
            rgba(168, 85, 247, 0.2),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(139, 92, 246, 0.15),
            transparent 55%
          ),
          #020617;
        box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
      }
      .modern-tools-card:hover {
        border-color: #c084fc;
        box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
        transform: translateY(-2px);
      }

      /* Masterquiz-Modal */
      .master-quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .master-quiz-modal.hidden {
        display: none;
      }
      .master-quiz-modal-inner {
        position: relative;
        z-index: 61;
        width: min(600px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 90vh;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }
      .master-quiz-scenario {
        padding: 0.8rem;
        border-radius: 0.7rem;
        border: 1px solid #374151;
        background: rgba(59, 130, 246, 0.1);
        margin-bottom: 1rem;
        font-size: 0.9rem;
        line-height: 1.6;
      }

      /* Celebration Animation für erfolgreiche Quiz-Abschlüsse */
      .quiz-modal.celebration,
      .master-quiz-modal.celebration {
        animation: celebrationBreakout 1.2s ease-out forwards;
      }

      @keyframes celebrationBreakout {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        30% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(0.8);
          opacity: 0;
        }
      }

      .celebration-particle {
        position: fixed;
        width: 8px;
        height: 8px;
        background: radial-gradient(circle, #fbbf24, #f59e0b);
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        animation: particleFloat 1.5s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(var(--tx), var(--ty)) scale(0);
        }
      }

      /* Fehler-Feedback: Roter Flash + Shake */
      .quiz-modal.error-feedback,
      .master-quiz-modal.error-feedback {
        animation: errorShake 0.5s ease-in-out;
      }

      @keyframes errorShake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-5px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(5px);
        }
      }

      .quiz-modal-inner.error-flash,
      .master-quiz-modal-inner.error-flash {
        animation: errorFlash 0.4s ease-out;
      }

      /* Command Detail Modal - MODERN REDESIGN */
      .command-modal {
        backdrop-filter: blur(8px);
      }
      .command-modal .master-quiz-modal-inner {
        display: flex;
        flex-direction: column;
        gap: 0;
        background: linear-gradient(135deg, #0f172a 0%, #1a2847 100%);
        border: 1px solid rgba(59, 130, 246, 0.3);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(59, 130, 246, 0.1);
        max-height: 90vh;
        width: min(900px, 100% - 2rem);
        overflow: hidden;
      }
      .command-modal .quiz-header {
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.1),
          rgba(99, 102, 241, 0.05)
        );
        border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        padding: 1.5rem 1.5rem;
        margin: 0;
      }
      .command-modal .quiz-header .quiz-title {
        font-size: 1.4rem;
        font-weight: 700;
        background: linear-gradient(135deg, #3b82f6, #60a5fa);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: -0.5px;
      }
      .command-modal .quiz-header .quiz-level-pill {
        font-size: 0.8rem;
        background: rgba(59, 130, 246, 0.15);
        border: 1px solid rgba(59, 130, 246, 0.3);
        color: #93c5fd;
        font-weight: 500;
      }
      .command-modal .quiz-body {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
        padding: 1.5rem;
        padding-top: 1.5rem;
        overflow-y: auto;
        flex: 1;
        min-height: 0;
      }
      .command-modal .command-summary {
        font-size: 1rem;
        color: #e0e7ff;
        line-height: 1.7;
        margin: 0;
        padding: 1rem 1.2rem;
        background: rgba(99, 102, 241, 0.08);
        border-left: 4px solid #6366f1;
        border-radius: 0.5rem;
      }
      .command-modal #command-modal-detail {
        padding: 1rem 1.2rem;
        background: rgba(34, 197, 94, 0.08);
        border-left: 4px solid #22c55e;
        border-radius: 0.5rem;
        color: #bbf7d0;
        line-height: 1.6;
        margin: 0;
      }
      .command-modal .command-meta-grid {
        display: grid;
        gap: 1.2rem;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }
      .command-modal .command-section {
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border-radius: 0.75rem;
        padding: 1.2rem;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
      }
      .command-modal .command-section:hover {
        border-color: rgba(59, 130, 246, 0.3);
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.06),
          rgba(99, 102, 241, 0.04)
        );
        box-shadow: 0 8px 16px rgba(59, 130, 246, 0.1);
      }
      .command-modal .command-section h3 {
        margin: 0 0 0.8rem;
        font-size: 1.1rem;
        font-weight: 600;
        color: #93c5fd;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.9;
      }
      .command-modal .flag-pill {
        display: inline-flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.3rem;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.15),
          rgba(99, 102, 241, 0.08)
        );
        border: 1px solid rgba(59, 130, 246, 0.4);
        color: #bfdbfe;
        font-weight: 600;
        margin: 0.2rem 0.2rem 0.2rem 0;
        font-size: 0.85rem;
        transition: all 0.2s ease;
      }
      .command-modal .flag-pill:hover {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.2),
          rgba(99, 102, 241, 0.12)
        );
        border-color: #3b82f6;
        transform: translateY(-2px);
      }
      .command-modal .flag-pill small {
        display: block;
        color: #cbd5e1;
        font-weight: 400;
        font-size: 0.75rem;
      }
      .command-modal .flags-search-container {
        margin-bottom: 1.5rem;
      }
      .command-modal .flags-search-input {
        width: 100%;
        padding: 0.875rem 1rem;
        background: rgba(15, 23, 42, 0.6);
        border: 2px solid rgba(59, 130, 246, 0.3);
        border-radius: 0.75rem;
        color: #e0e7ff;
        font-size: 1rem;
        font-family: inherit;
        transition: all 0.3s ease;
        outline: none;
      }
      .command-modal .flags-search-input:focus {
        border-color: #3b82f6;
        background: rgba(15, 23, 42, 0.8);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .command-modal .flags-search-input::placeholder {
        color: #64748b;
      }
      .command-modal .flags-search-info {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: #94a3b8;
        font-style: italic;
      }
      .command-modal .flags-no-results {
        text-align: center;
        padding: 2rem;
        color: #94a3b8;
        font-size: 1rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.75rem;
        margin-top: 1rem;
      }
      .command-modal .pitfalls-list {
        margin: 0;
        padding-left: 1.5rem;
        color: #e0e7ff;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .command-modal .pitfalls-list li {
        line-height: 1.5;
      }
      .command-modal .example-list {
        display: grid;
        gap: 0.8rem;
      }
      .command-modal .example-item {
        padding: 1rem;
        border-radius: 0.6rem;
        background: linear-gradient(
          135deg,
          rgba(16, 185, 129, 0.1),
          rgba(5, 150, 105, 0.05)
        );
        border: 1px solid rgba(16, 185, 129, 0.3);
        transition: all 0.2s ease;
      }
      .command-modal .example-item:hover {
        border-color: rgba(16, 185, 129, 0.5);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.1);
      }
      .command-modal .example-item code {
        display: block;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        color: #6ee7b7;
        font-size: 0.9rem;
        padding: 0.5rem;
        background: rgba(15, 23, 42, 0.5);
        border-radius: 0.4rem;
        margin-bottom: 0.5rem;
        overflow-x: auto;
      }
      .command-modal .quiz-footer {
        background: linear-gradient(
          90deg,
          rgba(59, 130, 246, 0.05),
          rgba(99, 102, 241, 0.02)
        );
        border-top: 1px solid rgba(59, 130, 246, 0.2);
        padding: 1rem 1.5rem;
        margin-top: auto;
      }

      @keyframes errorFlash {
        0% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
        50% {
          box-shadow: 0 22px 60px rgba(239, 68, 68, 0.6),
            0 0 40px rgba(239, 68, 68, 0.4);
          border-color: #ef4444;
        }
        100% {
          box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        }
      }

      /* Hotkeys-Modal */
      .hotkeys-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .hotkeys-modal.hidden {
        display: none;
      }
      .hotkeys-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 90vh;
        overflow-y: auto;
        overflow-y: auto;
      }
      .hotkeys-section {
        margin-bottom: 1.5rem;
      }
      .hotkeys-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #fbbf24;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(251, 191, 36, 0.3);
      }
      .hotkeys-item {
        padding: 0.4rem 0.6rem;
        margin-bottom: 0.3rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #fbbf24;
      }
      .hotkeys-shortcut {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
      }
      .hotkeys-description {
        color: #d1d5db;
        margin-left: 0.5rem;
      }

      /* Modern Tools Modal */
      .modern-tools-section {
        margin-bottom: 2rem;
      }
      .modern-tools-section-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #a855f7;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid rgba(168, 85, 247, 0.3);
      }
      .modern-tools-command-box {
        background: rgba(168, 85, 247, 0.1);
        border: 1px solid rgba(168, 85, 247, 0.3);
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 1rem 0;
      }
      .modern-tools-command-box code {
        color: #c084fc;
        font-size: 0.95rem;
        word-break: break-all;
      }
      .modern-tools-tool {
        background: rgba(168, 85, 247, 0.05);
        border: 1px solid rgba(168, 85, 247, 0.2);
        border-radius: 0.7rem;
        padding: 1rem;
        margin-bottom: 1.5rem;
      }
      .modern-tools-tool-header {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        margin-bottom: 1rem;
      }
      .modern-tools-tool-icon {
        font-size: 1.5rem;
        line-height: 1;
      }
      .modern-tools-tool-name {
        font-size: 1.1rem;
        font-weight: 600;
        color: #c084fc;
        margin-bottom: 0.3rem;
      }
      .modern-tools-tool-desc {
        color: #cbd5e1;
        font-size: 0.95rem;
      }
      .modern-tools-example {
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #a855f7;
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-bottom: 0.75rem;
      }
      .modern-tools-example-level {
        color: #a855f7;
        font-weight: 600;
        margin-bottom: 0.5rem;
        font-size: 0.95rem;
      }
      .modern-tools-example-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 0.5rem;
      }
      @media (max-width: 768px) {
        .modern-tools-example-row {
          grid-template-columns: 1fr;
        }
      }
      .modern-tools-example-new,
      .modern-tools-example-old {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0.4rem;
        padding: 0.6rem;
      }
      .modern-tools-example-label {
        color: #94a3b8;
        font-size: 0.85rem;
        margin-bottom: 0.3rem;
      }
      .modern-tools-example-new code {
        color: #34d399;
      }
      .modern-tools-example-old code {
        color: #f87171;
      }
      .modern-tools-example-note {
        color: #94a3b8;
        font-size: 0.9rem;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        white-space: pre-line;
      }
      .modern-tools-syntax-item {
        background: rgba(168, 85, 247, 0.05);
        border: 1px solid rgba(168, 85, 247, 0.2);
        border-radius: 0.7rem;
        padding: 1rem;
        margin-bottom: 1rem;
      }
      .modern-tools-syntax-title {
        font-size: 1rem;
        font-weight: 600;
        color: #c084fc;
        margin-bottom: 0.75rem;
      }
      .modern-tools-syntax-content {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0.4rem;
        padding: 0.6rem;
        margin-bottom: 0.75rem;
      }
      .modern-tools-syntax-content code {
        color: #c084fc;
      }
      .modern-tools-table {
        width: 100%;
        border-collapse: collapse;
        margin: 0.75rem 0;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0.4rem;
        overflow: hidden;
      }
      .modern-tools-table thead {
        background: rgba(168, 85, 247, 0.2);
      }
      .modern-tools-table th {
        padding: 0.6rem;
        text-align: left;
        color: #c084fc;
        font-weight: 600;
        border-bottom: 2px solid rgba(168, 85, 247, 0.3);
      }
      .modern-tools-table td {
        padding: 0.6rem;
        color: #cbd5e1;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }
      .modern-tools-table td code {
        color: #93c5fd;
      }
      .modern-tools-examples {
        margin-top: 0.75rem;
      }
      .modern-tools-example-code {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 0.4rem;
        padding: 0.5rem 0.6rem;
        margin-bottom: 0.4rem;
      }
      .modern-tools-example-code code {
        color: #c084fc;
        font-size: 0.9rem;
      }

      /* Beginner-Mistakes Modal */
      .mistakes-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .mistake-row {
        width: 100%;
        text-align: left;
        background: rgba(59, 130, 246, 0.06);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 0.7rem;
        padding: 0.75rem 0.85rem;
        color: #e5e7eb;
        cursor: pointer;
        transition: border-color 0.15s ease, transform 0.1s ease;
      }
      .mistake-row:hover {
        border-color: #93c5fd;
        transform: translateY(-1px);
      }
      .mistake-row-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.35rem;
        font-weight: 600;
      }
      .mistake-index {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 0.5rem;
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
        font-weight: 700;
      }
      .mistake-title {
        flex: 1;
        font-size: 0.95rem;
      }
      .mistake-description {
        font-size: 0.9rem;
        color: #cbd5e1;
        margin: 0;
      }
      .mistake-example {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        margin-top: 0.35rem;
        padding: 0.4rem 0.55rem;
        border-radius: 0.5rem;
        background: rgba(34, 197, 94, 0.08);
        border: 1px solid rgba(34, 197, 94, 0.3);
        color: #bbf7d0;
        font-size: 0.85rem;
      }
      .mistake-example code {
        background: rgba(15, 23, 42, 0.6);
        padding: 0.2rem 0.45rem;
        border-radius: 0.45rem;
        border: 1px solid rgba(34, 197, 94, 0.4);
        color: #22c55e;
      }
      .mistake-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        align-items: center;
        margin-top: 0.35rem;
        font-size: 0.8rem;
        color: #9ca3af;
      }

      /* FAQ Knowledge Base Modal */
      .faq-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .faq-modal.hidden {
        display: none;
      }
      .faq-modal-inner {
        position: relative;
        z-index: 61;
        width: min(1000px, 100% - 2rem);
        height: min(90vh, 800px);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .faq-modal-body {
        display: flex;
        flex: 1;
        overflow: hidden;
        gap: 0;
      }

      /* FAQ Sidebar */
      .faq-sidebar {
        width: 280px;
        background: rgba(15, 23, 42, 0.5);
        border-right: 1px solid #1f2937;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        flex-shrink: 0;
      }
      .faq-search-container {
        padding: 1rem;
        border-bottom: 1px solid #1f2937;
        position: sticky;
        top: 0;
        background: rgba(15, 23, 42, 0.95);
        backdrop-filter: blur(8px);
        z-index: 10;
      }
      .faq-search-input {
        width: 100%;
        padding: 0.6rem 0.9rem;
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 0.6rem;
        color: #e5e7eb;
        font-size: 0.85rem;
        font-family: inherit;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .faq-search-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .faq-search-input::placeholder {
        color: #6b7280;
      }

      .faq-category-list {
        padding: 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }
      .faq-category-item {
        padding: 0.65rem 0.85rem;
        border-radius: 0.6rem;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid transparent;
        color: #d1d5db;
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.15s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .faq-category-item:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: #334155;
      }
      .faq-category-item.active {
        background: rgba(59, 130, 246, 0.15);
        border-color: #3b82f6;
        color: #93c5fd;
        font-weight: 600;
      }
      .faq-category-icon {
        font-size: 1.1rem;
        flex-shrink: 0;
      }
      .faq-category-name {
        flex: 1;
      }
      .faq-category-count {
        font-size: 0.75rem;
        color: #9ca3af;
        background: rgba(255, 255, 255, 0.08);
        padding: 0.15rem 0.4rem;
        border-radius: 999px;
      }
      .faq-category-item.active .faq-category-count {
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
      }

      /* FAQ Content Area */
      .faq-content {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
        max-height: calc(90vh - 120px);
      }
      .faq-category-header {
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
        border-bottom: 2px solid #1f2937;
      }
      .faq-category-header h2 {
        margin: 0;
        font-size: 1.25rem;
        color: #f3f4f6;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .faq-category-header .faq-category-icon {
        font-size: 1.4rem;
      }

      /* FAQ Accordion Items */
      .faq-accordion-item {
        border: 1px solid #1f2937;
        border-radius: 0.75rem;
        background: rgba(255, 255, 255, 0.02);
        overflow: hidden;
        transition: all 0.2s ease;
      }
      .faq-accordion-item:hover {
        border-color: #334155;
        background: rgba(255, 255, 255, 0.04);
      }
      .faq-accordion-item.expanded {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.05);
      }
      .faq-question {
        padding: 1rem 1.25rem;
        cursor: pointer;
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        user-select: none;
      }
      .faq-question:hover {
        background: rgba(255, 255, 255, 0.03);
      }
      .faq-question-text {
        flex: 1;
        font-size: 0.95rem;
        font-weight: 600;
        color: #e5e7eb;
        line-height: 1.5;
      }
      .faq-question-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-shrink: 0;
      }
      .faq-bookmark-btn {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.5rem;
        border: 1px solid transparent;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        transition: all 0.15s ease;
        font-size: 1rem;
      }
      .faq-bookmark-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: #334155;
      }
      .faq-bookmark-btn.bookmarked {
        color: #fbbf24;
        border-color: rgba(251, 191, 36, 0.3);
        background: rgba(251, 191, 36, 0.1);
      }
      .faq-expand-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9ca3af;
        transition: transform 0.2s ease;
        flex-shrink: 0;
      }
      .faq-accordion-item.expanded .faq-expand-icon {
        transform: rotate(180deg);
      }
      .faq-answer {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding: 0 1.5rem;
      }
      .faq-accordion-item.expanded .faq-answer {
        max-height: 2000px;
        padding: 0 1.5rem 1.75rem;
      }
      .faq-answer-content {
        padding-top: 1rem;
        color: #d1d5db;
        font-size: 0.9rem;
        line-height: 1.7;
      }
      .faq-answer-content code {
        background: rgba(59, 130, 246, 0.15);
        padding: 0.2rem 0.4rem;
        border-radius: 0.3rem;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 0.9em;
        color: #93c5fd;
        border: 1px solid rgba(59, 130, 246, 0.3);
      }
      .faq-answer-content pre {
        background: rgba(15, 23, 42, 0.8);
        padding: 1rem;
        border-radius: 0.5rem;
        border: 1px solid #1f2937;
        overflow-x: auto;
        margin: 0.75rem 0;
      }
      .faq-answer-content pre code {
        background: transparent;
        padding: 0;
        border: none;
        color: #e5e7eb;
      }
      .faq-example-block {
        background: rgba(59, 130, 246, 0.08);
        border-left: 3px solid #3b82f6;
        padding: 1rem 1.25rem;
        margin: 1rem 0;
        border-radius: 0.4rem;
      }
      .faq-example-label {
        font-weight: 600;
        color: #93c5fd;
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
        display: block;
      }
      .faq-answer-content mark {
        background: rgba(251, 191, 36, 0.3);
        color: #fde68a;
        padding: 0.1rem 0.2rem;
        border-radius: 0.2rem;
      }

      /* Verwandte Commands */
      .faq-related-commands {
        margin-top: 1.25rem;
        padding-top: 1.25rem;
        border-top: 1px solid #1f2937;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }
      .faq-related-commands-label {
        font-size: 0.8rem;
        color: #9ca3af;
        font-weight: 600;
      }
      .faq-related-command-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.4rem 0.65rem;
        border-radius: 0.5rem;
        background: rgba(59, 130, 246, 0.12);
        border: 1px solid rgba(59, 130, 246, 0.3);
        color: #93c5fd;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
        text-decoration: none;
      }
      .faq-related-command-badge:hover {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
        transform: translateY(-1px);
      }

      /* Empty State */
      .faq-empty-state {
        text-align: center;
        padding: 3rem 1.5rem;
        color: #9ca3af;
      }
      .faq-empty-state-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
      }
      .faq-empty-state-text {
        font-size: 1rem;
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .faq-modal-inner {
          width: 100%;
          height: 100vh;
          border-radius: 0;
          max-height: none;
        }
        .faq-modal-body {
          flex-direction: column;
        }
        .faq-sidebar {
          width: 100%;
          max-height: 200px;
          border-right: none;
          border-bottom: 1px solid #1f2937;
        }
        .faq-content {
          padding: 1rem;
        }
      }

      /* Kali-Tools-Modal */
      .kali-tools-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
      }
      .kali-tools-modal.hidden {
        display: none;
      }
      .kali-tools-modal-inner {
        position: relative;
        z-index: 61;
        width: min(700px, 100% - 2rem);
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.2rem 1.5rem 1.3rem;
        max-height: 90vh;
        overflow-y: auto;
      }
      .kali-tools-section {
        margin-bottom: 1.5rem;
      }
      .kali-tools-section-title {
        font-size: 1.1rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.5rem;
        padding-bottom: 0.3rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-item {
        padding: 0.6rem 0.8rem;
        margin-bottom: 0.5rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #ef4444;
      }
      .kali-tools-name {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #93c5fd;
        font-weight: 600;
        display: block;
        margin-bottom: 0.3rem;
      }
      .kali-tools-description {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.5;
        margin-bottom: 0.3rem;
      }
      .kali-tools-benefit {
        color: #a78bfa;
        font-size: 0.9rem;
        font-style: italic;
        margin-top: 0.3rem;
      }
      .kali-tools-command {
        font-family: "JetBrains Mono", ui-monospace, monospace;
        color: #34d399;
        font-size: 0.85rem;
        background: rgba(52, 211, 153, 0.1);
        padding: 0.2rem 0.4rem;
        border-radius: 0.3rem;
        display: inline-block;
        margin-top: 0.3rem;
      }
      .kali-tools-example {
        margin-top: 0.5rem;
        padding: 0.6rem;
        border-radius: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(239, 68, 68, 0.2);
        position: relative;
      }
      .kali-tools-example-title {
        font-size: 0.85rem;
        font-weight: 600;
        color: #ef4444;
        margin-bottom: 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .kali-tools-example-content {
        color: #d1d5db;
        font-size: 0.9rem;
        line-height: 1.6;
      }
      .kali-tools-example-blurred {
        filter: blur(5px);
        user-select: none;
        pointer-events: none;
        position: relative;
        overflow: hidden;
      }
      .kali-tools-example-blurred::after {
        content: "";
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(2px);
      }
      .kali-tools-chicken-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.6rem;
        margin-left: 0.5rem;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.4);
        border-radius: 0.4rem;
        color: #fca5a5;
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
      }
      .kali-tools-chicken-btn:hover {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.6);
        transform: scale(1.05);
      }
      .kali-tools-chicken-btn:active {
        transform: scale(0.95);
      }
      .kali-tools-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 70;
      }
      .kali-tools-overlay.hidden {
        display: none;
      }
      .kali-tools-overlay-inner {
        position: relative;
        z-index: 71;
        width: min(600px, 100% - 2rem);
        max-height: 80vh;
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
        padding: 1.5rem;
        overflow-y: auto;
      }
      .kali-tools-overlay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.8rem;
        border-bottom: 2px solid rgba(239, 68, 68, 0.3);
      }
      .kali-tools-overlay-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #ef4444;
      }
      .kali-tools-overlay-close {
        background: transparent;
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        padding: 0.3rem 0.6rem;
        border-radius: 0.4rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }
      .kali-tools-overlay-close:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
      }
      .kali-tools-overlay-content {
        color: #d1d5db;
        font-size: 0.95rem;
        line-height: 1.7;
      }
      .kali-tools-overlay-content .kali-tools-name {
        margin-bottom: 0.5rem;
      }
      .kali-tools-overlay-content .kali-tools-command {
        margin-top: 0.5rem;
        display: block;
      }

      /* Kali-Tools Badge Container */
      .kali-tools-badges-container {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.8rem;
        padding-top: 0.8rem;
        border-top: 1px solid rgba(239, 68, 68, 0.2);
      }
      .kali-tools-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.7rem;
        border-radius: 0.5rem;
        font-size: 0.85rem;
        border: 1px solid;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .kali-tools-badge.locked {
        background: rgba(239, 68, 68, 0.1);
        border-color: rgba(239, 68, 68, 0.3);
        color: #fca5a5;
        opacity: 0.6;
      }
      .kali-tools-badge.unlocked {
        background: rgba(34, 197, 94, 0.15);
        border-color: rgba(34, 197, 94, 0.4);
        color: #86efac;
        opacity: 1;
      }
      .kali-tools-badge:hover {
        transform: scale(1.05);
        opacity: 1;
      }
      .kali-tools-badge-icon {
        font-size: 1rem;
      }
      .kali-tools-badge-name {
        font-weight: 500;
      }
      .kali-tools-badge-progress {
        font-size: 0.75rem;
        opacity: 0.8;
        margin-left: 0.2rem;
      }

      /* Desktop Layout - 16:9 Optimiert */
      main {
        max-width: 100%;
        margin: 0 auto;
        padding: 1rem 2rem 2rem;
        width: 100%;
      }

      .commands-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 0.8rem;
        width: 100%;
      }

      /* Header für Desktop optimiert */
      header {
        padding: 1rem 2rem 0.75rem;
      }

      .header-inner {
        max-width: 100%;
      }
      .command-card {
        border-radius: 0.9rem;
        border: 1px solid #1f2937;
        background: radial-gradient(
            circle at top left,
            rgba(56, 189, 248, 0.12),
            transparent 55%
          ),
          radial-gradient(
            circle at bottom right,
            rgba(129, 140, 248, 0.12),
            transparent 55%
          ),
          #020617;
        padding: 0.9rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        cursor: pointer;
        transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
          border-color 0.08s ease-out;
      }
      .command-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
        border-color: #3b82f6;
      }
      .command-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.15rem;
        position: relative;
      }
      .command-faq-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        font-size: 0.75rem;
        border: 2px solid #3b82f6;
        background: rgba(59, 130, 246, 0.15);
        color: #93c5fd;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        margin-left: auto;
      }
      .command-faq-badge:hover {
        background: rgba(59, 130, 246, 0.25);
        border-color: #60a5fa;
        transform: scale(1.1);
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
      }
      .command-name {
        margin: 0;
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .command-name code {
        background: #020617;
        padding: 0.1rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        font-size: 0.85rem;
      }
      .command-tag {
        font-size: 0.7rem;
        color: #9ca3af;
      }
      .command-body {
        font-size: 0.85rem;
        color: #d1d5db;
      }
      .command-body p {
        margin: 0.1rem 0;
      }
      code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.85em;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }

      /* Quiz modal */
      .quiz-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.7);
        backdrop-filter: blur(6px);
        z-index: 40;
      }
      .quiz-modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      .quiz-modal.hidden {
        display: none;
      }
      .quiz-modal-inner {
        position: relative;
        z-index: 51;
        width: min(520px, 100% - 2rem);
        max-height: 95vh;
        height: auto;
        background: transparent;
        transition: opacity 0.25s ease;
        display: flex;
        flex-direction: column;
      }
      .quiz-modal-front,
      .quiz-modal-back {
        width: 100%;
        padding: 1rem 1.2rem 1.1rem;
        display: flex;
        flex-direction: column;
        height: auto;
        overflow: visible;
        background: #020617;
        border-radius: 1rem;
        border: 1px solid #1f2937;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.7);
      }
      .quiz-modal-front {
        position: relative;
      }
      .quiz-modal-back {
        position: relative;
        display: none;
        overflow-y: visible;
        max-height: none;
        height: auto;
      }
      .quiz-modal-inner.flipped .quiz-modal-front {
        display: none;
      }
      .quiz-modal-inner.flipped .quiz-modal-back {
        display: flex;
      }
      .quiz-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .quiz-title {
        font-size: 1rem;
        font-weight: 600;
      }
      .quiz-level-pill {
        font-size: 0.7rem;
        padding: 0.12rem 0.6rem;
        border-radius: 999px;
        border: 1px solid #374151;
        color: #9ca3af;
      }
      .quiz-close-btn {
        border: none;
        background: #111827;
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.8rem;
        color: #9ca3af;
        cursor: pointer;
      }
      .quiz-body {
        font-size: 0.85rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.7rem;
        margin-bottom: 0.7rem;
        max-height: none;
        overflow-y: visible;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        flex: 1;
        min-height: 0;
      }
      .quiz-modal-back .quiz-body {
        max-height: none;
        overflow-y: visible;
      }

      /* Responsive: Auf sehr kleinen Bildschirmen Scrollleiste erlauben */
      @media (max-height: 600px) {
        .quiz-modal-inner {
          max-height: 98vh;
        }
        .quiz-modal-back {
          overflow-y: auto;
        }
        .quiz-modal-back .quiz-body {
          overflow-y: visible;
        }
      }

      /* Verbesserte Schriftart für Erklärungen mit besserer Unterscheidung */
      .quiz-body code,
      .quiz-body .cmd-example,
      .quiz-command-info code,
      .complex-explanation code,
      .quiz-question-title code {
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          "Cascadia Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace !important;
        font-feature-settings: "zero", "onum", "calt" !important;
        font-variant-numeric: tabular-nums !important;
        letter-spacing: 0.02em !important;
        font-weight: 500 !important;
      }
      .quiz-question {
        padding: 0.6rem 0.7rem;
        border-radius: 0.7rem;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-question-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
      }
      .quiz-question-meta {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-bottom: 0.35rem;
      }
      .quiz-options {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .quiz-option {
        display: flex;
        gap: 0.4rem;
        align-items: flex-start;
        cursor: pointer;
      }
      .quiz-option input {
        margin-top: 0.12rem;
      }
      .quiz-option.highlight-correct {
        background: rgba(34, 197, 94, 0.15);
        border-left: 3px solid #22c55e;
        padding-left: 0.5rem;
        border-radius: 0.25rem;
      }
      .quiz-chicken-btn {
        margin-top: 0.5rem;
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        background: rgba(245, 158, 11, 0.15);
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 0.4rem;
        color: #fbbf24;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
      }
      .quiz-chicken-btn:hover {
        background: rgba(245, 158, 11, 0.25);
        border-color: rgba(245, 158, 11, 0.5);
        transform: translateY(-1px);
      }
      .quiz-chicken-btn:active {
        transform: translateY(0);
      }
      .quiz-chicken-btn-command {
        margin-top: 0.5rem;
        padding: 0.35rem 0.75rem;
        font-size: 0.75rem;
        background: rgba(245, 158, 11, 0.15);
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 0.4rem;
        color: #fbbf24;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        display: none;
      }
      .quiz-chicken-btn-command.visible {
        display: inline-block;
      }
      .quiz-chicken-btn-command:hover {
        background: rgba(245, 158, 11, 0.25);
        border-color: rgba(245, 158, 11, 0.5);
        transform: translateY(-1px);
      }
      .quiz-command-input {
        width: 100%;
        padding: 0.75rem;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        font-size: 0.9rem;
        background: rgba(15, 23, 42, 0.8);
        border: 2px solid rgba(59, 130, 246, 0.3);
        border-radius: 0.5rem;
        color: #e2e8f0;
        margin-top: 0.75rem;
        transition: border-color 0.2s ease;
      }
      .quiz-command-input:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
      }
      .quiz-command-input::placeholder {
        color: #64748b;
        font-style: italic;
      }
      .quiz-solution-preview {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(15, 23, 42, 0.95);
        border: 2px solid #3b82f6;
        border-radius: 0.5rem;
        padding: 1.5rem;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        max-width: 90%;
        text-align: center;
        animation: solutionFadeIn 0.3s ease;
      }
      .quiz-solution-preview code {
        display: block;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        font-size: 1rem;
        color: #22c55e;
        background: rgba(34, 197, 94, 0.1);
        padding: 0.75rem;
        border-radius: 0.4rem;
        margin-top: 0.5rem;
        word-break: break-all;
      }
      .quiz-solution-preview .countdown {
        font-size: 0.85rem;
        color: #fbbf24;
        margin-top: 0.5rem;
      }
      @keyframes solutionFadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.9);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }
      @keyframes solutionFadeOut {
        from {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        to {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.9);
        }
      }
      .quiz-command-wrapper {
        position: relative;
        margin-top: 0.75rem;
      }
      .quiz-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8rem;
      }
      .quiz-submit-btn {
        border: none;
        border-radius: 999px;
        padding: 0.45rem 0.9rem;
        background: linear-gradient(135deg, #22c55e, #4ade80);
        color: #022c22;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .quiz-submit-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
      }
      .quiz-submit-btn:disabled {
        opacity: 0.5;
        cursor: default;
      }
      /* Quiz-Button im Command-Modal mit höchstem z-index und Glow */
      @keyframes quizButtonGlow {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
            0 4px 12px rgba(59, 130, 246, 0.3);
        }
        50% {
          box-shadow: 0 0 30px rgba(59, 130, 246, 0.7),
            0 4px 16px rgba(59, 130, 246, 0.4);
        }
      }
      .quiz-feedback {
        font-size: 0.8rem;
      }
      .command-card.quiz-done {
        border-color: #22c55e;
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6),
          0 14px 30px rgba(22, 163, 74, 0.35);
        position: relative;
      }
      .command-card.quiz-done::after {
        content: "✓ Quiz bestanden";
        position: absolute;
        top: 0.5rem;
        right: 0.7rem;
        font-size: 0.65rem;
        padding: 0.12rem 0.45rem;
        border-radius: 999px;
        background: rgba(22, 163, 74, 0.12);
        border: 1px solid rgba(22, 163, 74, 0.7);
        color: #bbf7d0;
      }
      .command-card.quiz-done.flash-once {
        animation: cardPulse 0.9s ease-out;
      }
      @keyframes cardPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.8);
        }
        100% {
          box-shadow: 0 0 0 16px rgba(34, 197, 94, 0);
        }
      }
      /* Category color accents (subtle contour lines) */
      .command-card {
        position: relative;
      }
      .command-card::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 6px;
        border-radius: 0.9rem 0 0 0.9rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 180ms ease;
      }
      .command-card.category-navigation::before {
        background: linear-gradient(#60a5fa, #3b82f6);
        opacity: 0.95;
      }
      .command-card.category-listing::before {
        background: linear-gradient(#f59e0b, #f97316);
        opacity: 0.95;
      }
      .command-card.category-search::before {
        background: linear-gradient(#a78bfa, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-pipes::before {
        background: linear-gradient(#34d399, #10b981);
        opacity: 0.95;
      }
      .command-card.category-redirect::before {
        background: linear-gradient(#fb7185, #ef4444);
        opacity: 0.95;
      }
      .command-card.category-workflow::before {
        background: linear-gradient(#60a5fa, #f59e0b);
        opacity: 0.95;
      }
      .command-card.category-files::before {
        background: linear-gradient(#ec4899, #db2777);
        opacity: 0.95;
      }
      .command-card.category-system::before {
        background: linear-gradient(#8b5cf6, #7c3aed);
        opacity: 0.95;
      }
      .command-card.category-permissions::before {
        background: linear-gradient(#f59e0b, #d97706);
        opacity: 0.95;
      }

      /* Slightly lift the border color to match accent (keeps original look but clearer grouping) */
      .command-card.category-navigation {
        border-color: rgba(96, 165, 250, 0.22);
      }
      .command-card.category-listing {
        border-color: rgba(245, 158, 11, 0.18);
      }
      .command-card.category-search {
        border-color: rgba(167, 139, 250, 0.18);
      }
      .command-card.category-pipes {
        border-color: rgba(52, 211, 153, 0.18);
      }
      .command-card.category-redirect {
        border-color: rgba(251, 113, 133, 0.18);
      }
      .command-card.category-workflow {
        border-color: rgba(96, 165, 250, 0.12);
      }
      .command-card.category-files {
        border-color: rgba(236, 72, 153, 0.18);
      }
      .command-card.category-system {
        border-color: rgba(139, 92, 246, 0.18);
      }
      .command-card.category-permissions {
        border-color: rgba(245, 158, 11, 0.18);
      }

      /* Modal: command info and collapsible details */
      .quiz-command-info {
        margin-bottom: 0.6rem;
        padding: 0.6rem;
        border-radius: 0.6rem;
        border: 1px solid #111827;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.01),
          rgba(255, 255, 255, 0)
        );
        font-size: 0.9rem;
        color: #d1d5db;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .quiz-command-info .cmd-title code {
        font-size: 0.95rem;
        padding: 0.08rem 0.35rem;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: #020617;
      }
      .quiz-command-info .cmd-example {
        color: #c7d2fe;
        font-family: "JetBrains Mono", "Fira Code", "Source Code Pro",
          ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
        font-feature-settings: "zero", "onum";
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
      }
      .quiz-details-toggle {
        background: transparent;
        border: none;
        color: #93c5fd;
        cursor: pointer;
        padding: 0;
        font-size: 0.85rem;
        align-self: flex-start;
      }
      .quiz-details {
        margin-top: 0.4rem;
        padding: 0.5rem;
        border-radius: 0.6rem;
        background: rgba(255, 255, 255, 0.015);
        border: 1px solid #0b1220;
        font-size: 0.85rem;
        color: #cbd5e1;
        display: none;
        white-space: pre-wrap;
      }
      .complex-explanation {
        margin-top: 0.5rem;
        padding: 0.8rem;
        border-radius: 0.6rem;
        background: rgba(59, 130, 246, 0.05);
        border: 1px solid rgba(59, 130, 246, 0.2);
      }
      .complex-explanation > div {
        margin-bottom: 0.8rem;
      }
      .complex-explanation > div:last-child {
        margin-bottom: 0;
      }

      /* Mobile Media Queries */
      @media (max-width: 768px) {
        /* Mobile Layout */
        main {
          padding: 1rem 1rem 2rem;
        }

        header {
          padding: 1rem 1rem 0.75rem;
        }

        .header-inner {
          max-width: 100%;
        }

        /* Badges wurden entfernt */

        .main-badges-row {
          grid-template-columns: repeat(2, 1fr);
          gap: 0.75rem;
          padding: 0;
        }

        .sub-badges-row {
          grid-template-columns: repeat(2, 1fr);
          gap: 0.75rem;
          padding: 0;
          margin-top: 0.75rem;
        }

        .main-badge {
          max-width: 100%;
          padding: 0.85rem 0.9rem;
          height: auto;
          min-height: 110px;
        }

        .badge-group {
          max-width: 100%;
        }

        .main-badge-icon {
          font-size: 1rem;
        }

        .main-badge-name {
          font-size: 0.75rem;
        }

        .main-badge-progress-text {
          font-size: 0.65rem;
        }

        /* Kacheln auf Mobile - 1 Spalte */
        .commands-grid {
          grid-template-columns: 1fr;
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }
      }

      /* Sehr kleine Bildschirme */
      @media (max-width: 480px) {
        .main-badge {
          flex: 1 1 100%;
          min-width: 100%;
        }

        .main-badge-name {
          font-size: 0.7rem;
        }

        .main-badge-progress-text {
          font-size: 0.6rem;
        }
      }

      /* Desktop 16:9 Optimierung */
      @media (min-width: 1400px) {
        main {
          padding: 1rem 3rem 2rem;
        }

        .badges-header {
          padding: 1.5rem 1.2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
        }

        .main-badges-row {
          grid-template-columns: repeat(5, 1fr);
          max-width: 1100px;
          gap: 1.2rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(5, 1fr);
          max-width: 1100px;
          gap: 1.2rem;
        }

        .main-badge {
          max-width: 200px;
        }

        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
          gap: 0.7rem;
        }

        .command-card {
          padding: 0.8rem 0.9rem;
        }

        .command-name {
          font-size: 0.9rem;
        }

        .command-body {
          font-size: 0.8rem;
        }
      }

      /* Tablet Optimierung */
      @media (min-width: 769px) and (max-width: 1023px) {
        .main-badges-row {
          grid-template-columns: repeat(3, 1fr);
          gap: 0.9rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(3, 1fr);
          gap: 0.9rem;
        }
      }

      /* Mittlere Desktop-Größen */
      @media (min-width: 1024px) and (max-width: 1399px) {
        .main-badges-row {
          grid-template-columns: repeat(4, 1fr);
          gap: 1rem;
        }

        .sub-badges-row {
          grid-template-columns: repeat(4, 1fr);
          gap: 1rem;
        }
      }

      /* Sehr große Bildschirme - Noch mehr Kacheln */
      @media (min-width: 1920px) {
        .commands-grid {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
          gap: 0.6rem;
        }

        .command-card {
          padding: 0.7rem 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-inner">
        <h1>Linux IQ Challenge & persönliches CLI-Cheat-Sheet</h1>
        <div class="search-container">
          <input
            type="text"
            id="search-input"
            class="search-input"
            placeholder="Befehle und FAQ durchsuchen (z.B. 'ls', 'grep', 'chmod'...)"
            autocomplete="off"
          />
        </div>
        <div class="header-badge-filter" id="header-badge-filter"></div>
      </div>
    </header>
    <main>
      <section class="commands-grid" id="commands-grid">
        <article class="command-card" data-command="pwd" data-quiz-id="pwd">
          <div class="command-header">
            <h2 class="command-name"><code>pwd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Zeigt das aktuelle Arbeitsverzeichnis (Pfad) an.</p>
          </div>
        </article>

        <article class="command-card" data-command="cd" data-quiz-id="cd">
          <div class="command-header">
            <h2 class="command-name"><code>cd</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Wechselt in ein anderes Verzeichnis.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="cd .."
          data-quiz-id="cd_parent"
        >
          <div class="command-header">
            <h2 class="command-name"><code>cd ..</code></h2>
            <span class="command-tag">Navigation</span>
          </div>
          <div class="command-body">
            <p>Springt eine Ebene in das übergeordnete Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="ls" data-quiz-id="ls">
          <div class="command-header">
            <h2 class="command-name"><code>ls</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet Dateien und Ordner im aktuellen Verzeichnis.</p>
          </div>
        </article>

        <article class="command-card" data-command="grep" data-quiz-id="grep">
          <div class="command-header">
            <h2 class="command-name"><code>grep</code></h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>Durchsucht Text nach Mustern.</p>
          </div>
        </article>

        <article class="command-card" data-command="pipe" data-quiz-id="pipe">
          <div class="command-header">
            <h2 class="command-name"><code>|</code> (Pipe)</h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Verkettet Befehle: Ausgabe → Eingabe.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="redirect"
          data-quiz-id="redirect"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>&gt;</code>, <code>&gt;&gt;</code>, <code>2&gt;</code>
            </h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet Ausgaben und Fehler in Dateien um.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="nano_flow"
          data-quiz-id="nano_flow"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>nano</code> + <code>chmod +x</code> +
              <code>./script.sh</code>
            </h2>
            <span class="command-tag">Workflow</span>
          </div>
          <div class="command-body">
            <p>
              Ein kompletter Mini‑Workflow zum Schreiben und Ausführen eines
              Scripts.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -a" data-quiz-id="ls_a">
          <div class="command-header">
            <h2 class="command-name"><code>ls -a</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Listet alle Dateien, inklusive versteckter (beginnen mit .).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -la"
          data-quiz-id="ls_la"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -la</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="mkdir" data-quiz-id="mkdir">
          <div class="command-header">
            <h2 class="command-name"><code>mkdir</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen neuen Ordner.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="mkdir -p"
          data-quiz-id="mkdir_p"
        >
          <div class="command-header">
            <h2 class="command-name"><code>mkdir -p</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="mv" data-quiz-id="mv">
          <div class="command-header">
            <h2 class="command-name"><code>mv</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Verschiebt Dateien/Ordner oder benennt sie um.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp" data-quiz-id="cp">
          <div class="command-header">
            <h2 class="command-name"><code>cp</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="cp -r" data-quiz-id="cp_r">
          <div class="command-header">
            <h2 class="command-name"><code>cp -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Kopiert einen Ordner rekursiv mit Inhalt.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm" data-quiz-id="rm">
          <div class="command-header">
            <h2 class="command-name"><code>rm</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Dateien.</p>
          </div>
        </article>

        <article class="command-card" data-command="rm -r" data-quiz-id="rm_r">
          <div class="command-header">
            <h2 class="command-name"><code>rm -r</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Löscht Ordner rekursiv inkl. aller Inhalte.</p>
          </div>
        </article>

        <article class="command-card" data-command="cat" data-quiz-id="cat">
          <div class="command-header">
            <h2 class="command-name"><code>cat</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Gibt den Inhalt einer Datei auf stdout aus.</p>
          </div>
        </article>

        <article class="command-card" data-command="sort" data-quiz-id="sort">
          <div class="command-header">
            <h2 class="command-name"><code>sort</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen alphabetisch.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="sort -n"
          data-quiz-id="sort_n"
        >
          <div class="command-header">
            <h2 class="command-name"><code>sort -n</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).</p>
          </div>
        </article>

        <article class="command-card" data-command="uniq" data-quiz-id="uniq">
          <div class="command-header">
            <h2 class="command-name"><code>uniq</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Entfernt doppelte aufeinanderfolgende Zeilen.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -name"
          data-quiz-id="find_name"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>find . -name "Muster"</code>
            </h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster
              passt.
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="find . -maxdepth 1 -type d"
          data-quiz-id="find_maxdepth"
        >
          <div class="command-header">
            <h2 class="command-name">
              <code>find . -maxdepth 1 -type d</code>
            </h2>
            <span class="command-tag">Suche</span>
          </div>
          <div class="command-body">
            <p>
              Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).
            </p>
          </div>
        </article>

        <article class="command-card" data-command="ls -R" data-quiz-id="ls_R">
          <div class="command-header">
            <h2 class="command-name"><code>ls -R</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und
              Dateien darunter).
            </p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="ls -aR"
          data-quiz-id="ls_aR"
        >
          <div class="command-header">
            <h2 class="command-name"><code>ls -aR</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>
              Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="tree" data-quiz-id="tree">
          <div class="command-header">
            <h2 class="command-name"><code>tree</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt Verzeichnisstruktur in Baumform.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -d"
          data-quiz-id="tree_d"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -d</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Zeigt nur Ordner (directory-only mode).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="tree -L"
          data-quiz-id="tree_L"
        >
          <div class="command-header">
            <h2 class="command-name"><code>tree -L</code></h2>
            <span class="command-tag">Auflisten</span>
          </div>
          <div class="command-body">
            <p>Begrenzt die Tiefe der rekursiven Baumdarstellung.</p>
          </div>
        </article>

        <article class="command-card" data-command="echo" data-quiz-id="echo">
          <div class="command-header">
            <h2 class="command-name"><code>echo</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Gibt Text im Terminal aus.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">"
          data-quiz-id="redirect_overwrite"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Ausgabe in eine Datei um (überschreibt).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command=">>"
          data-quiz-id="redirect_append"
        >
          <div class="command-header">
            <h2 class="command-name"><code>&gt;&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Hängt die Ausgabe ans Ende einer Datei an.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="2>"
          data-quiz-id="redirect_stderr"
        >
          <div class="command-header">
            <h2 class="command-name"><code>2&gt;</code></h2>
            <span class="command-tag">Umleitung</span>
          </div>
          <div class="command-body">
            <p>Leitet die Fehlerausgabe (stderr) in eine Datei.</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="whoami"
          data-quiz-id="whoami"
        >
          <div class="command-header">
            <h2 class="command-name"><code>whoami</code></h2>
            <span class="command-tag">System</span>
          </div>
          <div class="command-body">
            <p>Zeigt den aktuellen Benutzer.</p>
          </div>
        </article>

        <article class="command-card" data-command="chmod" data-quiz-id="chmod">
          <div class="command-header">
            <h2 class="command-name"><code>chmod</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Dateirechte (read/write/execute).</p>
          </div>
        </article>

        <article
          class="command-card"
          data-command="chmod -R"
          data-quiz-id="chmod_R"
        >
          <div class="command-header">
            <h2 class="command-name"><code>chmod -R</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert Rechte rekursiv für Ordner + Unterordner.</p>
          </div>
        </article>

        <article class="command-card" data-command="chown" data-quiz-id="chown">
          <div class="command-header">
            <h2 class="command-name"><code>chown</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert den Besitzer einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="chgrp" data-quiz-id="chgrp">
          <div class="command-header">
            <h2 class="command-name"><code>chgrp</code></h2>
            <span class="command-tag">Rechte</span>
          </div>
          <div class="command-body">
            <p>Ändert nur die Gruppenzugehörigkeit einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="touch" data-quiz-id="touch">
          <div class="command-header">
            <h2 class="command-name"><code>touch</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>
              Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.
            </p>
          </div>
        </article>

        <article class="command-card" data-command="head" data-quiz-id="head">
          <div class="command-header">
            <h2 class="command-name"><code>head</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die ersten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="tail" data-quiz-id="tail">
          <div class="command-header">
            <h2 class="command-name"><code>tail</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>Zeigt die letzten Zeilen einer Datei.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -l" data-quiz-id="wc_l">
          <div class="command-header">
            <h2 class="command-name"><code>wc -l</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Zeilen in einer Datei oder Eingabe.</p>
          </div>
        </article>

        <article class="command-card" data-command="wc -w" data-quiz-id="wc_w">
          <div class="command-header">
            <h2 class="command-name"><code>wc -w</code></h2>
            <span class="command-tag">Pipes</span>
          </div>
          <div class="command-body">
            <p>Zählt Wörter.</p>
          </div>
        </article>

        <article class="command-card" data-command="xargs" data-quiz-id="xargs">
          <div class="command-header">
            <h2 class="command-name"><code>xargs</code></h2>
            <span class="command-tag">Workflow</span>
          </div>
          <div class="command-body">
            <p>macht aus Listen echte Argumente fr nachfolgende Befehle.</p>
          </div>
        </article>

        <article class="command-card" data-command="tee" data-quiz-id="tee">
          <div class="command-header">
            <h2 class="command-name"><code>tee</code></h2>
            <span class="command-tag">Workflow</span>
          </div>
          <div class="command-body">
            <p>zeigt eine Pipeline-Ausgabe an und speichert sie parallel.</p>
          </div>
        </article>

        <article class="command-card" data-command="tar" data-quiz-id="tar">
          <div class="command-header">
            <h2 class="command-name"><code>tar</code></h2>
            <span class="command-tag">Dateien</span>
          </div>
          <div class="command-body">
            <p>erstellt oder entpackt Archive (z. B. tar.gz).</p>
          </div>
        </article>

        <!-- Flags-Übersicht Kachel -->
        <article
          class="command-card"
          data-command="flags_overview"
          data-quiz-id="flags_overview"
        >
          <div class="command-header">
            <h2 class="command-name">🏳️ Flags-Übersicht</h2>
            <span class="command-tag">Referenz</span>
          </div>
          <div class="command-body">
            <p>
              Komplette Übersicht aller Flags aus allen Kacheln mit Erklärungen
              und praktischen Beispielen.
            </p>
          </div>
        </article>

        <!-- Hotkeys & Quality of Life Kachel -->
        <article class="command-card hotkeys-card" id="hotkeys-card">
          <div class="command-header">
            <h2 class="command-name">⚡ Hotkeys & Quality of Life</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Tastaturkürzel, Terminal-Tools und Workflow-Verbesserungen für
              effizientes Arbeiten in der Kommandozeile.
            </p>
          </div>
        </article>

        <!-- Kali Linux Tools Kachel -->
        <article class="command-card kali-tools-card" id="kali-tools-card">
          <div class="command-header">
            <h2 class="command-name">🔐 Kali Linux Tools</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Übersicht über essentielle Pentesting-Tools und Setup-Schritte für
              Kali Linux – perfekt für Einsteiger.
            </p>
          </div>
        </article>

        <!-- Beginner Mistakes Kachel -->
        <article class="command-card mistakes-card" id="mistakes-card">
          <div class="command-header">
            <h2 class="command-name">🚧 Top 10 Anfängerfehler</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Häufige Stolpersteine mit kurzer Erklärung, korrektem Beispiel und
              direkter Verlinkung ins Command-Modal.
            </p>
          </div>
        </article>

        <!-- FAQ Knowledge Base Kachel -->
        <article class="command-card faq-card" id="faq-card">
          <div class="command-header">
            <h2 class="command-name">❓ Kali Linux FAQ</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Häufig gestellte Fragen zur Kommandozeilennutzung – durchsuchbar,
              kategorisiert und mit direkten Links zu verwandten Commands.
            </p>
          </div>
        </article>

        <!-- Modern Tools Kachel -->
        <article class="command-card modern-tools-card" id="modern-tools-card">
          <div class="command-header">
            <h2 class="command-name">🚀 Modern Tools</h2>
            <span class="command-tag">Wissen</span>
          </div>
          <div class="command-body">
            <p>
              Moderne Alternativen zu Standard-Commands: Installation auf Kali
              Linux und Vergleich zwischen neuen und alten Tools.
            </p>
          </div>
        </article>
      </section>
    </main>

    <div id="quiz-root" class="quiz-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="quiz-modal-inner">
        <!-- Front Side: Details immer sichtbar -->
        <div class="quiz-modal-front">
          <div class="quiz-header">
            <div>
              <div class="quiz-title" id="quiz-title">Quiz</div>
              <div class="quiz-level-pill" id="quiz-subtitle">
                3 Fragen: leicht · mittel · schwer
              </div>
            </div>
            <button class="quiz-close-btn" type="button" id="quiz-close-btn">
              ESC
            </button>
          </div>

          <div class="quiz-body" id="quiz-body"></div>

          <div class="quiz-footer">
            <div class="quiz-feedback" id="quiz-feedback"></div>
            <button class="quiz-submit-btn" type="button" id="quiz-submit-btn">
              Quiz starten
            </button>
          </div>
        </div>

        <!-- Back Side: Quiz-Fragen -->
        <div class="quiz-modal-back">
          <div class="quiz-header">
            <div>
              <div class="quiz-title" id="quiz-title-back">Quiz</div>
              <div class="quiz-level-pill" id="quiz-subtitle-back">
                3 Fragen: leicht · mittel · schwer
              </div>
            </div>
            <button
              class="quiz-close-btn"
              type="button"
              id="quiz-close-btn-back"
            >
              ESC
            </button>
          </div>

          <div class="quiz-body" id="quiz-body-back"></div>

          <div class="quiz-footer">
            <div class="quiz-feedback" id="quiz-feedback-back"></div>
            <button
              class="quiz-submit-btn"
              type="button"
              id="quiz-submit-btn-back"
            >
              Quiz auswerten
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Masterquiz-Modal -->
    <div
      id="master-quiz-root"
      class="master-quiz-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="master-quiz-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="master-quiz-title">Masterquiz</div>
            <div class="quiz-level-pill" id="master-quiz-subtitle">
              Kombinative Masterfrage
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="master-quiz-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="master-quiz-body"></div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="master-quiz-feedback"></div>
          <button
            class="quiz-submit-btn"
            type="button"
            id="master-quiz-submit-btn"
          >
            Antwort prüfen
          </button>
        </div>
      </div>
    </div>

    <!-- Command Detail Modal -->
    <div
      id="command-modal-root"
      class="master-quiz-modal command-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="master-quiz-modal-inner" role="dialog" aria-modal="true">
        <div class="quiz-header">
          <div>
            <div class="quiz-title" id="command-modal-title">
              Befehlsdetails
            </div>
            <div class="quiz-level-pill" id="command-modal-subtitle">
              Kontext &amp; Best Practices
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="command-modal-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="command-modal-body">
          <p class="command-summary" id="command-modal-summary"></p>
          <div
            id="command-modal-detail"
            class="command-section"
            style="display: none"
          ></div>
          <div class="command-meta-grid">
            <div class="command-section">
              <h3>Flags</h3>
              <div id="command-modal-flags"></div>
            </div>
            <div class="command-section">
              <h3>Typische Fehler</h3>
              <ul class="pitfalls-list" id="command-modal-pitfalls"></ul>
            </div>
          </div>
          <div
            class="command-section"
            id="command-modal-simple-example-section"
            style="display: none"
          >
            <h3>Einfaches Beispiel</h3>
            <div id="command-modal-simple-example"></div>
          </div>
          <div
            class="command-section"
            id="command-modal-complex-example-section"
            style="display: none"
          >
            <h3>Komplexes Beispiel</h3>
            <div id="command-modal-complex-example"></div>
          </div>
          <div
            class="command-section"
            id="command-modal-additional-examples-section"
            style="display: none"
          >
            <h3>Weitere Beispiele</h3>
            <div id="command-modal-additional-examples"></div>
          </div>
          <div class="command-section">
            <h3>Beispiele</h3>
            <div class="example-list" id="command-modal-examples"></div>
          </div>
        </div>

        <div class="quiz-footer">
          <div class="quiz-feedback" id="command-modal-feedback"></div>
        </div>
      </div>
    </div>

    <!-- Hotkeys-Modal -->
    <div id="hotkeys-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">⚡ Hotkeys & Quality of Life</div>
            <div class="quiz-level-pill">Terminal-Workflow Verbesserungen</div>
          </div>
          <button class="quiz-close-btn" type="button" id="hotkeys-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="hotkeys-body"></div>
      </div>
    </div>

    <!-- Kali-Tools-Modal -->
    <div
      id="kali-tools-root"
      class="kali-tools-modal hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div class="kali-tools-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🔐 Kali Linux Tools</div>
            <div class="quiz-level-pill">Pentesting-Tools & Setup-Guide</div>
            <div
              class="kali-tools-badges-container"
              id="kali-tools-badges-container"
            ></div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="kali-tools-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="kali-tools-body"></div>
      </div>
    </div>

    <!-- Kali-Tools Example Overlay -->
    <div
      id="kali-tools-example-overlay"
      class="kali-tools-overlay hidden"
      aria-hidden="true"
    >
      <div class="quiz-backdrop"></div>
      <div
        id="kali-tools-example-overlay-inner"
        class="kali-tools-overlay-inner"
      >
        <div class="kali-tools-overlay-header">
          <div
            id="kali-tools-example-overlay-title"
            class="kali-tools-overlay-title"
          ></div>
          <button
            type="button"
            class="kali-tools-overlay-close"
            id="kali-tools-example-overlay-close"
          >
            ✕ Schließen
          </button>
        </div>
        <div
          id="kali-tools-example-overlay-content"
          class="kali-tools-overlay-content"
        ></div>
      </div>
    </div>

    <!-- Beginner-Mistakes-Modal -->
    <div id="mistakes-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🚧 Top 10 Anfängerfehler</div>
            <div class="quiz-level-pill">
              Verstehe typische Fehltritte und springe direkt zum passenden
              Quiz.
            </div>
          </div>
          <button class="quiz-close-btn" type="button" id="mistakes-close-btn">
            ESC
          </button>
        </div>

        <div class="quiz-body" id="mistakes-body"></div>
      </div>
    </div>

    <!-- FAQ Knowledge Base Modal -->
    <div id="faq-modal-root" class="faq-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="faq-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">❓ Kali Linux FAQ</div>
            <div class="quiz-level-pill">
              Häufig gestellte Fragen zur Kommandozeilennutzung
            </div>
          </div>
          <button class="quiz-close-btn" type="button" id="faq-modal-close-btn">
            ESC
          </button>
        </div>

        <div class="faq-modal-body">
          <div class="faq-sidebar" id="faq-sidebar">
            <div class="faq-search-container">
              <input
                type="text"
                id="faq-search-input"
                class="faq-search-input"
                placeholder="FAQ durchsuchen..."
                aria-label="FAQ durchsuchen"
              />
            </div>
            <div class="faq-category-list" id="faq-category-list">
              <!-- Kategorien werden dynamisch eingefügt -->
            </div>
          </div>

          <div class="faq-content" id="faq-content">
            <!-- FAQ-Inhalte werden dynamisch eingefügt -->
          </div>
        </div>
      </div>
    </div>

    <!-- Modern Tools Modal -->
    <div id="modern-tools-root" class="hotkeys-modal hidden" aria-hidden="true">
      <div class="quiz-backdrop"></div>
      <div class="hotkeys-modal-inner">
        <div class="quiz-header">
          <div>
            <div class="quiz-title">🚀 Modern Tools</div>
            <div class="quiz-level-pill">
              Moderne Alternativen zu Standard-Commands
            </div>
          </div>
          <button
            class="quiz-close-btn"
            type="button"
            id="modern-tools-close-btn"
          >
            ESC
          </button>
        </div>

        <div class="quiz-body" id="modern-tools-body"></div>
      </div>
    </div>

    <script>
      // Suppress browser extension message channel errors (harmless but annoying)
      // These errors occur when browser extensions (ad blockers, password managers, etc.)
      // try to communicate with the page but the message channel closes before they can respond
      const isMessageChannelError = (error) => {
        if (!error) return false;
        const errorStr =
          typeof error === "string"
            ? error
            : error.message || error.toString() || "";
        const patterns = [
          "message channel closed",
          "asynchronous response",
          "listener indicated an asynchronous response",
          "channel closed before a response",
        ];
        return patterns.some((pattern) =>
          errorStr.toLowerCase().includes(pattern.toLowerCase())
        );
      };

      // Catch synchronous errors
      window.addEventListener(
        "error",
        (event) => {
          if (
            isMessageChannelError(event.message) ||
            isMessageChannelError(event.error)
          ) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            return false;
          }
        },
        true
      );

      // Catch unhandled promise rejections
      window.addEventListener("unhandledrejection", (event) => {
        if (isMessageChannelError(event.reason)) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      });

      // Also suppress console errors for this specific issue (optional, but helps with debugging)
      const originalConsoleError = console.error;
      console.error = function (...args) {
        const errorMessage = args.join(" ");
        if (isMessageChannelError(errorMessage)) {
          return; // Suppress this specific error
        }
        originalConsoleError.apply(console, args);
      };

      // Quiz-Daten – geprüfte & polierte Version
      const quizData = {
        pwd: {
          title: "pwd",
          description: "Arbeite bewusst mit dem aktuellen Arbeitsverzeichnis.",
          explanation: "Zeigt das aktuelle Arbeitsverzeichnis.",
          simpleExample: "pwd → /home/user",
          detail:
            "Sehr praktisch in Kombination mit cd .., um zu überprüfen, wo du gerade „gelandet“ bist.",
          complexExample: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Aktuelles Verzeichnis: $(pwd)" >> script.log',
              explanation:
                "$(pwd) wird durch den aktuellen Pfad ersetzt, echo gibt den Text aus, >> hängt ihn an script.log an (ohne Überschreibung)",
            },
          ],
          flags: [
            {
              flag: "-P",
              description: "zeigt den physischen Pfad ohne Symlinks",
              utility: "mittel",
              risk: "niedrig (nur Anzeige)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Du arbeitest in einem Script und musst das aktuelle Verzeichnis in eine Variable speichern. Welcher Befehl gibt dir den absoluten Pfad zurück, den du in einer Variable speichern kannst?",
              options: [
                "`pwd` - gibt den absoluten Pfad zurück",
                "`ls` - listet das Verzeichnis auf",
                "`cd` - wechselt das Verzeichnis",
                "`echo $PWD` - zeigt nur relative Pfade",
              ],
              correctIndex: 0,
              explanation:
                "`pwd` gibt den absoluten Pfad zurück, den du mit `CURRENT_DIR=$(pwd)` in einer Variable speichern kannst.",
            },
            {
              level: "mittel",
              prompt:
                "Du hast ein Symbolic Link-Verzeichnis `/home/user/link` das auf `/var/data` zeigt. Du bist in `/home/user/link` und führst `pwd` aus. Was passiert, wenn du stattdessen `/bin/pwd -P` verwendest?",
              options: [
                "Beide zeigen `/home/user/link` (identisch)",
                "`pwd` zeigt `/home/user/link`, `/bin/pwd -P` zeigt `/var/data` (physikalischer Pfad)",
                "Beide zeigen `/var/data` (folgen dem Link)",
                "`pwd` funktioniert nicht, nur `/bin/pwd -P`",
              ],
              correctIndex: 1,
              explanation:
                "Das Shell-Builtin `pwd` zeigt den logischen Pfad (`/home/user/link`), während `/bin/pwd -P` den physikalischen Pfad (`/var/data`) ohne Symbolic Links zeigt.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst in einem Script das aktuelle Verzeichnis in eine Log-Datei schreiben. Schreibe einen Befehl, der den absoluten Pfad (ohne Symbolic Links) in die Datei `current_path.log` schreibt.",
              correctCommand: "/bin/pwd -P > current_path.log",
              acceptedVariants: [
                "/bin/pwd -P > current_path.log",
                "pwd -P > current_path.log",
              ],
              explanation:
                "`/bin/pwd -P` gibt den physikalischen Pfad zurück (ohne Symbolic Links), `>` leitet die Ausgabe in die Datei um.",
            },
          ],
        },

        cd: {
          title: "cd",
          description: "Verzeichnisse wechseln – Grundlage jeder Navigation.",
          explanation: "Wechselt in ein anderes Verzeichnis.",
          simpleExample: "cd /home/user/Documents",
          detail:
            "Mit cd ohne Argument kehrst du in dein Home zurück: cd → /home/user",
          complexExample:
            'OLDPWD=$(pwd)\n\ncd /home/user/Downloads\n\nls > download_list.txt\n\ncd "$OLDPWD"',
          complexExampleExplanation: [
            {
              line: "OLDPWD=$(pwd)",
              explanation:
                "Speichert den aktuellen Pfad in der Variable OLDPWD für späteren Rückweg",
            },
            {
              line: "cd /home/user/Downloads",
              explanation:
                "Wechselt ins Downloads-Verzeichnis (absoluter Pfad)",
            },
            {
              line: "ls > download_list.txt",
              explanation:
                "Listet alle Dateien auf und speichert die Ausgabe in download_list.txt (überschreibt die Datei)",
            },
            {
              line: 'cd "$OLDPWD"',
              explanation:
                "Wechselt zurück zum ursprünglichen Verzeichnis (die Variable wird in Anführungszeichen gesetzt, falls Leerzeichen enthalten sind)",
            },
          ],
          flags: [
            {
              flag: "(ohne Argument)",
              description: "wechselt ins Home-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "-",
              description: "wechselt ins vorherige Verzeichnis (Toggle)",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "..",
              description: "Parent-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
            },
            {
              flag: "~user",
              description: "ins Home von user",
              utility: "mittel",
              risk: "niedrig (nur Navigation)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Du musst in ein Verzeichnis wechseln, dessen Pfad Leerzeichen enthält (z.B. `/home/user/My Documents`). Welche Variante funktioniert korrekt?",
              options: [
                "`cd /home/user/My Documents` (ohne Anführungszeichen)",
                "`cd '/home/user/My Documents'` oder `cd \"/home/user/My Documents\"` (mit Anführungszeichen)",
                "`cd /home/user/My\\ Documents` (nur mit Backslash)",
                "Alle Varianten funktionieren gleich",
              ],
              correctIndex: 1,
              explanation:
                "Pfade mit Leerzeichen müssen in Anführungszeichen gesetzt werden, sonst interpretiert die Shell sie als separate Argumente.",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/home/user` und willst in `/var/log` wechseln, dann zurück zu `/home/user`, dann wieder nach `/var/log`. Welche Befehlssequenz ist am effizientesten?",
              options: [
                "`cd /var/log` dann `cd /home/user` dann `cd /var/log`",
                "`cd /var/log` dann `cd -` dann `cd -` (Toggle)",
                "`cd /var/log` dann `cd $OLDPWD` dann `cd -`",
                "Alle sind gleich effizient",
              ],
              correctIndex: 1,
              explanation:
                "`cd -` wechselt zwischen dem aktuellen und dem vorherigen Verzeichnis (Toggle), was bei wiederholtem Wechseln am effizientesten ist.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst in ein Verzeichnis wechseln, dessen Name in der Variable `$TARGET_DIR` gespeichert ist. Der Pfad könnte Leerzeichen enthalten. Schreibe einen sicheren Befehl, der in dieses Verzeichnis wechselt.",
              correctCommand: 'cd "$TARGET_DIR"',
              acceptedVariants: ['cd "$TARGET_DIR"', "cd '$TARGET_DIR'"],
              explanation:
                '`cd "$TARGET_DIR"` verwendet Anführungszeichen um Leerzeichen im Pfad zu handhaben und expandiert die Variable korrekt.',
            },
          ],
        },

        cd_parent: {
          title: "cd ..",
          description: "Eine Ebene nach oben springen.",
          explanation: "Wechselt ein Verzeichnis nach oben (Parent).",
          simpleExample: "cd ..\n\nvon /home/user/Documents → /home/user",
          detail:
            "Du kannst auch cd ../.. verwenden, um zwei Ebenen hochzugehen.",
          complexExample:
            'cd "$(dirname "$0")/.."   # ein Level hoch relativ zum Script\n\npwd >> where_am_i.log',
          complexExampleExplanation: [
            {
              line: 'cd "$(dirname "$0")/.."',
              explanation:
                'dirname "$0" gibt das Verzeichnis des aktuellen Scripts zurück, /.. geht eine Ebene hoch, cd wechselt dorthin',
            },
            {
              line: "pwd >> where_am_i.log",
              explanation:
                "Zeigt den aktuellen Pfad an und hängt ihn an where_am_i.log an (für Logging/Debugging)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Eine Ebene hoch gehen und dann prüfen wo du bist</strong><br>
            <code>cd ..</code><br>
            <code>pwd</code><br>
            → Geht eine Ebene nach oben, pwd zeigt den neuen Pfad<br><br>

            ✅ <strong>2. Nach oben gehen und dann den Inhalt auflisten</strong><br>
            <code>cd ..</code><br>
            <code>ls</code><br>
            → Wechselt ins Parent-Verzeichnis, ls zeigt was dort ist<br><br>

            ✅ <strong>3. Zwei Ebenen hoch gehen</strong><br>
            <code>cd ../..</code><br>
            <code>pwd</code><br>
            → Geht zwei Ebenen nach oben, pwd zeigt den neuen Pfad<br><br>

            ✅ <strong>4. In einen Ordner wechseln, dann zurück nach oben</strong><br>
            <code>cd Documents</code><br>
            <code>cd ..</code><br>
            <code>ls</code><br>
            → Wechselt ins Documents-Verzeichnis, geht zurück nach oben, ls zeigt den Inhalt<br><br>

            ✅ <strong>5. Nach oben gehen und dann Dateien kopieren</strong><br>
            <code>cd ..</code><br>
            <code>cp file.txt backup/</code><br>
            → Geht eine Ebene hoch, kopiert dann eine Datei ins backup-Verzeichnis
                      `,
          questions: [
            {
              level: "leicht",
              prompt:
                "Du bist in `/home/user/projects/backend` und musst ins übergeordnete Verzeichnis `projects`. Welcher Befehl bringt dich dorthin?",
              options: [
                "`cd .` (bleibt im aktuellen Verzeichnis)",
                "`cd ..` (eine Ebene nach oben)",
                "`cd ../..` (zwei Ebenen nach oben)",
                "`cd ~` (ins Home-Verzeichnis)",
              ],
              correctIndex: 1,
              explanation:
                "`cd ..` wechselt eine Ebene nach oben, von `/home/user/projects/backend` nach `/home/user/projects`.",
            },
            {
              level: "mittel",
              prompt:
                "Du bist in `/var/log/apache2` und willst in `/var/log` wechseln, dann in `/var`, dann zurück zu `/var/log/apache2`. Welche Sequenz ist korrekt?",
              options: [
                "`cd ..` dann `cd ..` dann `cd apache2`",
                "`cd ../..` dann `cd log` dann `cd apache2`",
                "`cd ..` dann `cd ..` dann `cd log/apache2`",
                "Alle funktionieren gleich",
              ],
              correctIndex: 0,
              explanation:
                "Von `/var/log/apache2` aus: `cd ..` → `/var/log`, `cd ..` → `/var`, `cd apache2` funktioniert nicht (apache2 ist nicht in `/var`). Richtig: `cd log/apache2` von `/var` aus.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du bist in `/home/user/projects/backend/src` und musst ins Verzeichnis `/home/user/scripts` wechseln. Schreibe den effizientesten Befehl, der dies in einem Schritt macht (ohne absoluten Pfad).",
              correctCommand: "cd ../../scripts",
              acceptedVariants: ["cd ../../scripts"],
              explanation:
                "Von `/home/user/projects/backend/src` aus: `../..` geht zwei Ebenen hoch nach `/home/user`, dann `scripts` führt ins Zielverzeichnis.",
            },
          ],
        },

        ls: {
          title: "ls",
          description: "Dateien und Ordner auflisten.",
          explanation: "Listet Dateien und Ordner im aktuellen Verzeichnis.",
          simpleExample: "ls",
          detail:
            "ls sortiert standardmäßig alphabetisch; mit ls -t nach Änderungszeit.",
          complexExample: "ls *.log 2>/dev/null | wc -l",
          complexExampleExplanation: [
            {
              line: "ls *.log 2>/dev/null | wc -l",
              explanation:
                "ls *.log listet alle .log-Dateien, 2>/dev/null versteckt Fehler (z.B. wenn keine .log-Dateien existieren), | leitet an wc -l weiter, das die Anzahl der Zeilen (also Dateien) zählt",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl listet Dateien im aktuellen Verzeichnis auf?",
              options: ["show", "ls", "pwd", "open"],
              correctIndex: 1,
              explanation:
                "`ls` ist der Standardbefehl zum Auflisten des Inhalts eines Verzeichnisses.",
            },
            {
              level: "mittel",
              prompt:
                "Welche Option zeigt dir zusätzlich versteckte Dateien (Einträge, die mit `.` beginnen)?",
              options: ["`ls -l`", "`ls -R`", "`ls -a`", "`ls -h`"],
              correctIndex: 2,
              explanation:
                "`-a` steht für „all“ und zeigt auch versteckte Einträge.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst alle `.log`-Dateien im aktuellen Verzeichnis auflisten, aber Fehlermeldungen verstecken falls keine .log-Dateien existieren. Schreibe den Befehl.",
              correctCommand: "ls *.log 2>/dev/null",
              acceptedVariants: [
                "ls *.log 2>/dev/null",
                "ls *.log 2> /dev/null",
              ],
              explanation:
                "`ls *.log` listet alle .log-Dateien, `2>/dev/null` leitet Fehler (stderr) ins Nichts um, sodass Fehlermeldungen nicht angezeigt werden.",
            },
          ],
        },

        grep: {
          title: "grep",
          description: "Texte nach Mustern durchsuchen.",
          explanation: "Sucht nach Textmustern in Dateien oder Eingaben.",
          simpleExample: 'grep "Error" logfile.txt',
          detail:
            "Mit -n Zeilennummern anzeigen, mit -i Groß-/Kleinschreibung ignorieren.",
          complexExample: 'grep -n "TODO" *.sh',
          additionalExamples: `
            ✅ <strong>1. In einer Datei suchen (die du mit cat anzeigen könntest)</strong><br>
            <code>cat log.txt</code><br>
            <code>grep "Error" log.txt</code><br>
            → cat zeigt den ganzen Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

            ✅ <strong>2. Suche und dann sortiere die Ergebnisse</strong><br>
            <code>grep "user" names.txt</code><br>
            <code>grep "user" names.txt | sort</code><br>
            → Findet alle Zeilen mit "user", sort sortiert sie alphabetisch<br><br>

            ✅ <strong>3. Suche in mehreren Dateien (die du mit find finden könntest)</strong><br>
            <code>find . -name "*.log"</code><br>
            <code>grep "Error" *.log</code><br>
            → find zeigt alle .log-Dateien, grep sucht "Error" in allen .log-Dateien<br><br>

            ✅ <strong>4. Suche und zeige nur die ersten 5 Treffer</strong><br>
            <code>grep "TODO" *.txt</code><br>
            <code>grep "TODO" *.txt | head -n 5</code><br>
            → Findet alle "TODO" Einträge, head zeigt nur die ersten 5 Zeilen<br><br>

            ✅ <strong>5. Suche, sortiere und entferne Duplikate</strong><br>
            <code>grep "admin" users.txt</code><br>
            <code>grep "admin" users.txt | sort | uniq</code><br>
            → Findet "admin", sort sortiert, uniq entfernt doppelte Zeilen
                      `,
          complexExampleExplanation: [
            {
              line: 'grep -n "TODO" *.sh',
              explanation:
                'grep sucht nach "TODO", -n zeigt Zeilennummern an, *.sh durchsucht alle .sh-Dateien im aktuellen Verzeichnis',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                'Du hast einen Log-File mit 1000 Zeilen. Du willst nur Zeilen sehen, die "ERROR" enthalten, aber auch die Zeilennummern brauchst. Welche Option fehlt?',
              options: [
                '`grep -n "ERROR" logfile.txt` (zeigt Zeilennummern)',
                '`grep -c "ERROR" logfile.txt` (zählt nur)',
                '`grep -v "ERROR" logfile.txt` (invertiert)',
                '`grep "ERROR" logfile.txt` (ohne Optionen)',
              ],
              correctIndex: 0,
              explanation:
                "`grep -n` zeigt die Zeilennummern zusammen mit den gefundenen Zeilen, was beim Debuggen sehr hilfreich ist.",
            },
            {
              level: "mittel",
              prompt:
                'Du musst in allen `.log`-Dateien rekursiv nach "failed" suchen, aber nur in Dateien die "2024" im Namen haben. Welche Kombination ist korrekt?',
              options: [
                '`grep -r "failed" --include="*2024*.log" .`',
                '`grep -r "failed" *.log | grep 2024`',
                "`grep -r \"failed\" . -name '*2024*.log'`",
                "`grep \"failed\" $(find . -name '*2024*.log')`",
              ],
              correctIndex: 0,
              explanation:
                "`grep -r` sucht rekursiv, `--include='*2024*.log'` filtert Dateien mit '2024' im Namen, `.` ist das Startverzeichnis.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Finde alle Zeilen in `.log`-Dateien die 'error' enthalten (case-insensitive) und zeige Zeilennummern. Suche rekursiv ab dem aktuellen Verzeichnis.",
              correctCommand: 'grep -ri "error" . --include="*.log" -n',
              acceptedVariants: [
                'grep -ri "error" . --include="*.log" -n',
                "grep -ri 'error' . --include='*.log' -n",
              ],
              explanation:
                "`grep -ri` sucht rekursiv und case-insensitive, `--include='*.log'` beschränkt auf .log-Dateien, `-n` zeigt Zeilennummern.",
            },
          ],
        },

        pipe: {
          title: "Pipe |",
          description: "Befehle zu einer Verarbeitungskette verknüpfen.",
          explanation:
            "Leitet die Ausgabe eines Befehls als Eingabe an den nächsten weiter.",
          simpleExample: "ls | sort",
          detail:
            "Pipes verbinden stdout → stdin; viele kleine Werkzeuge zusammen verwenden.",
          complexExample: "cat errors.log | sort | uniq > unique_errors.txt",
          complexExampleExplanation: [
            {
              line: "cat errors.log | sort | uniq > unique_errors.txt",
              explanation:
                "cat liest errors.log, | leitet an sort weiter (sortiert alphabetisch), | leitet an uniq weiter (entfernt Duplikate), > speichert das Ergebnis in unique_errors.txt",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Dateien auflisten und sortieren</strong><br>
            <code>ls</code><br>
            <code>ls | sort</code><br>
            → ls zeigt Dateien, sort sortiert sie alphabetisch<br><br>

            ✅ <strong>2. Datei anzeigen, dann nach etwas suchen</strong><br>
            <code>cat log.txt</code><br>
            <code>cat log.txt | grep "Error"</code><br>
            → cat zeigt den Inhalt, grep filtert nur Zeilen mit "Error"<br><br>

            ✅ <strong>3. Suche, sortiere und entferne Duplikate</strong><br>
            <code>grep "user" names.txt</code><br>
            <code>grep "user" names.txt | sort | uniq</code><br>
            → Findet "user", sort sortiert, uniq entfernt doppelte Zeilen<br><br>

            ✅ <strong>4. Dateien auflisten und zählen</strong><br>
            <code>ls</code><br>
            <code>ls | wc -l</code><br>
            → ls zeigt Dateien, wc -l zählt wie viele es sind<br><br>

            ✅ <strong>5. Suche, zeige nur die ersten Treffer</strong><br>
            <code>grep "TODO" *.txt</code><br>
            <code>grep "TODO" *.txt | head -n 10</code><br>
            → Findet alle "TODO" Einträge, head zeigt nur die ersten 10
                      `,
          questions: [
            {
              level: "leicht",
              prompt:
                "Du willst die Ausgabe von `ls` sortieren. Welches Symbol verbindet die Befehle korrekt?",
              options: [
                "`ls && sort` (logisches UND)",
                "`ls | sort` (Pipe)",
                "`ls > sort` (Umleitung)",
                "`ls ; sort` (Semikolon)",
              ],
              correctIndex: 1,
              explanation:
                "Das Pipe-Symbol `|` leitet die Ausgabe von `ls` als Eingabe an `sort` weiter, sodass die Dateiliste sortiert wird.",
            },
            {
              level: "mittel",
              prompt:
                "Du musst aus einer Log-Datei alle eindeutigen IP-Adressen extrahieren (sortiert, ohne Duplikate). Welche Pipe-Kette ist korrekt?",
              options: [
                "`grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' log.txt | sort | uniq`",
                "`grep IP log.txt | uniq | sort`",
                "`cat log.txt | uniq | sort`",
                "`sort log.txt | uniq`",
              ],
              correctIndex: 0,
              explanation:
                "`grep -oE` extrahiert IP-Adressen mit Regex, `sort` sortiert sie, `uniq` entfernt Duplikate. Wichtig: erst sortieren, dann uniq.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Extrahiere alle eindeutigen Fehlertypen aus `errors.log` (alphabetisch sortiert, ohne Duplikate) und speichere das Ergebnis in `unique_errors.txt`.",
              correctCommand:
                "cat errors.log | sort | uniq > unique_errors.txt",
              acceptedVariants: [
                "cat errors.log | sort | uniq > unique_errors.txt",
              ],
              explanation:
                "`cat` liest die Datei, `sort` sortiert alphabetisch, `uniq` entfernt Duplikate (muss nach sort kommen), `>` speichert in die Datei.",
            },
          ],
        },

        redirect: {
          title: "Umleitung",
          description: "stdout/stderr in Dateien umleiten.",
          explanation: "Leitet Ausgaben und Fehler in Dateien um.",
          simpleExample: "echo Hallo > out.txt",
          detail:
            "`>` überschreibt, `>>` hängt an; `2>&1` kombiniert stderr mit stdout.",
          complexExample: "command > all.log 2>&1",
          complexExampleExplanation: [
            {
              line: "command > all.log 2>&1",
              explanation:
                "command führt einen Befehl aus, > all.log leitet stdout in all.log um, 2>&1 leitet stderr (2) auf stdout (1) um, sodass beide Streams in derselben Datei landen",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `echo Hallo > out.txt`?",
              options: [
                'Hängt "Hallo" an `out.txt` an.',
                'Überschreibt `out.txt` mit "Hallo" (oder erstellt die Datei).',
                'Zeigt "Hallo" nur im Terminal an.',
                "Löscht die Datei `out.txt`.",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt (oder erstellt) die Datei und schreibt die Standardausgabe hinein.",
            },
            {
              level: "mittel",
              prompt:
                "Du willst Log-Ausgaben an eine Datei anhängen statt sie zu überschreiben. Welche Variante ist korrekt?",
              options: [
                "`echo Neu > log.txt`",
                "`echo Neu >> log.txt`",
                "`echo Neu 2> log.txt`",
                "`echo Neu | log.txt`",
              ],
              correctIndex: 1,
              explanation:
                "`>>` fügt Text am Ende der Datei an, ohne den bestehenden Inhalt zu löschen.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du führst einen Befehl aus und musst sowohl stdout als auch stderr in dieselbe Datei `all.log` umleiten. Schreibe den Befehl (ersetze 'command' durch einen Beispielbefehl wie 'ls').",
              correctCommand: "ls > all.log 2>&1",
              acceptedVariants: ["ls > all.log 2>&1", "command > all.log 2>&1"],
              explanation:
                "`> all.log` leitet stdout um, `2>&1` lenkt stderr (2) auf den gleichen Stream wie stdout (1), sodass beide in `all.log` landen.",
            },
          ],
        },

        nano_flow: {
          title: "Nano + Script-Workflow",
          description:
            "Script schreiben, speichern, ausführbar machen, starten.",
          explanation:
            "Script schreiben, ausführbar machen und starten (Editor + Rechte).",
          simpleExample:
            "STRG+O (speichern) → chmod +x script.sh → ./script.sh",
          detail: "STRG+O speichert in nano; chmod +x setzt das Execute-Bit.",
          complexExample: "nano script.sh\n\nchmod +x script.sh\n\n./script.sh",
          complexExampleExplanation: [
            {
              line: "nano script.sh",
              explanation:
                "Öffnet den Editor nano zum Bearbeiten von script.sh (STRG+O speichern, STRG+X beenden)",
            },
            {
              line: "chmod +x script.sh",
              explanation:
                "Setzt das Ausführungsbit (x) für script.sh, damit es direkt ausgeführt werden kann",
            },
            {
              line: "./script.sh",
              explanation:
                "Führt das Script im aktuellen Verzeichnis aus (./ bedeutet aktuelles Verzeichnis)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welche Tastenkombination speichert eine Datei in `nano`?",
              options: ["STRG + X", "STRG + S", "STRG + O", "STRG + Q"],
              correctIndex: 2,
              explanation:
                "In `nano` steht STRG+O (write Out) für Speichern, STRG+X beendet den Editor.",
            },
            {
              level: "mittel",
              prompt:
                "Welche zwei Befehle brauchst du minimal, um `script.sh` ausführbar zu machen und direkt zu starten?",
              options: [
                "`chmod +x script.sh` und `./script.sh`",
                "`nano script.sh` und `bash script.sh`",
                "`chown script.sh` und `run script.sh`",
                "`exec script.sh` und `run script.sh`",
              ],
              correctIndex: 0,
              explanation:
                "Mit `chmod +x` setzt du das Ausführungsbit, `./script.sh` startet das Script im aktuellen Verzeichnis.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du hast ein Script `backup.sh` erstellt und musst es ausführbar machen und dann starten. Schreibe die beiden Befehle in einem (getrennt durch &&).",
              correctCommand: "chmod +x backup.sh && ./backup.sh",
              acceptedVariants: ["chmod +x backup.sh && ./backup.sh"],
              explanation:
                "`chmod +x` setzt das Ausführungsbit, `&&` führt den zweiten Befehl nur aus wenn der erste erfolgreich war, `./backup.sh` startet das Script.",
            },
          ],
        },

        ls_a: {
          title: "ls -a",
          description:
            "Listet alle Dateien, inklusive versteckter (beginnen mit .).",
          explanation: "Zeigt auch versteckte Dateien.",
          simpleExample: "ls -a",
          detail: "Zeigt auch . (aktuelles Verzeichnis) und .. (Parent).",
          complexExample: 'cd ~\nls -a | grep "^\\."',
          complexExampleExplanation: [
            {
              line: "cd ~",
              explanation:
                "Wechselt ins Home-Verzeichnis (~ ist eine Abkürzung für $HOME)",
            },
            {
              line: 'ls -a | grep "^\\."',
              explanation:
                'ls -a zeigt alle Dateien (inkl. versteckter), | leitet an grep weiter, "^\\." filtert nur Zeilen, die mit einem Punkt beginnen (versteckte Dateien)',
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Normale Liste vs. alle Dateien</strong><br>
            <code>ls</code><br>
            <code>ls -a</code><br>
            → ls zeigt nur normale Dateien, ls -a zeigt auch versteckte (mit .)<br><br>

            ✅ <strong>2. In ein Verzeichnis wechseln und dann alles anzeigen</strong><br>
            <code>cd Documents</code><br>
            <code>ls -a</code><br>
            → Wechselt ins Documents-Verzeichnis, ls -a zeigt alle Dateien dort<br><br>

            ✅ <strong>3. Prüfen wo du bist, dann alles auflisten</strong><br>
            <code>pwd</code><br>
            <code>ls -a</code><br>
            → pwd zeigt deinen Pfad, ls -a zeigt alle Dateien im aktuellen Verzeichnis<br><br>

            ✅ <strong>4. Liste speichern und dann anzeigen</strong><br>
            <code>ls -a > alle_dateien.txt</code><br>
            <code>cat alle_dateien.txt</code><br>
            → Speichert die Liste in eine Datei, cat zeigt den Inhalt<br><br>

            ✅ <strong>5. Versteckte Dateien finden und dann auflisten</strong><br>
            <code>ls -a</code><br>
            <code>ls -a | grep "^\\.bash"</code><br>
            → Zeigt alle Dateien, grep filtert nur .bash-Dateien (versteckte Config-Dateien)
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -a` zusätzlich zu normalen Dateien?",
              options: [
                "Nur Dateien mit Schreibrechten",
                "Versteckte Dateien (beginnen mit .)",
                "Nur Ordner",
                "Nur ausführbare Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-a` steht für 'all' und zeigt auch versteckte Einträge, die mit einem Punkt beginnen.",
            },
            {
              level: "mittel",
              prompt: "Welche Einträge zeigt `ls -a` immer an?",
              options: [
                "Nur . und ..",
                ". (aktuelles Verzeichnis) und .. (Parent-Verzeichnis)",
                "Nur versteckte Dateien",
                "Alle Dateien außer ..",
              ],
              correctIndex: 1,
              explanation:
                "`ls -a` zeigt immer . (aktuelles Verzeichnis) und .. (übergeordnetes Verzeichnis) zusätzlich zu allen anderen Dateien.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst nur die versteckten Dateien im Home-Verzeichnis auflisten (Dateien die mit einem Punkt beginnen). Schreibe den Befehl mit Pipe und grep.",
              correctCommand: "ls -a ~ | grep '^\\.'",
              acceptedVariants: [
                "ls -a ~ | grep '^\\.'",
                "cd ~ && ls -a | grep '^\\.'",
              ],
              explanation:
                "`ls -a ~` zeigt alle Dateien im Home, `| grep '^\\.'` filtert nur Zeilen die mit einem Punkt beginnen (versteckte Dateien).",
            },
          ],
        },

        ls_la: {
          title: "ls -la",
          description:
            "Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe usw.",
          explanation: "Details + versteckte Dateien.",
          simpleExample: "ls -la",
          detail:
            "Das erste Zeichen der Zeile zeigt den Typ: - Datei, d Verzeichnis, l Link.",
          complexExample: "ls -la | awk '{print $1, $9}'",
          complexExampleExplanation: [
            {
              line: "ls -la | awk '{print $1, $9}'",
              explanation:
                "ls -la zeigt Details aller Dateien, | leitet an awk weiter, awk extrahiert Spalte 1 (Rechte) und Spalte 9 (Dateiname) und gibt sie aus",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Normale Liste vs. detaillierte Liste</strong><br>
            <code>ls</code><br>
            <code>ls -la</code><br>
            → ls zeigt nur Namen, ls -la zeigt Details (Rechte, Besitzer, Größe, Datum)<br><br>

            ✅ <strong>2. Prüfen wo du bist, dann Details anzeigen</strong><br>
            <code>pwd</code><br>
            <code>ls -la</code><br>
            → pwd zeigt deinen Pfad, ls -la zeigt alle Dateien mit Details<br><br>

            ✅ <strong>3. In einen Ordner wechseln und Details anzeigen</strong><br>
            <code>cd Documents</code><br>
            <code>ls -la</code><br>
            → Wechselt ins Documents-Verzeichnis, zeigt alle Dateien mit Details<br><br>

            ✅ <strong>4. Details speichern und dann anzeigen</strong><br>
            <code>ls -la > dateien_details.txt</code><br>
            <code>cat dateien_details.txt</code><br>
            → Speichert die detaillierte Liste in eine Datei, cat zeigt den Inhalt<br><br>

            ✅ <strong>5. Details anzeigen und dann nach etwas suchen</strong><br>
            <code>ls -la</code><br>
            <code>ls -la | grep ".txt"</code><br>
            → Zeigt alle Details, grep filtert nur .txt-Dateien
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -la` zusätzlich zu `ls`?",
              options: [
                "Nur versteckte Dateien",
                "Details (Rechte, Besitzer, Größe) und versteckte Dateien",
                "Nur Dateigrößen",
                "Nur Besitzer",
              ],
              correctIndex: 1,
              explanation:
                "`-l` zeigt Details, `-a` zeigt versteckte Dateien. Kombiniert: alles mit Details.",
            },
            {
              level: "mittel",
              prompt:
                "Was bedeutet das erste Zeichen 'd' in der Ausgabe von `ls -la`?",
              options: [
                "Datei",
                "Verzeichnis (Directory)",
                "Link",
                "Ausführbar",
              ],
              correctIndex: 1,
              explanation:
                "Das erste Zeichen zeigt den Dateityp: 'd' = Directory (Verzeichnis), '-' = Datei, 'l' = Link.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst aus der detaillierten Liste (`ls -la`) nur die Rechte (Spalte 1) und Dateinamen (Spalte 9) extrahieren. Schreibe den Befehl mit awk.",
              correctCommand: "ls -la | awk '{print $1, $9}'",
              acceptedVariants: [
                "ls -la | awk '{print $1, $9}'",
                'ls -la | awk "{print \\$1, \\$9}"',
              ],
              explanation:
                "`ls -la` zeigt Details, `| awk '{print $1, $9}'` extrahiert Spalte 1 (Rechte) und Spalte 9 (Dateiname) und gibt sie aus.",
            },
          ],
        },

        mkdir: {
          title: "mkdir",
          description: "Erstellt einen neuen Ordner.",
          explanation: "Ordner erstellen.",
          simpleExample: "mkdir Test",
          detail:
            "Fehlschlag, wenn der Ordner schon existiert (außer du nutzt -p).",
          complexExample: "mkdir Music Images Documents Scripts",
          complexExampleExplanation: [
            {
              line: "mkdir Music Images Documents Scripts",
              explanation:
                "Erstellt vier Ordner gleichzeitig: Music, Images, Documents und Scripts (mehrere Argumente werden als separate Ordner interpretiert)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Ordner erstellen und dann prüfen wo du bist</strong><br>
            <code>mkdir my_folder</code><br>
            <code>pwd</code><br>
            → Erstellt den Ordner, pwd zeigt deinen aktuellen Pfad<br><br>

            ✅ <strong>2. Ordner erstellen und dann den Inhalt anzeigen</strong><br>
            <code>mkdir backup</code><br>
            <code>ls</code><br>
            → Erstellt backup, ls zeigt dass der neue Ordner existiert<br><br>

            ✅ <strong>3. Ordner erstellen, hinein wechseln, prüfen</strong><br>
            <code>mkdir projects</code><br>
            <code>cd projects</code><br>
            <code>pwd</code><br>
            → Erstellt projects, wechselt hinein, zeigt den neuen Pfad<br><br>

            ✅ <strong>4. Mehrere Ordner erstellen und dann auflisten</strong><br>
            <code>mkdir folder1 folder2 folder3</code><br>
            <code>ls</code><br>
            → Erstellt drei Ordner auf einmal, ls zeigt alle<br><br>

            ✅ <strong>5. Ordner erstellen, Dateien kopieren, dann Inhalt prüfen</strong><br>
            <code>mkdir archive</code><br>
            <code>cp *.txt archive/</code><br>
            <code>ls archive/</code><br>
            → Erstellt archive, kopiert Dateien hinein, ls zeigt den Inhalt
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir Test`?",
              options: [
                "Löscht den Ordner Test",
                "Erstellt einen neuen Ordner namens Test",
                "Zeigt den Inhalt von Test",
                "Kopiert Test",
              ],
              correctIndex: 1,
              explanation:
                "`mkdir` steht für 'make directory' und erstellt einen neuen Ordner.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `mkdir Test` ausführst, aber Test bereits existiert?",
              options: [
                "Der Ordner wird überschrieben",
                "Es gibt einen Fehler",
                "Der Ordner wird umbenannt",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-p` gibt `mkdir` einen Fehler aus, wenn der Ordner bereits existiert.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst drei Ordner gleichzeitig erstellen: `backup`, `archive` und `temp`. Schreibe den Befehl.",
              correctCommand: "mkdir backup archive temp",
              acceptedVariants: ["mkdir backup archive temp"],
              explanation:
                "`mkdir` kann mehrere Ordner auf einmal erstellen, wenn du sie als separate Argumente angibst.",
            },
          ],
        },

        mkdir_p: {
          title: "mkdir -p",
          description:
            "Erstellt einen Ordner inkl. aller fehlenden Zwischenordner.",
          explanation: "inkl. Zwischenordner erstellen.",
          simpleExample: "mkdir -p Projekte/2025/Notizen",
          detail: "Wenn der Pfad schon existiert, gibt es keinen Fehler.",
          complexExample:
            'mkdir -p /var/log/myapp\necho "Starte App..." >> /var/log/myapp/run.log',
          complexExampleExplanation: [
            {
              line: "mkdir -p /var/log/myapp",
              explanation:
                "Erstellt /var/log/myapp inklusive aller fehlenden Zwischenordner (/var, /var/log), -p verhindert Fehler wenn Verzeichnisse bereits existieren",
            },
            {
              line: 'echo "Starte App..." >> /var/log/myapp/run.log',
              explanation:
                'Gibt "Starte App..." aus und hängt es an run.log an (>> fügt am Ende hinzu, ohne Überschreibung)',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mkdir -p Projekte/2025/Notizen`?",
              options: [
                "Erstellt nur Notizen",
                "Erstellt Projekte, 2025 und Notizen (alle fehlenden Ordner)",
                "Löscht die Ordner",
                "Zeigt den Pfad an",
              ],
              correctIndex: 1,
              explanation:
                "`-p` erstellt alle fehlenden Zwischenordner im Pfad automatisch.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert mit `mkdir -p`, wenn der Ordner bereits existiert?",
              options: [
                "Fehler",
                "Kein Fehler, es wird nichts gemacht",
                "Der Ordner wird gelöscht und neu erstellt",
                "Der Ordner wird umbenannt",
              ],
              correctIndex: 1,
              explanation:
                "Mit `-p` gibt es keinen Fehler, wenn der Ordner bereits existiert – ideal für Scripts.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst in einem Script die Verzeichnisstruktur `logs/2025/january` erstellen, auch wenn einige Ordner bereits existieren. Schreibe den Befehl.",
              correctCommand: "mkdir -p logs/2025/january",
              acceptedVariants: ["mkdir -p logs/2025/january"],
              explanation:
                "`mkdir -p` erstellt alle fehlenden Zwischenordner und gibt keinen Fehler, wenn Ordner bereits existieren – ideal für Scripts.",
            },
          ],
        },

        mv: {
          title: "mv",
          description: "Verschiebt Dateien/Ordner oder benennt sie um.",
          explanation: "verschieben oder umbenennen.",
          simpleExample: "mv song.mp3 Music/\nmv oldname.txt newname.txt",
          detail:
            "Überschreibt still; mit mv -i fragt es vor dem Überschreiben.",
          complexExample: "mkdir -p archive\nmv *.txt archive/",
          complexExampleExplanation: [
            {
              line: "mkdir -p archive",
              explanation:
                "Erstellt den Ordner archive (oder tut nichts, falls er bereits existiert)",
            },
            {
              line: "mv *.txt archive/",
              explanation:
                "Verschiebt alle .txt-Dateien (*.txt ist ein Wildcard-Muster) in den archive-Ordner",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
            <code>mv file.txt backup/</code><br>
            <code>pwd</code><br>
            → Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

            ✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
            <code>mv old.txt new.txt</code><br>
            <code>ls</code><br>
            → Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

            ✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
            <code>cd Documents</code><br>
            <code>mv report.txt ../archive/</code><br>
            <code>cd ..</code><br>
            → Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

            ✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
            <code>mv *.log logs/</code><br>
            <code>ls logs/</code><br>
            → Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

            ✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
            <code>mkdir old_files</code><br>
            <code>mv file1.txt file2.txt old_files/</code><br>
            <code>ls old_files/</code><br>
            → Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
                      `,
          additionalExamples: `
            ✅ <strong>1. Datei verschieben und dann prüfen wo du bist</strong><br>
            <code>mv file.txt backup/</code><br>
            <code>pwd</code><br>
            → Verschiebt die Datei, pwd zeigt deinen aktuellen Pfad<br><br>

            ✅ <strong>2. Datei umbenennen und dann den Ordner auflisten</strong><br>
            <code>mv old.txt new.txt</code><br>
            <code>ls</code><br>
            → Benennt die Datei um, ls zeigt dass nur new.txt existiert<br><br>

            ✅ <strong>3. In einen Ordner wechseln, verschieben, zurückkehren</strong><br>
            <code>cd Documents</code><br>
            <code>mv report.txt ../archive/</code><br>
            <code>cd ..</code><br>
            → Wechselt ins Documents-Verzeichnis, verschiebt eine Datei eine Ebene nach oben, kehrt zurück<br><br>

            ✅ <strong>4. Mehrere Dateien verschieben und dann prüfen</strong><br>
            <code>mv *.log logs/</code><br>
            <code>ls logs/</code><br>
            → Verschiebt alle .log-Dateien ins logs-Verzeichnis, ls zeigt den Inhalt<br><br>

            ✅ <strong>5. Ordner erstellen, dann Dateien hinein verschieben</strong><br>
            <code>mkdir old_files</code><br>
            <code>mv file1.txt file2.txt old_files/</code><br>
            <code>ls old_files/</code><br>
            → Erstellt den Ordner, verschiebt Dateien hinein, prüft den Inhalt
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `mv datei.txt Ordner/`?",
              options: [
                "Kopiert die Datei",
                "Verschiebt die Datei in den Ordner",
                "Löscht die Datei",
                "Zeigt die Datei an",
              ],
              correctIndex: 1,
              explanation: "`mv` verschiebt Dateien von einem Ort zum anderen.",
            },
            {
              level: "mittel",
              prompt: "Was macht `mv alt.txt neu.txt`?",
              options: [
                "Kopiert alt.txt zu neu.txt",
                "Benennt alt.txt in neu.txt um",
                "Löscht beide Dateien",
                "Zeigt beide Dateien an",
              ],
              correctIndex: 1,
              explanation:
                "Wenn das Ziel keine existierende Datei/Ordner ist, benennt `mv` die Datei um.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst alle `.txt`-Dateien in den Ordner `archive` verschieben. Schreibe den Befehl mit Wildcard.",
              correctCommand: "mv *.txt archive/",
              acceptedVariants: ["mv *.txt archive/", "mv *.txt archive"],
              explanation:
                "`mv *.txt archive/` verschiebt alle .txt-Dateien (*.txt ist ein Wildcard-Muster) in den archive-Ordner.",
            },
          ],
        },

        cp: {
          title: "cp",
          description: "Kopiert Dateien.",
          explanation: "Datei kopieren.",
          simpleExample: "cp notes.txt notes_backup.txt",
          detail:
            "Mit cp -i vor dem Überschreiben nachfragen; mit cp -u nur neuere kopieren.",
          complexExample: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp ~/.bashrc ~/.bashrc.backup_$(date +%F)",
              explanation:
                "Kopiert .bashrc aus dem Home-Verzeichnis, $(date +%F) wird durch das aktuelle Datum (YYYY-MM-DD) ersetzt, erstellt z.B. .bashrc.backup_2025-01-15",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Backup erstellen und dann prüfen wo du bist</strong><br>
            <code>cp notes.txt notes_backup.txt</code><br>
            <code>pwd</code><br>
            → Kopiert die Datei, dann zeigt pwd deinen aktuellen Pfad<br><br>

            ✅ <strong>2. Datei kopieren und dann den Inhalt des Ordners anzeigen</strong><br>
            <code>cp datei.txt backup/</code><br>
            <code>ls backup/</code><br>
            → Kopiert die Datei ins backup-Verzeichnis, ls zeigt was drin ist<br><br>

            ✅ <strong>3. In einen Ordner wechseln, kopieren, zurückkehren</strong><br>
            <code>cd Documents</code><br>
            <code>cp report.txt ../backup/</code><br>
            <code>cd ..</code><br>
            → Wechselt ins Documents-Verzeichnis, kopiert eine Datei eine Ebene nach oben ins backup, kehrt zurück<br><br>

            ✅ <strong>4. Mehrere Dateien kopieren und dann auflisten</strong><br>
            <code>cp *.txt backup/</code><br>
            <code>ls -a backup/</code><br>
            → Kopiert alle .txt-Dateien ins backup-Verzeichnis, ls -a zeigt alle Dateien (inkl. versteckter)<br><br>

            ✅ <strong>5. Ordner erstellen, dann Datei hinein kopieren</strong><br>
            <code>mkdir my_backup</code><br>
            <code>cp important.txt my_backup/</code><br>
            <code>ls my_backup/</code><br>
            → Erstellt zuerst den Ordner, kopiert dann die Datei hinein, prüft mit ls
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp datei.txt backup.txt`?",
              options: [
                "Verschiebt datei.txt",
                "Kopiert datei.txt zu backup.txt",
                "Löscht datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`cp` kopiert Dateien – die Originaldatei bleibt erhalten.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cp -u quelle.txt ziel.txt`?",
              options: [
                "Kopiert nur, wenn ziel.txt älter ist",
                "Kopiert nur, wenn ziel.txt neuer ist",
                "Kopiert immer",
                "Löscht ziel.txt",
              ],
              correctIndex: 0,
              explanation:
                "`-u` (update) kopiert nur, wenn die Quelldatei neuer ist als die Zieldatei.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst eine Datei `config.conf` mit dem aktuellen Datum im Format YYYY-MM-DD als Backup kopieren. Schreibe den Befehl.",
              correctCommand: "cp config.conf config.conf.backup_$(date +%F)",
              acceptedVariants: [
                "cp config.conf config.conf.backup_$(date +%F)",
                "cp config.conf config.conf.backup_$(date +%Y-%m-%d)",
              ],
              explanation:
                "`cp` kopiert die Datei, `$(date +%F)` wird durch das aktuelle Datum im Format YYYY-MM-DD ersetzt.",
            },
          ],
        },

        cp_r: {
          title: "cp -r",
          description: "Kopiert einen Ordner rekursiv mit Inhalt.",
          explanation: "Ordner rekursiv kopieren.",
          simpleExample: "cp -r ProjektA ProjektA_backup",
          detail:
            "-r oder besser -R ist für Verzeichnisse notwendig – sonst Fehler.",
          complexExample: "cp -r /var/www/site /var/backups/site_$(date +%F)",
          complexExampleExplanation: [
            {
              line: "cp -r /var/www/site /var/backups/site_$(date +%F)",
              explanation:
                "Kopiert rekursiv (-r) den gesamten site-Ordner inklusive aller Unterordner und Dateien, $(date +%F) fügt das Datum zum Zielnamen hinzu für ein datiertes Backup",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cp -r Ordner1 Ordner2`?",
              options: [
                "Kopiert nur den Ordner ohne Inhalt",
                "Kopiert den Ordner rekursiv mit allen Inhalten",
                "Verschiebt den Ordner",
                "Löscht den Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) kopiert den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt:
                "Was passiert, wenn du `cp Ordner1 Ordner2` ohne `-r` ausführst?",
              options: [
                "Es funktioniert normal",
                "Fehler: Ordner können nicht kopiert werden",
                "Es kopiert nur die Dateien im Ordner",
                "Es erstellt einen leeren Ordner",
              ],
              correctIndex: 1,
              explanation:
                "Ohne `-r` gibt `cp` einen Fehler aus, da Ordner nicht direkt kopiert werden können.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst den gesamten Ordner `project` rekursiv inklusive aller Unterordner und Dateien nach `project_backup` kopieren. Schreibe den Befehl.",
              correctCommand: "cp -r project project_backup",
              acceptedVariants: [
                "cp -r project project_backup",
                "cp -R project project_backup",
              ],
              explanation:
                "`cp -r` (recursive) kopiert den gesamten Ordner inklusive aller Unterordner und Dateien rekursiv.",
            },
          ],
        },

        rm: {
          title: "rm",
          description: "Löscht Dateien.",
          explanation: "Datei löschen.",
          simpleExample: "rm temp.txt",
          detail: "Kein Papierkorb! Weg ist weg. Nutze rm -i für Sicherheit.",
          complexExample: "rm -i *.tmp",
          complexExampleExplanation: [
            {
              line: "rm -i *.tmp",
              explanation:
                "Löscht alle .tmp-Dateien, -i (interactive) fragt vor jedem Löschen nach Bestätigung (sicherer als ohne -i)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei löschen und dann prüfen ob sie weg ist</strong><br>
            <code>rm temp.txt</code><br>
            <code>ls</code><br>
            → Löscht die Datei, ls zeigt dass sie nicht mehr existiert<br><br>

            ✅ <strong>2. Dateien auflisten, dann bestimmte löschen</strong><br>
            <code>ls *.log</code><br>
            <code>rm *.log</code><br>
            → Zeigt alle .log-Dateien, rm löscht sie alle<br><br>

            ✅ <strong>3. In einen Ordner wechseln, löschen, zurückkehren</strong><br>
            <code>cd temp/</code><br>
            <code>rm old_file.txt</code><br>
            <code>cd ..</code><br>
            → Wechselt ins temp-Verzeichnis, löscht eine Datei, kehrt zurück<br><br>

            ✅ <strong>4. Datei kopieren, dann Original löschen</strong><br>
            <code>cp important.txt backup/</code><br>
            <code>rm important.txt</code><br>
            → Kopiert die Datei ins Backup, löscht dann das Original<br><br>

            ✅ <strong>5. Liste speichern, dann Dateien löschen</strong><br>
            <code>ls > dateien_liste.txt</code><br>
            <code>rm temp*.txt</code><br>
            → Speichert die Liste, löscht dann alle temp*.txt Dateien
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm datei.txt`?",
              options: [
                "Verschiebt datei.txt in den Papierkorb",
                "Löscht datei.txt endgültig",
                "Kopiert datei.txt",
                "Zeigt datei.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`rm` löscht Dateien endgültig – es gibt keinen Papierkorb in der Shell.",
            },
            {
              level: "mittel",
              prompt:
                "Wie kannst du sicherstellen, dass `rm` vor dem Löschen fragt?",
              options: [
                "rm -f datei.txt",
                "rm -i datei.txt",
                "rm -r datei.txt",
                "rm --ask datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`rm -i` (interactive) fragt vor jedem Löschen nach – viel sicherer.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst alle `.tmp`-Dateien im aktuellen Verzeichnis löschen, aber vor jedem Löschen nachfragen. Schreibe den Befehl.",
              correctCommand: "rm -i *.tmp",
              acceptedVariants: ["rm -i *.tmp"],
              explanation:
                "`rm -i` (interactive) fragt vor jedem Löschen nach Bestätigung, `*.tmp` ist ein Wildcard-Muster für alle .tmp-Dateien.",
            },
          ],
        },

        rm_r: {
          title: "rm -r",
          description: "Löscht Ordner rekursiv inkl. aller Inhalte.",
          explanation: "Ordner rekursiv löschen.",
          simpleExample: "rm -r Backup/",
          detail:
            "rm -rf (force) ist extrem gefährlich – löscht ohne Nachfragen, auch schreibgeschütztes.",
          complexExample: "rm -r build/ dist/ .cache/ 2>/dev/null",
          complexExampleExplanation: [
            {
              line: "rm -r build/ dist/ .cache/ 2>/dev/null",
              explanation:
                "Löscht rekursiv (-r) drei Ordner, 2>/dev/null leitet Fehler (stderr) ins Nichts um, sodass Fehlermeldungen (z.B. wenn Ordner nicht existieren) nicht angezeigt werden",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `rm -r Ordner/`?",
              options: [
                "Löscht nur den leeren Ordner",
                "Löscht den Ordner rekursiv mit allen Inhalten",
                "Kopiert den Ordner",
                "Zeigt den Ordner an",
              ],
              correctIndex: 1,
              explanation:
                "`-r` (recursive) löscht den gesamten Ordner inklusive aller Unterordner und Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `rm -rf` besonders gefährlich?",
              options: [
                "Es ist langsam",
                "Es löscht ohne Nachfrage, auch schreibgeschützte Dateien",
                "Es kopiert Dateien",
                "Es zeigt zu viele Informationen",
              ],
              correctIndex: 1,
              explanation:
                "`-rf` kombiniert rekursiv + force – löscht alles ohne Nachfrage, auch schreibgeschützte Dateien. Sehr gefährlich!",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst drei Ordner rekursiv löschen (`build`, `dist`, `.cache`) und Fehlermeldungen verstecken falls Ordner nicht existieren. Schreibe den Befehl.",
              correctCommand: "rm -r build/ dist/ .cache/ 2>/dev/null",
              acceptedVariants: [
                "rm -r build/ dist/ .cache/ 2>/dev/null",
                "rm -r build dist .cache 2>/dev/null",
              ],
              explanation:
                "`rm -r` löscht rekursiv, `2>/dev/null` leitet Fehler (stderr) ins Nichts um, sodass Fehlermeldungen nicht angezeigt werden.",
            },
          ],
        },

        cat: {
          title: "cat",
          description: "Gibt den Inhalt einer Datei auf stdout aus.",
          explanation: "Datei anzeigen.",
          simpleExample: "cat notes.txt",
          detail:
            "Mehrere Dateien werden hintereinander ausgegeben: cat a.txt b.txt.",
          complexExample: "cat header.conf main.conf footer.conf > full.conf",
          complexExampleExplanation: [
            {
              line: "cat header.conf main.conf footer.conf > full.conf",
              explanation:
                "cat liest drei Dateien nacheinander und gibt sie hintereinander aus, > leitet die kombinierte Ausgabe in full.conf um (überschreibt die Datei)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `cat datei.txt`?",
              options: [
                "Kopiert datei.txt",
                "Zeigt den Inhalt von datei.txt an",
                "Löscht datei.txt",
                "Erstellt datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`cat` (concatenate) gibt den Inhalt einer Datei auf stdout aus.",
            },
            {
              level: "mittel",
              prompt: "Was macht `cat a.txt b.txt`?",
              options: [
                "Zeigt nur a.txt",
                "Zeigt a.txt und b.txt hintereinander",
                "Vergleicht die Dateien",
                "Löscht beide Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`cat` kann mehrere Dateien verketten und gibt sie hintereinander aus.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst drei Config-Dateien (`header.conf`, `main.conf`, `footer.conf`) zu einer Datei `full.conf` zusammenfügen. Schreibe den Befehl.",
              correctCommand:
                "cat header.conf main.conf footer.conf > full.conf",
              acceptedVariants: [
                "cat header.conf main.conf footer.conf > full.conf",
              ],
              explanation:
                "`cat` liest drei Dateien nacheinander und gibt sie hintereinander aus, `>` leitet die kombinierte Ausgabe in `full.conf` um.",
            },
          ],
        },

        sort: {
          title: "sort",
          description: "Sortiert Zeilen alphabetisch.",
          explanation: "alphabetisch sortieren.",
          simpleExample: "sort namen.txt",
          detail: "Mit -r wird absteigend sortiert.",
          complexExample: "sort namen.txt | uniq > namen_uniq.txt",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq > namen_uniq.txt",
              explanation:
                "sort sortiert die Zeilen alphabetisch, | leitet an uniq weiter (entfernt aufeinanderfolgende Duplikate), > speichert das Ergebnis in namen_uniq.txt",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei anzeigen, dann sortieren</strong><br>
            <code>cat namen.txt</code><br>
            <code>sort namen.txt</code><br>
            → cat zeigt den Inhalt, sort zeigt die sortierte Version<br><br>

            ✅ <strong>2. Nach bestimmten Zeilen suchen, dann sortieren</strong><br>
            <code>grep "admin" users.txt</code><br>
            <code>grep "admin" users.txt | sort</code><br>
            → grep findet alle "admin" Zeilen, sort sortiert sie alphabetisch<br><br>

            ✅ <strong>3. Mehrere Dateien zusammenfügen und sortieren</strong><br>
            <code>cat liste1.txt liste2.txt</code><br>
            <code>cat liste1.txt liste2.txt | sort</code><br>
            → cat zeigt beide Dateien zusammen, sort sortiert das kombinierte Ergebnis<br><br>

            ✅ <strong>4. Sortieren und nur die ersten 10 Zeilen zeigen</strong><br>
            <code>sort große_liste.txt</code><br>
            <code>sort große_liste.txt | head -n 10</code><br>
            → Sortiert die Liste, head zeigt nur die ersten 10 Zeilen<br><br>

            ✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
            <code>sort emails.txt | uniq</code><br>
            <code>sort emails.txt | uniq | wc -l</code><br>
            → Sortiert, entfernt Duplikate mit uniq, wc -l zählt die eindeutigen Zeilen
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sort datei.txt`?",
              options: [
                "Zeigt datei.txt an",
                "Sortiert die Zeilen alphabetisch",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation: "`sort` sortiert Zeilen alphabetisch (aufsteigend).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du absteigend (rückwärts)?",
              options: [
                "sort -d datei.txt",
                "sort -r datei.txt",
                "sort -n datei.txt",
                "sort --reverse datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -r` (reverse) sortiert absteigend – von Z nach A.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst eine Datei `namen.txt` sortieren, Duplikate entfernen und das Ergebnis in `namen_uniq.txt` speichern. Schreibe den Befehl mit Pipe und Redirection.",
              correctCommand: "sort namen.txt | uniq > namen_uniq.txt",
              acceptedVariants: ["sort namen.txt | uniq > namen_uniq.txt"],
              explanation:
                "`sort` sortiert alphabetisch, `| uniq` entfernt aufeinanderfolgende Duplikate, `>` speichert das Ergebnis in `namen_uniq.txt`.",
            },
          ],
        },

        sort_n: {
          title: "sort -n",
          description:
            "Sortiert Zeilen numerisch (Zahlen korrekt, nicht als Text).",
          explanation: "numerisch sortieren.",
          simpleExample: "sort -n zahlen.txt",
          detail:
            "Mit -n wird z. B. 2 vor 10 einsortiert (bei normalem sort käme 10 vor 2).",
          complexExample: "sort -n zahlen.txt | tail -n 5",
          complexExampleExplanation: [
            {
              line: "sort -n zahlen.txt | tail -n 5",
              explanation:
                "sort -n sortiert numerisch (nicht alphabetisch, damit 2 vor 10 kommt), | leitet an tail -n 5 weiter, das die letzten 5 Zeilen zeigt (also die 5 größten Zahlen)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei anzeigen, dann numerisch sortieren</strong><br>
            <code>cat zahlen.txt</code><br>
            <code>sort -n zahlen.txt</code><br>
            → cat zeigt den Inhalt, sort -n sortiert Zahlen korrekt (2 vor 10)<br><br>

            ✅ <strong>2. Normal sortieren vs. numerisch sortieren</strong><br>
            <code>sort zahlen.txt</code><br>
            <code>sort -n zahlen.txt</code><br>
            → sort sortiert als Text (10 vor 2), sort -n sortiert numerisch (2 vor 10)<br><br>

            ✅ <strong>3. Sortieren und dann die größten Zahlen zeigen</strong><br>
            <code>sort -n zahlen.txt</code><br>
            <code>sort -n zahlen.txt | tail -n 5</code><br>
            → Sortiert numerisch, tail zeigt die letzten 5 (die größten)<br><br>

            ✅ <strong>4. Sortieren, Duplikate entfernen, dann zählen</strong><br>
            <code>sort -n zahlen.txt | uniq</code><br>
            <code>sort -n zahlen.txt | uniq | wc -l</code><br>
            → Sortiert numerisch, entfernt Duplikate, wc -l zählt eindeutige Zahlen<br><br>

            ✅ <strong>5. Mehrere Dateien kombinieren und numerisch sortieren</strong><br>
            <code>cat liste1.txt liste2.txt | sort -n</code><br>
            → Kombiniert beide Dateien, sort -n sortiert alle Zahlen korrekt
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `sort` und `sort -n`?",
              options: [
                "Kein Unterschied",
                "sort sortiert alphabetisch, sort -n numerisch",
                "sort -n ist schneller",
                "sort -n funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`sort` sortiert als Text (10 kommt vor 2), `sort -n` sortiert numerisch (2 kommt vor 10).",
            },
            {
              level: "mittel",
              prompt: "Wie sortierst du eine Datei mit Zahlen numerisch?",
              options: [
                "sort zahlen.txt",
                "sort -n zahlen.txt",
                "sort --number zahlen.txt",
                "sort -r zahlen.txt",
              ],
              correctIndex: 1,
              explanation:
                "`sort -n` sortiert numerisch – wichtig für Zahlen, damit 2 vor 10 kommt.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst eine Datei `zahlen.txt` numerisch sortieren und dann die 5 größten Zahlen anzeigen. Schreibe den Befehl mit Pipe.",
              correctCommand: "sort -n zahlen.txt | tail -n 5",
              acceptedVariants: ["sort -n zahlen.txt | tail -n 5"],
              explanation:
                "`sort -n` sortiert numerisch (nicht alphabetisch, damit 2 vor 10 kommt), `| tail -n 5` zeigt die letzten 5 Zeilen (die 5 größten Zahlen).",
            },
          ],
        },

        uniq: {
          title: "uniq",
          description: "Entfernt doppelte aufeinanderfolgende Zeilen.",
          explanation: "entfernt aufeinanderfolgende Duplikate.",
          simpleExample: "uniq liste.txt",
          detail:
            "Oft mit sort kombiniert, weil nur direkt aufeinanderfolgende Duplikate erkannt werden.",
          complexExample: "sort namen.txt | uniq -c | sort -n",
          complexExampleExplanation: [
            {
              line: "sort namen.txt | uniq -c | sort -n",
              explanation:
                "sort sortiert alphabetisch, | leitet an uniq -c weiter (zählt Vorkommen jedes Namens), | leitet an sort -n weiter (sortiert nach Anzahl, kleinste zuerst)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei anzeigen, dann Duplikate entfernen</strong><br>
            <code>cat liste.txt</code><br>
            <code>uniq liste.txt</code><br>
            → cat zeigt den Inhalt, uniq entfernt aufeinanderfolgende Duplikate<br><br>

            ✅ <strong>2. Erst sortieren, dann Duplikate entfernen</strong><br>
            <code>sort namen.txt</code><br>
            <code>sort namen.txt | uniq</code><br>
            → Sortiert die Namen, uniq entfernt dann alle Duplikate (weil sie zusammen sind)<br><br>

            ✅ <strong>3. Mehrere Dateien kombinieren, sortieren, Duplikate entfernen</strong><br>
            <code>cat file1.txt file2.txt | sort</code><br>
            <code>cat file1.txt file2.txt | sort | uniq</code><br>
            → Kombiniert beide Dateien, sort sortiert, uniq entfernt Duplikate<br><br>

            ✅ <strong>4. Nach etwas suchen, dann Duplikate entfernen</strong><br>
            <code>grep "user" log.txt</code><br>
            <code>grep "user" log.txt | sort | uniq</code><br>
            → Findet alle "user" Einträge, sort sortiert, uniq entfernt doppelte Zeilen<br><br>

            ✅ <strong>5. Duplikate entfernen und dann zählen</strong><br>
            <code>sort emails.txt | uniq</code><br>
            <code>sort emails.txt | uniq | wc -l</code><br>
            → Sortiert, entfernt Duplikate, wc -l zählt wie viele eindeutige Einträge es gibt
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `uniq datei.txt`?",
              options: [
                "Sortiert die Datei",
                "Entfernt aufeinanderfolgende doppelte Zeilen",
                "Kopiert die Datei",
                "Löscht die Datei",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` entfernt nur direkt aufeinanderfolgende Duplikate – daher oft mit `sort` kombiniert.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `uniq` oft mit `sort` kombiniert?",
              options: [
                "Weil sort schneller ist",
                "Weil uniq nur aufeinanderfolgende Duplikate erkennt",
                "Weil sort mehr Funktionen hat",
                "Weil uniq nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "`uniq` erkennt nur direkt aufeinanderfolgende Duplikate. `sort` bringt alle Duplikate zusammen, dann kann `uniq` sie entfernen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sort namen.txt | uniq -c | sort -n`?",
              options: [
                "Zeigt nur eindeutige Namen",
                "Sortiert, zählt Vorkommen jedes Namens, sortiert nach Häufigkeit",
                "Löscht Duplikate",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Sortiert → `uniq -c` zählt Vorkommen → `sort -n` sortiert nach Anzahl (häufigste zuletzt).",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Du hast eine unsortierte Liste `emails.txt` mit Duplikaten. Schreibe einen Befehl, der sortiert, Duplikate entfernt und das Ergebnis in `unique_emails.txt` speichert.",
              correctCommand: "sort emails.txt | uniq > unique_emails.txt",
              acceptedVariants: [
                "sort emails.txt | uniq > unique_emails.txt",
                "sort emails.txt | uniq | tee unique_emails.txt",
              ],
              explanation:
                "`sort` bringt identische Zeilen zusammen, `uniq` entfernt die Duplikate, `>` schreibt die bereinigte Liste in `unique_emails.txt`.",
            },
          ],
        },

        find_name: {
          title: "find . -name",
          description:
            "Sucht rekursiv nach Dateien/Ordnern mit Namen, der zum Muster passt.",
          explanation: "nach Name suchen.",
          simpleExample: 'find . -name "notes.txt"',
          detail: 'Muster können Wildcards enthalten: find . -name "*.log".',
          complexExample: 'find . -name "*.log" -type f -exec rm {} \\;',
          complexExampleExplanation: [
            {
              line: 'find . -name "*.log" -type f -exec rm {} \\;',
              explanation:
                "find sucht ab dem aktuellen Verzeichnis (.) nach Dateien (-type f) mit Namen *.log, -exec rm {} \\; führt rm für jede gefundene Datei aus ({} wird durch den Dateinamen ersetzt)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Alle .config-Dateien im aktuellen Verzeichnis finden</strong><br>
            <code>find . -name "*.config"</code><br><br>

            ✅ <strong>2. .config-Dateien nur im aktuellen Verzeichnis (ohne Unterordner)</strong><br>
            <code>find . -maxdepth 1 -name "*.config"</code><br><br>

            ✅ <strong>3. Nur reguläre Dateien (keine Ordner, keine Symlinks)</strong><br>
            <code>find . -type f -name "*.config"</code><br><br>

            ✅ <strong>4. Rekursiv und case-insensitive (.CONFIG, .Config usw.)</strong><br>
            <code>find . -iname "*.config"</code><br><br>

            ✅ <strong>5. Alle .config-Dateien + Dateigröße anzeigen</strong><br>
            <code>find . -type f -name "*.config" -exec ls -lh {} \\;</code><br><br>

            ✅ <strong>6. Nur die Anzahl der .config-Dateien</strong><br>
            <code>find . -type f -name "*.config" | wc -l</code><br><br>

            ✅ <strong>7. Unterhalb eines bestimmten Verzeichnisses (z. B. /etc)</strong><br>
            <code>find /etc -type f -name "*.config"</code><br><br>

            🛑 <strong>Gefährliche Varianten (nur Info, nicht nutzen!)</strong><br>
            <em>(Niemals löschen ohne exakt getestetes Pattern)</em><br><br>
            <code>find . -name "*.config" -delete</code><br>
            → sehr riskant, löscht sofort.<br><br>

            💡 <strong>Safe Default für dich:</strong><br>
            Wenn du einfach alle .config-Dateien finden möchtest:<br>
            <code>find . -type f -name "*.config"</code>
                      `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `find . -name "datei.txt"`?',
              options: [
                "Erstellt datei.txt",
                "Sucht rekursiv nach datei.txt",
                "Löscht datei.txt",
                "Kopiert datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`find . -name` sucht rekursiv ab dem aktuellen Verzeichnis (.) nach Dateien/Ordnern mit diesem Namen.",
            },
            {
              level: "mittel",
              prompt: "Wie suchst du nach allen .log-Dateien?",
              options: [
                'find . -name "log"',
                'find . -name "*.log"',
                "find . -type log",
                "find . -ext log",
              ],
              correctIndex: 1,
              explanation:
                'Mit Wildcards: `find . -name "*.log"` findet alle Dateien, die mit .log enden.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -name "*.log" -type f -exec rm {} \\;`?',
              options: [
                "Zeigt alle .log-Dateien",
                "Löscht alle .log-Dateien rekursiv",
                "Kopiert alle .log-Dateien",
                "Erstellt .log-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Findet alle .log-Dateien (`-type f` = nur Dateien), dann `-exec rm {} \\;` löscht jede gefundene Datei.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Finde unter `/etc` alle Dateien mit der Endung `.conf` und schreibe die vollstaendigen Pfade in `conf_files.txt`.",
              correctCommand:
                "find /etc -type f -name '*.conf' > conf_files.txt",
              acceptedVariants: [
                "find /etc -name '*.conf' -type f > conf_files.txt",
                "find /etc -type f -name '*.conf' > conf_files.txt",
              ],
              explanation:
                "`find /etc -type f` sucht nur Dateien, `-name *.conf` filtert die Muster, `>` leitet die Liste in `conf_files.txt` um.",
            },
          ],
        },

        find_maxdepth: {
          title: "find . -maxdepth 1 -type d",
          description:
            "Listet nur Ordner im aktuellen Verzeichnis (keine Unterordner).",
          explanation: "nur Ordner im aktuellen Verzeichnis.",
          simpleExample: "find . -maxdepth 1 -type d",
          detail: 'Mit ! -name "." schließt du das aktuelle Verzeichnis aus.',
          complexExample:
            'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
          complexExampleExplanation: [
            {
              line: 'find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt',
              explanation:
                'find sucht nur im aktuellen Verzeichnis (-maxdepth 1) nach Ordnern (-type d), ! -name "." schließt das aktuelle Verzeichnis aus, -printf "%f\\n" gibt nur den Dateinamen (ohne Pfad) aus, > speichert in folders.txt',
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `find . -maxdepth 1 -type d`?",
              options: [
                "Findet alle Ordner rekursiv",
                "Findet nur Ordner im aktuellen Verzeichnis (keine Unterordner)",
                "Findet nur Dateien",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-maxdepth 1` begrenzt die Suche auf das aktuelle Verzeichnis, `-type d` sucht nur nach Ordnern.",
            },
            {
              level: "mittel",
              prompt:
                "Wie schließt du das aktuelle Verzeichnis (.) aus der Suche aus?",
              options: [
                'find . -maxdepth 1 -type d -name "."',
                'find . -maxdepth 1 -type d ! -name "."',
                "find . -maxdepth 0 -type d",
                "Das geht nicht",
              ],
              correctIndex: 1,
              explanation:
                'Mit `! -name "."` (NOT name) schließt du das aktuelle Verzeichnis aus.',
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find . -maxdepth 1 -type d ! -name "." -printf "%f\\n" > folders.txt`?',
              options: [
                "Zeigt alle Ordner",
                "Speichert nur die Ordnernamen (ohne Pfad) in folders.txt",
                "Löscht alle Ordner",
                "Kopiert alle Ordner",
              ],
              correctIndex: 1,
              explanation:
                'Findet Ordner, schließt . aus, `-printf "%f\\n"` gibt nur den Dateinamen (ohne Pfad) aus, `>` speichert in folders.txt.',
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zaehle nur die direkten Unterordner (ohne `.`) im aktuellen Verzeichnis und schreibe die Zahl in `folder_count.txt`.",
              correctCommand:
                "find . -maxdepth 1 -mindepth 1 -type d | wc -l > folder_count.txt",
              acceptedVariants: [
                "find . -maxdepth 1 -type d ! -name '.' | wc -l > folder_count.txt",
                "find . -maxdepth 1 -mindepth 1 -type d | wc -l > folder_count.txt",
              ],
              explanation:
                "`-maxdepth 1` + `-mindepth 1` betrachtet nur die direkte Ebene, `-type d` filtert Ordner, `wc -l` zaehlt und `>` schreibt das Ergebnis in die Datei.",
            },
          ],
        },

        ls_R: {
          title: "ls -R",
          description:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          explanation:
            "Listet den gesamten Verzeichnisbaum rekursiv (alle Ordner und Dateien darunter).",
          simpleExample: "ls -R",
          detail:
            "Ohne Filter sehr unübersichtlich → wird oft mit grep kombiniert.",
          complexExample: 'ls -R | grep ":$"',
          complexExampleExplanation: [
            {
              line: 'ls -R | grep ":$"',
              explanation:
                'ls -R listet rekursiv alle Dateien und Ordner, | leitet an grep weiter, ":$" filtert nur Zeilen, die mit einem Doppelpunkt enden (Ordner werden von ls -R mit : am Ende angezeigt)',
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Normale Liste vs. rekursive Liste</strong><br>
            <code>ls</code><br>
            <code>ls -R</code><br>
            → ls zeigt nur das aktuelle Verzeichnis, ls -R zeigt alles rekursiv<br><br>

            ✅ <strong>2. Rekursive Liste speichern und dann anzeigen</strong><br>
            <code>ls -R > alle_struktur.txt</code><br>
            <code>cat alle_struktur.txt</code><br>
            → Speichert die gesamte Struktur in eine Datei, cat zeigt den Inhalt<br><br>

            ✅ <strong>3. Nach bestimmten Dateien suchen in der rekursiven Liste</strong><br>
            <code>ls -R</code><br>
            <code>ls -R | grep ".txt$"</code><br>
            → Zeigt alles rekursiv, grep filtert nur .txt-Dateien<br><br>

            ✅ <strong>4. Nur Ordner aus der rekursiven Liste zeigen</strong><br>
            <code>ls -R</code><br>
            <code>ls -R | grep ":$"</code><br>
            → Zeigt alles rekursiv, grep filtert nur Ordner (endet mit :)<br><br>

            ✅ <strong>5. Rekursive Liste sortieren und dann begrenzen</strong><br>
            <code>ls -R | sort</code><br>
            <code>ls -R | sort | head -n 20</code><br>
            → Sortiert die rekursive Liste alphabetisch, head zeigt nur die ersten 20 Einträge
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `ls -R`?",
              options: [
                "Listet nur das aktuelle Verzeichnis",
                "Listet den gesamten Verzeichnisbaum rekursiv",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) listet alle Dateien und Ordner rekursiv durch alle Unterordner.",
            },
            {
              level: "mittel",
              prompt: "Warum wird `ls -R` oft mit `grep` kombiniert?",
              options: [
                "Weil es schneller ist",
                "Weil die Ausgabe ohne Filter sehr unübersichtlich ist",
                "Weil grep mehr Funktionen hat",
                "Weil ls -R nicht funktioniert",
              ],
              correctIndex: 1,
              explanation:
                "Die rekursive Ausgabe kann sehr lang sein – `grep` filtert nach bestimmten Mustern.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner im gesamten Verzeichnisbaum?",
              options: [
                "ls -R | grep files",
                'ls -R | grep ":$"',
                'ls -R | grep "^d"',
                "ls -R | sort",
              ],
              correctIndex: 1,
              explanation:
                '`ls -R` zeigt Ordner mit `:` am Ende an – `grep ":$"` filtert nur diese Zeilen.',
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Leite eine rekursive Auflistung aller Ordner in `directories.txt` um (nur Ordnernamen, keine Dateien).",
              correctCommand: "ls -R | grep ':$' > directories.txt",
              acceptedVariants: [
                "ls -R | grep ':$' > directories.txt",
                "ls -R | grep ':$' > ./directories.txt",
              ],
              explanation:
                "`ls -R` zeigt alle Eintraege, Zeilen mit `:` markieren Ordner; `grep :$` filtert diese, `>` speichert sie in `directories.txt`.",
            },
          ],
        },

        ls_aR: {
          title: "ls -aR",
          description:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          explanation:
            "Rekursives Auflisten aller Dateien UND versteckter Dateien/Ordner.",
          simpleExample: "ls -aR",
          detail: "Zeigt ., .., .git, .config, usw. in jedem Unterordner.",
          complexExample: 'ls -aR ~ | grep "^\\." | wc -l',
          complexExampleExplanation: [
            {
              line: 'ls -aR ~ | grep "^\\." | wc -l',
              explanation:
                "ls -aR listet rekursiv alle Dateien im Home-Verzeichnis (inkl. versteckter), | leitet an grep weiter (filtert nur Zeilen die mit . beginnen), | leitet an wc -l weiter (zählt die Anzahl der Zeilen/Dateien)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was zeigt `ls -aR` zusätzlich zu `ls -R`?",
              options: [
                "Nur größere Dateien",
                "Versteckte Dateien und Ordner (beginnen mit .)",
                "Nur ausführbare Dateien",
                "Nur Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-a` zeigt versteckte Dateien, `-R` rekursiv – kombiniert: alle versteckten Dateien in allen Unterordnern.",
            },
            {
              level: "mittel",
              prompt: "Was zeigt `ls -aR` in jedem Unterordner?",
              options: [
                "Nur .",
                "Nur ..",
                "., .., .git, .config, usw.",
                "Nur Dateien",
              ],
              correctIndex: 2,
              explanation:
                "`-aR` zeigt in jedem Unterordner auch versteckte Einträge wie `.`, `..`, `.git`, `.config` etc.",
            },
            {
              level: "schwer",
              prompt:
                "Wie zählst du alle versteckten Dateien im Home-Verzeichnis?",
              options: [
                "ls -aR ~ | wc -l",
                'ls -aR ~ | grep "^\\." | wc -l',
                'ls -R ~ | grep "^\\."',
                'find ~ -name ".*"',
              ],
              correctIndex: 1,
              explanation:
                '`ls -aR ~` listet alles rekursiv, `grep "^\\."` filtert nur versteckte Dateien (beginnen mit .), `wc -l` zählt.',
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zaehle rekursiv alle versteckten Dateien (Beginnen mit `.`) in deinem Home und schreibe die Anzahl in `hidden_count.txt`.",
              correctCommand:
                "ls -aR ~ | grep '^\\.' | wc -l > hidden_count.txt",
              acceptedVariants: [
                "ls -aR ~ | grep '^\\.' | wc -l > hidden_count.txt",
                "ls -aR $HOME | grep '^\\.' | wc -l > hidden_count.txt",
              ],
              explanation:
                "`ls -aR` zeigt auch versteckte Eintraege, `grep '^\.'` filtert sie, `wc -l` zaehlt, `>` schreibt die Zahl in die Datei.",
            },
          ],
        },

        tree: {
          title: "tree",
          description: "Zeigt Verzeichnisstruktur in Baumform.",
          explanation: "Zeigt Verzeichnisstruktur in Baumform.",
          simpleExample: "tree",
          detail: "Wird oft manuell installiert (sudo apt install tree).",
          complexExample: "tree -d ~/Projects",
          complexExampleExplanation: [
            {
              line: "tree -d ~/Projects",
              explanation:
                "Zeigt die Verzeichnisstruktur von ~/Projects in Baumform, -d zeigt nur Ordner (directories), keine Dateien",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Normale Liste vs. Baumstruktur</strong><br>
            <code>ls</code><br>
            <code>tree</code><br>
            → ls zeigt flache Liste, tree zeigt hierarchische Struktur<br><br>

            ✅ <strong>2. Baumstruktur speichern und dann anzeigen</strong><br>
            <code>tree > struktur.txt</code><br>
            <code>cat struktur.txt</code><br>
            → Speichert die Baumstruktur in eine Datei, cat zeigt den Inhalt<br><br>

            ✅ <strong>3. In einen Ordner wechseln und Baumstruktur zeigen</strong><br>
            <code>cd projects</code><br>
            <code>tree</code><br>
            → Wechselt ins projects-Verzeichnis, zeigt die Struktur dort<br><br>

            ✅ <strong>4. Baumstruktur begrenzen und dann speichern</strong><br>
            <code>tree -L 2</code><br>
            <code>tree -L 2 > struktur_2_ebenen.txt</code><br>
            → Zeigt nur 2 Ebenen, speichert das Ergebnis<br><br>

            ✅ <strong>5. Baumstruktur anzeigen und dann nach etwas suchen</strong><br>
            <code>tree</code><br>
            <code>tree | grep "config"</code><br>
            → Zeigt die Struktur, grep filtert nur Zeilen mit "config"
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree`?",
              options: [
                "Löscht Bäume",
                "Zeigt Verzeichnisstruktur in Baumform",
                "Kopiert Verzeichnisse",
                "Sortiert Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`tree` zeigt die Verzeichnisstruktur als visuellen Baum – sehr übersichtlich.",
            },
            {
              level: "mittel",
              prompt: "Was musst du tun, wenn `tree` nicht verfügbar ist?",
              options: [
                "Nichts, es ist immer installiert",
                "Manuell installieren: sudo apt install tree",
                "Es gibt keinen Ersatz",
                "Es funktioniert automatisch",
              ],
              correctIndex: 1,
              explanation:
                "`tree` ist nicht standardmäßig installiert – muss mit `sudo apt install tree` (oder ähnlich) installiert werden.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du nur Ordner in der Baumstruktur?",
              options: ["tree -f", "tree -d", "tree -a", "tree -l"],
              correctIndex: 1,
              explanation:
                "`tree -d` (directory-only) zeigt nur Ordner, keine Dateien – perfekt für Strukturübersicht.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Erzeuge eine Baumansicht nur der Ordner unter `/var/www` und speichere sie in `tree_www.txt`.",
              correctCommand: "tree -d /var/www > tree_www.txt",
              acceptedVariants: [
                "tree -d /var/www > tree_www.txt",
                "tree -d /var/www/ > tree_www.txt",
              ],
              explanation:
                "`tree -d` zeigt nur Verzeichnisse, `/var/www` ist der Startpunkt, `>` schreibt die Struktur in die Datei.",
            },
          ],
        },

        tree_d: {
          title: "tree -d",
          description: "Zeigt nur Ordner (directory-only mode).",
          explanation: "Zeigt nur Ordner (directory-only mode).",
          simpleExample: "tree -d",
          detail: "Perfekt, um reinen Ordneraufbau zu sehen.",
          complexExample: "tree -d -L 2",
          complexExampleExplanation: [
            {
              line: "tree -d -L 2",
              explanation:
                "Zeigt nur Ordner (-d) in Baumform, -L 2 begrenzt die Tiefe auf 2 Ebenen (nur direkt sichtbare Ordner und deren Unterordner)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -d`?",
              options: [
                "Zeigt nur Dateien",
                "Zeigt nur Ordner",
                "Zeigt alles",
                "Löscht Ordner",
              ],
              correctIndex: 1,
              explanation:
                "`-d` steht für 'directory-only' – zeigt nur Ordner, keine Dateien.",
            },
            {
              level: "mittel",
              prompt: "Wann ist `tree -d` besonders nützlich?",
              options: [
                "Wenn man Dateien sehen will",
                "Wenn man nur den reinen Ordneraufbau sehen will",
                "Wenn man Dateien löschen will",
                "Wenn man Dateien kopieren will",
              ],
              correctIndex: 1,
              explanation:
                "`tree -d` ist perfekt, um die reine Verzeichnisstruktur ohne Dateien zu überblicken.",
            },
            {
              level: "schwer",
              prompt: "Wie begrenzt du die Tiefe auf 2 Ebenen?",
              options: [
                "tree -d -L 2",
                "tree -d -d 2",
                "tree -d -max 2",
                "tree -d 2",
              ],
              correctIndex: 0,
              explanation:
                "`-L 2` begrenzt die Tiefe auf 2 Ebenen – kombiniert mit `-d` nur Ordner bis Ebene 2.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zeige nur Ordner bis Tiefe 2 ab dem aktuellen Verzeichnis und schreibe die Ausgabe in `struktur.txt`.",
              correctCommand: "tree -d -L 2 > struktur.txt",
              acceptedVariants: [
                "tree -d -L 2 > struktur.txt",
                "tree -L 2 -d > struktur.txt",
              ],
              explanation:
                "`-d` blendet Dateien aus, `-L 2` begrenzt die Tiefe, `>` leitet in `struktur.txt` um.",
            },
          ],
        },

        tree_L: {
          title: "tree -L",
          description: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          explanation: "Begrenzt die Tiefe der rekursiven Baumdarstellung.",
          simpleExample: "tree -L 1",
          detail: "Hilft, tiefe Strukturen übersichtlich zu halten.",
          complexExample: "sudo tree -L 3 /",
          complexExampleExplanation: [
            {
              line: "sudo tree -L 3 /",
              explanation:
                "sudo gibt Root-Rechte, tree zeigt die Verzeichnisstruktur des Wurzelverzeichnisses (/), -L 3 begrenzt die Tiefe auf 3 Ebenen (benötigt sudo für Systemverzeichnisse)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tree -L 1`?",
              options: [
                "Zeigt nur die erste Ebene",
                "Zeigt alle Ebenen",
                "Löscht die erste Ebene",
                "Kopiert die erste Ebene",
              ],
              correctIndex: 0,
              explanation:
                "`-L 1` begrenzt die Ausgabe auf die erste Ebene – nur direkt sichtbare Ordner/Dateien.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `tree -L` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es tiefe Strukturen übersichtlich hält",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Bei sehr tiefen Verzeichnisstrukturen hilft `-L`, die Ausgabe übersichtlich zu begrenzen.",
            },
            {
              level: "schwer",
              prompt: "Wie zeigst du die obersten drei Ebenen des Systems?",
              options: [
                "tree -L 3 /",
                "tree -d 3 /",
                "tree -a 3 /",
                "tree 3 /",
              ],
              correctIndex: 0,
              explanation:
                "`sudo tree -L 3 /` zeigt die obersten 3 Ebenen des Wurzelverzeichnisses (benötigt sudo für Systemverzeichnisse).",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Gib die obersten drei Ebenen von `/etc` als Baum aus und speichere das Ergebnis in `etc_top3.txt`.",
              correctCommand: "tree -L 3 /etc > etc_top3.txt",
              acceptedVariants: [
                "tree -L 3 /etc > etc_top3.txt",
                "sudo tree -L 3 /etc > etc_top3.txt",
              ],
              explanation:
                "`tree -L 3 /etc` begrenzt die Tiefe auf drei Ebenen ab /etc, `>` schreibt die Ausgabe in die Datei.",
            },
          ],
        },

        echo: {
          title: "echo",
          description: "Gibt Text im Terminal aus.",
          explanation: "Gibt Text im Terminal aus.",
          simpleExample: 'echo "Hallo Welt"',
          detail: "Mit >> nützlich zum Schreiben in Logdateien.",
          complexExample: 'echo "Starte Backup am $(date)" >> backup.log',
          complexExampleExplanation: [
            {
              line: 'echo "Starte Backup am $(date)" >> backup.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch das aktuelle Datum und die Uhrzeit ersetzt, >> hängt den Text an backup.log an (ohne Überschreibung)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Text ausgeben und dann in eine Datei schreiben</strong><br>
            <code>echo "Hallo"</code><br>
            <code>echo "Hallo" > greeting.txt</code><br>
            → Erst zeigt echo den Text, dann schreibt > ihn in eine Datei<br><br>

            ✅ <strong>2. Text an eine Datei anhängen (statt überschreiben)</strong><br>
            <code>echo "Zeile 1" > log.txt</code><br>
            <code>echo "Zeile 2" >> log.txt</code><br>
            → > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

            ✅ <strong>3. Mehrere Zeilen schreiben und dann anzeigen</strong><br>
            <code>echo "Start" > status.txt</code><br>
            <code>echo "Läuft" >> status.txt</code><br>
            <code>cat status.txt</code><br>
            → Schreibt zwei Zeilen, cat zeigt den Inhalt<br><br>

            ✅ <strong>4. Text in Datei schreiben und dann den Ordner auflisten</strong><br>
            <code>echo "Test" > test.txt</code><br>
            <code>ls</code><br>
            → Erstellt eine Datei mit echo, ls zeigt dass sie existiert<br><br>

            ✅ <strong>5. Fehlerausgabe umleiten (statt normale Ausgabe)</strong><br>
            <code>echo "Fehler!"</code><br>
            <code>echo "Fehler!" > output.txt</code><br>
            <code>echo "Fehler!" 2> error.txt</code><br>
            → > schreibt normale Ausgabe, 2> schreibt Fehlerausgabe
                      `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Hallo"`?',
              options: [
                "Löscht Hallo",
                "Gibt 'Hallo' im Terminal aus",
                "Kopiert Hallo",
                "Erstellt eine Datei Hallo",
              ],
              correctIndex: 1,
              explanation:
                "`echo` gibt Text auf stdout aus – im Terminal sichtbar.",
            },
            {
              level: "mittel",
              prompt: "Wie schreibst du Text in eine Logdatei?",
              options: [
                'echo "Text" > log.txt',
                'echo "Text" >> log.txt',
                'echo "Text" | log.txt',
                'echo "Text" log.txt',
              ],
              correctIndex: 1,
              explanation:
                "Mit `>>` wird Text an die Datei angehängt – ideal für Logdateien, die wachsen sollen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Starte Backup am $(date)" >> backup.log`?',
              options: [
                "Zeigt nur das Datum",
                "Schreibt 'Starte Backup am [aktuelles Datum]' in backup.log",
                "Löscht backup.log",
                "Kopiert backup.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(date)` wird durch das aktuelle Datum ersetzt, dann wird der gesamte Text an backup.log angehängt.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                'Schreibe den Text "Deploy gestartet: <Datum>" dynamisch an das Ende von `deploy.log`.',
              correctCommand: 'echo "Deploy gestartet: $(date)" >> deploy.log',
              acceptedVariants: [
                'echo "Deploy gestartet: $(date)" >> deploy.log',
                'echo "Deploy gestartet: $(date)" >> ./deploy.log',
              ],
              explanation:
                "`echo` erzeugt die Zeile, `$(date)` fuegt das aktuelle Datum ein, `>>` haengt sie an `deploy.log` an.",
            },
          ],
        },

        redirect_overwrite: {
          title: ">",
          description: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          explanation: "Leitet die Ausgabe in eine Datei um (überschreibt).",
          simpleExample: 'echo "Hallo" > info.txt',
          detail: "Achtung: überschreibt komplett ohne Warnung.",
          complexExample: "ls /etc > etc_contents.txt",
          complexExampleExplanation: [
            {
              line: "ls /etc > etc_contents.txt",
              explanation:
                "ls listet den Inhalt von /etc auf, > leitet die Ausgabe in etc_contents.txt um (überschreibt die Datei komplett, falls sie existiert)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Text ausgeben vs. in Datei speichern</strong><br>
            <code>echo "Hallo"</code><br>
            <code>echo "Hallo" > greeting.txt</code><br>
            → Erst zeigt echo den Text, dann speichert > ihn in eine Datei<br><br>

            ✅ <strong>2. Dateiliste speichern und dann anzeigen</strong><br>
            <code>ls</code><br>
            <code>ls > dateien.txt</code><br>
            <code>cat dateien.txt</code><br>
            → ls zeigt Dateien, > speichert die Liste, cat zeigt den Inhalt<br><br>

            ✅ <strong>3. Dateiinhalt kopieren in neue Datei</strong><br>
            <code>cat original.txt</code><br>
            <code>cat original.txt > backup.txt</code><br>
            → Zeigt den Inhalt, dann speichert > ihn in backup.txt<br><br>

            ✅ <strong>4. Nach etwas suchen und Ergebnisse speichern</strong><br>
            <code>grep "Error" log.txt</code><br>
            <code>grep "Error" log.txt > fehler.txt</code><br>
            → Findet Fehler, > speichert alle Treffer in fehler.txt<br><br>

            ✅ <strong>5. Mehrere Dateien kombinieren und speichern</strong><br>
            <code>cat file1.txt file2.txt</code><br>
            <code>cat file1.txt file2.txt > kombiniert.txt</code><br>
            → Zeigt beide Dateien zusammen, > speichert das kombinierte Ergebnis
                      `,
          questions: [
            {
              level: "leicht",
              prompt: 'Was macht `echo "Text" > datei.txt`?',
              options: [
                "Hängt Text an datei.txt an",
                "Überschreibt datei.txt mit Text (oder erstellt die Datei)",
                "Zeigt Text nur im Terminal",
                "Löscht datei.txt",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett oder erstellt sie, wenn sie nicht existiert.",
            },
            {
              level: "mittel",
              prompt: "Was passiert, wenn die Datei bereits existiert?",
              options: [
                "Es wird nachgefragt",
                "Die Datei wird komplett überschrieben ohne Warnung",
                "Die Datei wird gelöscht",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt ohne Warnung – Vorsicht! Alle bisherigen Inhalte gehen verloren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls /etc > etc_contents.txt`?",
              options: [
                "Zeigt /etc im Terminal",
                "Speichert die Liste von /etc in etc_contents.txt",
                "Löscht /etc",
                "Kopiert /etc",
              ],
              correctIndex: 1,
              explanation:
                "Die Ausgabe von `ls /etc` wird in die Datei etc_contents.txt umgeleitet (überschreibt sie).",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Ueberschreibe `status.log` mit der aktuellen Speicher- und Plattenauslastung (`df -h`).",
              correctCommand: "df -h > status.log",
              acceptedVariants: ["df -h > status.log", "df -h > ./status.log"],
              explanation:
                "`df -h` zeigt belegten Speicher in menschenlesbarer Form, `>` ueberschreibt `status.log` mit dieser Ausgabe.",
            },
          ],
        },

        redirect_append: {
          title: ">>",
          description: "Hängt die Ausgabe ans Ende einer Datei an.",
          explanation: "Hängt die Ausgabe ans Ende einer Datei an.",
          simpleExample: 'echo "Neue Zeile" >> log.txt',
          detail: "Datei wird nicht gelöscht wie bei >.",
          complexExample: 'echo "$(date): Prozess gestartet" >> system.log',
          complexExampleExplanation: [
            {
              line: 'echo "$(date): Prozess gestartet" >> system.log',
              explanation:
                "echo gibt Text aus, $(date) wird durch Datum/Uhrzeit ersetzt, >> hängt den Text am Ende von system.log an (bisheriger Inhalt bleibt erhalten)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Überschreiben vs. Anhängen</strong><br>
            <code>echo "Zeile 1" > log.txt</code><br>
            <code>echo "Zeile 2" >> log.txt</code><br>
            → > überschreibt, >> hängt an (beide Zeilen bleiben erhalten)<br><br>

            ✅ <strong>2. Text anhängen und dann anzeigen</strong><br>
            <code>echo "Neu" >> status.txt</code><br>
            <code>cat status.txt</code><br>
            → Hängt Text an die Datei, cat zeigt den gesamten Inhalt<br><br>

            ✅ <strong>3. Liste speichern, dann weitere Einträge anhängen</strong><br>
            <code>ls > dateien.txt</code><br>
            <code>ls -a >> dateien.txt</code><br>
            → Speichert normale Liste, >> hängt versteckte Dateien an<br><br>

            ✅ <strong>4. Mehrere Zeilen nacheinander anhängen</strong><br>
            <code>echo "Start" >> log.txt</code><br>
            <code>echo "Mitte" >> log.txt</code><br>
            <code>echo "Ende" >> log.txt</code><br>
            → Hängt drei Zeilen nacheinander an, alle bleiben erhalten<br><br>

            ✅ <strong>5. Suche-Ergebnisse anhängen statt überschreiben</strong><br>
            <code>grep "Error" log1.txt > fehler.txt</code><br>
            <code>grep "Error" log2.txt >> fehler.txt</code><br>
            → Speichert erste Suche, >> hängt zweite Suche an (kombiniert beide)
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was ist der Unterschied zwischen `>` und `>>`?",
              options: [
                "Kein Unterschied",
                "`>` überschreibt, `>>` hängt an",
                "`>>` ist schneller",
                "`>` funktioniert nicht",
              ],
              correctIndex: 1,
              explanation:
                "`>` überschreibt die Datei komplett, `>>` hängt neuen Inhalt am Ende an.",
            },
            {
              level: "mittel",
              prompt: "Was passiert mit dem bisherigen Inhalt bei `>>`?",
              options: [
                "Er wird gelöscht",
                "Er bleibt erhalten, neuer Inhalt wird angehängt",
                "Er wird überschrieben",
                "Nichts passiert",
              ],
              correctIndex: 1,
              explanation:
                "Bei `>>` bleibt der bisherige Inhalt erhalten – neuer Inhalt wird einfach angehängt.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "$(date): Prozess gestartet" >> system.log`?',
              options: [
                "Überschreibt system.log",
                "Hängt '[Datum]: Prozess gestartet' an system.log an",
                "Löscht system.log",
                "Zeigt nur das Datum",
              ],
              correctIndex: 1,
              explanation:
                "Das aktuelle Datum wird eingefügt, dann wird der Text an system.log angehängt (ideal für Logs).",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Haenge die letzten 20 Zeilen aus `/var/log/syslog` an `errors.log` an.",
              correctCommand: "tail -n 20 /var/log/syslog >> errors.log",
              acceptedVariants: [
                "tail -n 20 /var/log/syslog >> errors.log",
                "tail -20 /var/log/syslog >> errors.log",
              ],
              explanation:
                "`tail -n 20` holt die letzten Zeilen, `>>` fuegt sie an `errors.log` an (ohne zu loeschen).",
            },
          ],
        },

        redirect_stderr: {
          title: "2>",
          description: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          explanation: "Leitet die Fehlerausgabe (stderr) in eine Datei.",
          simpleExample: "command 2> fehler.txt",
          detail: "Sehr nützlich, um Fehlermeldungen zu isolieren.",
          complexExample: 'find / -name "*.conf" 2> /tmp/find_errors.log',
          complexExampleExplanation: [
            {
              line: 'find / -name "*.conf" 2> /tmp/find_errors.log',
              explanation:
                "find sucht ab dem Wurzelverzeichnis (/) rekursiv nach .conf-Dateien, 2> leitet Fehler (stderr) in /tmp/find_errors.log um (normale Ausgabe bleibt im Terminal)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `command 2> fehler.txt`?",
              options: [
                "Leitet stdout in fehler.txt",
                "Leitet stderr (Fehlerausgabe) in fehler.txt",
                "Löscht fehler.txt",
                "Kopiert fehler.txt",
              ],
              correctIndex: 1,
              explanation:
                "`2>` leitet stderr (Stream 2 = Fehlerausgabe) in die Datei um.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `2>` nützlich?",
              options: [
                "Weil es schneller ist",
                "Weil es Fehlermeldungen isoliert und von normaler Ausgabe trennt",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Fehlermeldungen werden isoliert – normale Ausgabe bleibt im Terminal, Fehler landen in der Datei.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `find / -name "*.conf" 2> /tmp/find_errors.log`?',
              options: [
                "Zeigt alle Fehler im Terminal",
                "Sucht nach .conf-Dateien, Fehler landen in /tmp/find_errors.log",
                "Löscht alle .conf-Dateien",
                "Kopiert alle .conf-Dateien",
              ],
              correctIndex: 1,
              explanation:
                "Sucht rekursiv nach .conf-Dateien, normale Ausgabe bleibt im Terminal, Fehler (z.B. Berechtigungsfehler) landen in der Logdatei.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Suche in `/root` nach `*.key` Dateien, leite aber nur die Fehlermeldungen in `find_errors.log` um.",
              correctCommand: "find /root -name '*.key' 2> find_errors.log",
              acceptedVariants: [
                "find /root -type f -name '*.key' 2> find_errors.log",
                "find /root -name '*.key' 2> find_errors.log",
              ],
              explanation:
                "`find /root` kann Berechtigungsfehler werfen; `2>` schickt stderr nach `find_errors.log`, stdout bleibt im Terminal.",
            },
          ],
        },

        whoami: {
          title: "whoami",
          description: "Zeigt den aktuellen Benutzer.",
          explanation: "Zeigt den aktuellen Benutzer.",
          simpleExample: "whoami → user",
          detail: "Wird oft in Scripts verwendet, um Berechtigungen zu prüfen.",
          complexExample:
            'echo "Dieses Script läuft als: $(whoami)" >> script.log',
          complexExampleExplanation: [
            {
              line: 'echo "Dieses Script läuft als: $(whoami)" >> script.log',
              explanation:
                "echo gibt Text aus, $(whoami) wird durch den aktuellen Benutzernamen ersetzt, >> hängt den Text an script.log an (für Logging/Debugging)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `whoami`?",
              options: [
                "Zeigt alle Benutzer",
                "Zeigt den aktuellen Benutzer",
                "Löscht Benutzer",
                "Erstellt Benutzer",
              ],
              correctIndex: 1,
              explanation:
                "`whoami` zeigt den Namen des aktuell angemeldeten Benutzers.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `whoami` oft in Scripts verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Berechtigungen zu prüfen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Scripts prüfen oft mit `whoami`, ob sie mit den richtigen Berechtigungen laufen.",
            },
            {
              level: "schwer",
              prompt:
                'Was macht `echo "Dieses Script läuft als: $(whoami)" >> script.log`?',
              options: [
                "Zeigt nur whoami",
                "Schreibt 'Dieses Script läuft als: [Benutzername]' in script.log",
                "Löscht script.log",
                "Kopiert script.log",
              ],
              correctIndex: 1,
              explanation:
                "`$(whoami)` wird durch den Benutzernamen ersetzt, dann wird der Text in script.log geschrieben.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Schreibe den aktuell eingeloggten Benutzer in `current_user.txt` (alles bestehende wird ersetzt).",
              correctCommand: "whoami > current_user.txt",
              acceptedVariants: [
                "whoami > current_user.txt",
                "whoami > ./current_user.txt",
              ],
              explanation:
                "`whoami` liefert den Benutzernamen, `>` leitet ihn in die Datei um und ueberschreibt sie.",
            },
          ],
        },

        chmod: {
          title: "chmod",
          description: "Ändert Dateirechte (read/write/execute).",
          explanation: "Ändert Dateirechte (read/write/execute).",
          simpleExample: "chmod +x script.sh",
          detail:
            "chmod 755 wird häufig für webserver-readable Scripts genutzt.",
          complexExample: "chmod u=rwx,go=rx meinprogramm",
          complexExampleExplanation: [
            {
              line: "chmod u=rwx,go=rx meinprogramm",
              explanation:
                "Setzt Rechte mit symbolischer Notation: u (user/Besitzer) = rwx (read/write/execute), go (group/others) = rx (read/execute), sehr präzise Kontrolle über Dateirechte",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod +x script.sh`?",
              options: [
                "Löscht script.sh",
                "Macht script.sh ausführbar",
                "Kopiert script.sh",
                "Zeigt script.sh an",
              ],
              correctIndex: 1,
              explanation:
                "`+x` fügt Ausführungsrechte hinzu – die Datei kann dann mit `./script.sh` ausgeführt werden.",
            },
            {
              level: "mittel",
              prompt: "Was bedeutet `chmod 755`?",
              options: [
                "Nur lesen",
                "Besitzer: rwx, Gruppe/Andere: rx (häufig für webserver-readable Scripts)",
                "Nur schreiben",
                "Keine Rechte",
              ],
              correctIndex: 1,
              explanation:
                "755 = Besitzer: read/write/execute (7), Gruppe/Andere: read/execute (5) – Standard für ausführbare Scripts.",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod u=rwx,go=rx meinprogramm`?",
              options: [
                "Setzt Rechte für alle gleich",
                "Setzt Besitzer (u): rwx, Gruppe/Andere (go): rx",
                "Löscht alle Rechte",
                "Kopiert die Datei",
              ],
              correctIndex: 1,
              explanation:
                "Symbolische Notation: u (user) = rwx, go (group/others) = rx – sehr präzise Kontrolle.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Setze die Rechte von `deploy.sh` auf 750 (Besitzer: rwx, Gruppe/Andere: rx).",
              correctCommand: "chmod 750 deploy.sh",
              acceptedVariants: [
                "chmod 750 deploy.sh",
                "chmod u=rwx,go=rx deploy.sh",
              ],
              explanation:
                "750 gibt dem Besitzer alle Rechte, Gruppe/Andere nur lesen+ausfuehren.",
            },
          ],
        },

        chmod_R: {
          title: "chmod -R",
          description: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          explanation: "Ändert Rechte rekursiv für Ordner + Unterordner.",
          simpleExample: "chmod -R 755 public/",
          detail: "Schnell sehr gefährlich, wenn im falschen Pfad ausgeführt.",
          complexExample: "chmod -R 700 ~/.ssh",
          complexExampleExplanation: [
            {
              line: "chmod -R 700 ~/.ssh",
              explanation:
                "Ändert Rechte rekursiv (-R) für .ssh und alle Inhalte, 700 bedeutet nur Besitzer hat alle Rechte (rwx), niemand sonst - perfekt für sensible Verzeichnisse wie SSH-Keys",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `chmod -R 755 public/`?",
              options: [
                "Ändert Rechte nur für public/",
                "Ändert Rechte rekursiv für public/ und alle Unterordner/Dateien",
                "Löscht public/",
                "Kopiert public/",
              ],
              correctIndex: 1,
              explanation:
                "`-R` (recursive) wendet die Rechteänderung auf den gesamten Verzeichnisbaum an.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `chmod -R` gefährlich?",
              options: [
                "Weil es langsam ist",
                "Weil es schnell sehr gefährlich ist, wenn im falschen Pfad ausgeführt",
                "Weil es nichts macht",
                "Weil es Dateien kopiert",
              ],
              correctIndex: 1,
              explanation:
                "Im falschen Pfad (z.B. `/` statt `./`) werden Rechte systemweit geändert – sehr gefährlich!",
            },
            {
              level: "schwer",
              prompt: "Was macht `chmod -R 700 ~/.ssh`?",
              options: [
                "Macht .ssh für alle lesbar",
                "Setzt .ssh und alle Inhalte auf 700 (nur Besitzer: rwx)",
                "Löscht .ssh",
                "Kopiert .ssh",
              ],
              correctIndex: 1,
              explanation:
                "700 = nur Besitzer hat alle Rechte (rwx), niemand sonst – perfekt für sensible Verzeichnisse wie .ssh.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Sichere `/opt/secure` rekursiv, so dass nur der Besitzer vollen Zugriff hat.",
              correctCommand: "chmod -R 700 /opt/secure",
              acceptedVariants: [
                "chmod -R 700 /opt/secure",
                "chmod 700 -R /opt/secure",
              ],
              explanation:
                "`-R` wirkt auf alle Unterobjekte, 700 erlaubt nur dem Besitzer lesen/schreiben/ausfuehren.",
            },
          ],
        },

        chown: {
          title: "chown",
          description: "Ändert den Besitzer einer Datei.",
          explanation: "Ändert den Besitzer einer Datei.",
          simpleExample: "sudo chown user file.txt",
          detail:
            "Die Kombination chown user:group file ändert Besitzer + Gruppe.",
          complexExample: "sudo chown www-data:www-data -R /var/www/site",
          complexExampleExplanation: [
            {
              line: "sudo chown www-data:www-data -R /var/www/site",
              explanation:
                "sudo gibt Root-Rechte, chown ändert Besitzer und Gruppe, www-data:www-data setzt beide auf www-data, -R rekursiv für den gesamten /var/www/site Baum (Standard für Web-Server)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chown user file.txt`?",
              options: [
                "Ändert die Rechte",
                "Ändert den Besitzer von file.txt zu 'user'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chown` ändert den Besitzer – benötigt meist `sudo`, da man normalerweise nicht Besitzer anderer Dateien ändern kann.",
            },
            {
              level: "mittel",
              prompt: "Wie änderst du Besitzer UND Gruppe?",
              options: [
                "chown user file",
                "chown user:group file",
                "chown user,group file",
                "chown user.group file",
              ],
              correctIndex: 1,
              explanation:
                "Mit `user:group` werden beide auf einmal geändert – z.B. `chown www-data:www-data file`.",
            },
            {
              level: "schwer",
              prompt:
                "Was macht `sudo chown www-data:www-data -R /var/www/site`?",
              options: [
                "Ändert nur die Rechte",
                "Ändert Besitzer und Gruppe rekursiv auf www-data für den gesamten /var/www/site Baum",
                "Löscht /var/www/site",
                "Kopiert /var/www/site",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird Besitzer und Gruppe auf www-data gesetzt – Standard für Web-Server-Verzeichnisse.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Uebergib den Besitz von `/opt/app` rekursiv an Nutzer `deploy` und Gruppe `deploy`.",
              correctCommand: "sudo chown -R deploy:deploy /opt/app",
              acceptedVariants: [
                "sudo chown -R deploy:deploy /opt/app",
                "chown -R deploy:deploy /opt/app",
              ],
              explanation:
                "`chown user:group -R` setzt Besitzer und Gruppe fuer den gesamten Baum.",
            },
          ],
        },

        chgrp: {
          title: "chgrp",
          description: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          explanation: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          simpleExample: "sudo chgrp staff file.txt",
          detail: "Wird oft verwendet, wenn mehrere User Zugriff benötigen.",
          complexExample: "sudo chgrp developers -R project/",
          complexExampleExplanation: [
            {
              line: "sudo chgrp developers -R project/",
              explanation:
                "sudo gibt Root-Rechte, chgrp ändert nur die Gruppe (nicht den Besitzer), developers ist der Gruppenname, -R rekursiv für den gesamten project/ Baum (alle Entwickler in dieser Gruppe haben Zugriff)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `sudo chgrp staff file.txt`?",
              options: [
                "Ändert den Besitzer",
                "Ändert nur die Gruppe von file.txt zu 'staff'",
                "Löscht file.txt",
                "Kopiert file.txt",
              ],
              correctIndex: 1,
              explanation:
                "`chgrp` ändert nur die Gruppe, nicht den Besitzer – nützlich für Gruppen-Zugriff.",
            },
            {
              level: "mittel",
              prompt: "Wann wird `chgrp` oft verwendet?",
              options: [
                "Wenn man Dateien löschen will",
                "Wenn mehrere User Zugriff benötigen",
                "Wenn man Dateien kopieren will",
                "Wenn man Dateien sortieren will",
              ],
              correctIndex: 1,
              explanation:
                "Wenn mehrere Benutzer Zugriff auf Dateien brauchen, setzt man sie in eine gemeinsame Gruppe.",
            },
            {
              level: "schwer",
              prompt: "Was macht `sudo chgrp developers -R project/`?",
              options: [
                "Ändert nur den Besitzer",
                "Ändert die Gruppe rekursiv auf 'developers' für den gesamten project/ Baum",
                "Löscht project/",
                "Kopiert project/",
              ],
              correctIndex: 1,
              explanation:
                "Rekursiv (`-R`) wird die Gruppe auf 'developers' gesetzt – alle Entwickler in dieser Gruppe haben dann Zugriff.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Setze fuer `logs/` und alle enthaltenen Dateien die Gruppe auf `devops`.",
              correctCommand: "sudo chgrp -R devops logs/",
              acceptedVariants: [
                "sudo chgrp -R devops logs/",
                "chgrp -R devops logs",
              ],
              explanation:
                "`chgrp -R` passt die Gruppe rekursiv an; wichtig fuer gemeinsame Schreibrechte.",
            },
          ],
        },

        touch: {
          title: "touch",
          description:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          explanation:
            "Erstellt eine leere Datei oder aktualisiert das Änderungsdatum.",
          simpleExample: "touch notes.txt",
          detail: "Wird oft genutzt, um Testdateien zu erzeugen.",
          complexExample: "touch $(date +backup_%F.txt)",
          complexExampleExplanation: [
            {
              line: "touch $(date +backup_%F.txt)",
              explanation:
                "touch erstellt eine leere Datei, $(date +backup_%F.txt) wird durch das aktuelle Datum im Format backup_YYYY-MM-DD.txt ersetzt (z.B. backup_2025-01-15.txt)",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `touch notes.txt`?",
              options: [
                "Löscht notes.txt",
                "Erstellt eine leere Datei notes.txt (oder aktualisiert das Datum, wenn sie existiert)",
                "Kopiert notes.txt",
                "Zeigt notes.txt an",
              ],
              correctIndex: 1,
              explanation:
                "`touch` erstellt eine leere Datei, wenn sie nicht existiert, oder aktualisiert das Änderungsdatum.",
            },
            {
              level: "mittel",
              prompt: "Wofür wird `touch` oft verwendet?",
              options: [
                "Um Dateien zu löschen",
                "Um Testdateien zu erzeugen",
                "Um Dateien zu kopieren",
                "Um Dateien zu sortieren",
              ],
              correctIndex: 1,
              explanation:
                "Schnell eine leere Datei erstellen – ideal für Tests oder als Platzhalter.",
            },
            {
              level: "schwer",
              prompt: "Was macht `touch $(date +backup_%F.txt)`?",
              options: [
                "Erstellt eine Datei mit dem aktuellen Datum im Namen",
                "Löscht alle Backup-Dateien",
                "Kopiert alle Backup-Dateien",
                "Zeigt alle Backup-Dateien",
              ],
              correctIndex: 0,
              explanation:
                "`$(date +%F)` wird durch das Datum (YYYY-MM-DD) ersetzt, dann wird eine Datei wie `backup_2025-01-15.txt` erstellt.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Lege im Ordner `backups/` eine leere Datei mit heutigem Datum im Namen an (z. B. `backup_2024-05-01.txt`).",
              correctCommand: 'touch "backups/backup_$(date +%F).txt"',
              acceptedVariants: [
                'touch "backups/backup_$(date +%F).txt"',
                "touch backups/backup_$(date +%F).txt",
              ],
              explanation:
                "`touch` erzeugt (oder aktualisiert) die Datei, `$(date +%F)` liefert das Datum im Format JJJJ-MM-TT.",
            },
          ],
        },

        head: {
          title: "head",
          description: "Zeigt die ersten Zeilen einer Datei.",
          explanation: "Zeigt die ersten Zeilen einer Datei.",
          simpleExample: "head file.txt",
          detail: "Immer 10 Zeilen, außer man nutzt -n.",
          complexExample: "head -n 3 error.log",
          complexExampleExplanation: [
            {
              line: "head -n 3 error.log",
              explanation:
                "head zeigt die ersten Zeilen einer Datei, -n 3 begrenzt die Ausgabe auf die ersten 3 Zeilen (nützlich um schnell den Anfang einer Logdatei zu sehen)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Ganze Datei anzeigen vs. nur Anfang</strong><br>
            <code>cat große_datei.txt</code><br>
            <code>head große_datei.txt</code><br>
            → cat zeigt alles, head zeigt nur die ersten 10 Zeilen<br><br>

            ✅ <strong>2. Nach etwas suchen, dann nur die ersten Treffer zeigen</strong><br>
            <code>grep "Error" log.txt</code><br>
            <code>grep "Error" log.txt | head -n 5</code><br>
            → grep findet alle Fehler, head zeigt nur die ersten 5<br><br>

            ✅ <strong>3. Datei sortieren und dann nur den Anfang zeigen</strong><br>
            <code>sort namen.txt</code><br>
            <code>sort namen.txt | head -n 10</code><br>
            → Sortiert die Namen, head zeigt nur die ersten 10 (alphabetisch erste)<br><br>

            ✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
            <code>head -n 20 data.txt</code><br>
            <code>head -n 20 data.txt | wc -l</code><br>
            → Zeigt die ersten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

            ✅ <strong>5. Mehrere Dateien zusammenfügen und nur Anfang zeigen</strong><br>
            <code>cat file1.txt file2.txt</code><br>
            <code>cat file1.txt file2.txt | head -n 15</code><br>
            → cat kombiniert beide Dateien, head zeigt nur die ersten 15 Zeilen
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `head file.txt`?",
              options: [
                "Zeigt die letzten Zeilen",
                "Zeigt die ersten 10 Zeilen",
                "Löscht die ersten Zeilen",
                "Kopiert die ersten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`head` zeigt standardmäßig die ersten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Wie zeigst du nur die ersten 3 Zeilen?",
              options: [
                "head -3 file.txt",
                "head -n 3 file.txt",
                "head --lines 3 file.txt",
                "Alle oben genannten funktionieren",
              ],
              correctIndex: 3,
              explanation:
                "Alle Varianten funktionieren: `-n 3`, `-3`, `--lines 3` – alle zeigen die ersten 3 Zeilen.",
            },
            {
              level: "schwer",
              prompt: "Was macht `head -n 3 error.log`?",
              options: [
                "Zeigt die letzten 3 Zeilen",
                "Zeigt die ersten 3 Zeilen von error.log",
                "Löscht die ersten 3 Zeilen",
                "Kopiert error.log",
              ],
              correctIndex: 1,
              explanation:
                "Zeigt nur die ersten 3 Zeilen – nützlich, um schnell den Anfang einer Logdatei zu sehen.",
            },

            {
              level: "schwer",
              type: "command",
              prompt: "Zeige die ersten 15 Zeilen von `/var/log/auth.log`.",
              correctCommand: "head -n 15 /var/log/auth.log",
              acceptedVariants: [
                "head -n 15 /var/log/auth.log",
                "head -15 /var/log/auth.log",
              ],
              explanation:
                "`head -n 15` begrenzt die Ausgabe auf die ersten 15 Zeilen der Datei.",
            },
          ],
        },

        tail: {
          title: "tail",
          description: "Zeigt die letzten Zeilen einer Datei.",
          explanation: "Zeigt die letzten Zeilen einer Datei.",
          simpleExample: "tail file.txt",
          detail: "Mit -f live-Logausgabe: extrem wichtig für Monitoring.",
          complexExample: "tail -f /var/log/syslog",
          complexExampleExplanation: [
            {
              line: "tail -f /var/log/syslog",
              explanation:
                "tail zeigt die letzten Zeilen, -f (follow) überwacht die Datei live und zeigt neue Zeilen automatisch an, sobald sie hinzugefügt werden (perfekt für Live-Log-Monitoring)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Ganze Datei vs. nur Ende anzeigen</strong><br>
            <code>cat log.txt</code><br>
            <code>tail log.txt</code><br>
            → cat zeigt alles, tail zeigt nur die letzten 10 Zeilen<br><br>

            ✅ <strong>2. Nach Fehlern suchen, dann nur die letzten Treffer zeigen</strong><br>
            <code>grep "Error" log.txt</code><br>
            <code>grep "Error" log.txt | tail -n 5</code><br>
            → grep findet alle Fehler, tail zeigt nur die letzten 5<br><br>

            ✅ <strong>3. Datei sortieren und dann das Ende zeigen</strong><br>
            <code>sort namen.txt</code><br>
            <code>sort namen.txt | tail -n 10</code><br>
            → Sortiert die Namen, tail zeigt die letzten 10 (alphabetisch letzte)<br><br>

            ✅ <strong>4. Letzte Zeilen zeigen und dann zählen</strong><br>
            <code>tail -n 20 data.txt</code><br>
            <code>tail -n 20 data.txt | wc -l</code><br>
            → Zeigt die letzten 20 Zeilen, wc -l zählt dass es genau 20 sind<br><br>

            ✅ <strong>5. Mehrere Dateien zusammenfügen und nur Ende zeigen</strong><br>
            <code>cat file1.txt file2.txt</code><br>
            <code>cat file1.txt file2.txt | tail -n 15</code><br>
            → cat kombiniert beide Dateien, tail zeigt nur die letzten 15 Zeilen
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tail file.txt`?",
              options: [
                "Zeigt die ersten Zeilen",
                "Zeigt die letzten 10 Zeilen",
                "Löscht die letzten Zeilen",
                "Kopiert die letzten Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`tail` zeigt standardmäßig die letzten 10 Zeilen einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Was ist besonders wichtig an `tail -f`?",
              options: [
                "Es ist schneller",
                "Live-Logausgabe: zeigt neue Zeilen in Echtzeit (extrem wichtig für Monitoring)",
                "Es zeigt mehr Zeilen",
                "Es löscht Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`-f` (follow) zeigt neue Zeilen live an, sobald sie zur Datei hinzugefügt werden – essentiell für Log-Monitoring.",
            },
            {
              level: "schwer",
              prompt: "Was macht `tail -f /var/log/syslog`?",
              options: [
                "Zeigt nur die letzten 10 Zeilen",
                "Zeigt die Logdatei live und aktualisiert sich automatisch bei neuen Einträgen",
                "Löscht die Logdatei",
                "Kopiert die Logdatei",
              ],
              correctIndex: 1,
              explanation:
                "Live-Monitoring: neue Log-Einträge erscheinen automatisch im Terminal – perfekt zum Debuggen.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zeige die letzten 50 Zeilen von `app.log` und beobachte die Datei weiter live.",
              correctCommand: "tail -n 50 -f app.log",
              acceptedVariants: [
                "tail -n 50 -f app.log",
                "tail -50 -f app.log",
              ],
              explanation:
                "`tail -n 50` startet mit den letzten Zeilen, `-f` folgt neuen Logeintraegen in Echtzeit.",
            },
          ],
        },

        wc_l: {
          title: "wc -l",
          description: "Zählt Zeilen in einer Datei oder Eingabe.",
          explanation: "Zählt Zeilen in einer Datei oder Eingabe.",
          simpleExample: "wc -l file.txt",
          detail: "Mit Piping mächtig: zählt Ergebnisse nach Filtern.",
          complexExample: "ls | wc -l",
          complexExampleExplanation: [
            {
              line: "ls | wc -l",
              explanation:
                "ls listet Dateien im aktuellen Verzeichnis auf, | leitet die Ausgabe an wc -l weiter, das die Anzahl der Zeilen (also Dateien/Ordner) zählt",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei anzeigen und dann Zeilen zählen</strong><br>
            <code>cat log.txt</code><br>
            <code>wc -l log.txt</code><br>
            → cat zeigt den Inhalt, wc -l zählt wie viele Zeilen es sind<br><br>

            ✅ <strong>2. Dateien auflisten und dann zählen</strong><br>
            <code>ls</code><br>
            <code>ls | wc -l</code><br>
            → ls zeigt Dateien, wc -l zählt wie viele Dateien/Ordner es sind<br><br>

            ✅ <strong>3. Nach etwas suchen und Treffer zählen</strong><br>
            <code>grep "Error" log.txt</code><br>
            <code>grep "Error" log.txt | wc -l</code><br>
            → Findet alle Fehler, wc -l zählt wie viele Treffer es gibt<br><br>

            ✅ <strong>4. Erste Zeilen zeigen und dann zählen</strong><br>
            <code>head -n 20 data.txt</code><br>
            <code>head -n 20 data.txt | wc -l</code><br>
            → Zeigt die ersten 20 Zeilen, wc -l bestätigt dass es genau 20 sind<br><br>

            ✅ <strong>5. Sortieren, Duplikate entfernen, dann zählen</strong><br>
            <code>sort namen.txt | uniq</code><br>
            <code>sort namen.txt | uniq | wc -l</code><br>
            → Sortiert und entfernt Duplikate, wc -l zählt wie viele eindeutige Namen es gibt
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -l file.txt`?",
              options: [
                "Zählt Wörter",
                "Zählt Zeilen",
                "Zählt Zeichen",
                "Löscht Zeilen",
              ],
              correctIndex: 1,
              explanation:
                "`wc -l` zählt die Anzahl der Zeilen in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Warum ist `wc -l` mit Piping mächtig?",
              options: [
                "Weil es schneller ist",
                "Weil es Ergebnisse nach Filtern zählen kann",
                "Weil es mehr zeigt",
                "Weil es Dateien löscht",
              ],
              correctIndex: 1,
              explanation:
                "Nach Filtern (z.B. `grep`, `find`) kann man mit `wc -l` schnell zählen, wie viele Treffer es gibt.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ls | wc -l`?",
              options: [
                "Zeigt alle Dateien",
                "Zählt die Anzahl der Dateien/Ordner im aktuellen Verzeichnis",
                "Löscht alle Dateien",
                "Kopiert alle Dateien",
              ],
              correctIndex: 1,
              explanation:
                "`ls` listet Dateien, `|` leitet an `wc -l` weiter, das die Anzahl der Zeilen (also Dateien) zählt.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zaehle, wie viele Shell-Skripte (`*.sh`) es unterhalb des aktuellen Verzeichnisses gibt.",
              correctCommand: "find . -type f -name '*.sh' | wc -l",
              acceptedVariants: [
                "find . -name '*.sh' -type f | wc -l",
                "find . -type f -name '*.sh' | wc -l",
              ],
              explanation:
                "`find` sammelt alle Skripte, `wc -l` zaehlt die Treffer.",
            },
          ],
        },

        wc_w: {
          title: "wc -w",
          description: "Zählt Wörter.",
          explanation: "Zählt Wörter.",
          simpleExample: "wc -w text.txt",
          detail: "Oft zusammen mit head/tail verwendet.",
          complexExample: "ifconfig | head -n 7 | wc -w",
          complexExampleExplanation: [
            {
              line: "ifconfig | head -n 7 | wc -w",
              explanation:
                "ifconfig zeigt Netzwerkinformationen, | leitet an head -n 7 weiter (zeigt nur die ersten 7 Zeilen), | leitet an wc -w weiter (zählt die Anzahl der Wörter in diesen Zeilen)",
            },
          ],
          additionalExamples: `
            ✅ <strong>1. Datei anzeigen und dann Wörter zählen</strong><br>
            <code>cat text.txt</code><br>
            <code>wc -w text.txt</code><br>
            → cat zeigt den Inhalt, wc -w zählt wie viele Wörter es sind<br><br>

            ✅ <strong>2. Erste Zeilen zeigen und dann Wörter zählen</strong><br>
            <code>head -n 10 log.txt</code><br>
            <code>head -n 10 log.txt | wc -w</code><br>
            → Zeigt die ersten 10 Zeilen, wc -w zählt die Wörter darin<br><br>

            ✅ <strong>3. Nach etwas suchen und dann Wörter zählen</strong><br>
            <code>grep "Error" log.txt</code><br>
            <code>grep "Error" log.txt | wc -w</code><br>
            → Findet alle Fehler-Zeilen, wc -w zählt die Wörter in den Treffern<br><br>

            ✅ <strong>4. Letzte Zeilen zeigen und dann Wörter zählen</strong><br>
            <code>tail -n 5 status.txt</code><br>
            <code>tail -n 5 status.txt | wc -w</code><br>
            → Zeigt die letzten 5 Zeilen, wc -w zählt die Wörter<br><br>

            ✅ <strong>5. Mehrere Dateien kombinieren und Wörter zählen</strong><br>
            <code>cat file1.txt file2.txt</code><br>
            <code>cat file1.txt file2.txt | wc -w</code><br>
            → Kombiniert beide Dateien, wc -w zählt alle Wörter zusammen
                      `,
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `wc -w text.txt`?",
              options: [
                "Zählt Zeilen",
                "Zählt Wörter",
                "Zählt Zeichen",
                "Löscht Wörter",
              ],
              correctIndex: 1,
              explanation:
                "`wc -w` zählt die Anzahl der Wörter in einer Datei.",
            },
            {
              level: "mittel",
              prompt: "Womit wird `wc -w` oft kombiniert?",
              options: ["Mit rm", "Mit head/tail", "Mit cp", "Mit mv"],
              correctIndex: 1,
              explanation:
                "Oft kombiniert mit `head` oder `tail`, um nur einen Teil der Datei zu analysieren.",
            },
            {
              level: "schwer",
              prompt: "Was macht `ifconfig | head -n 7 | wc -w`?",
              options: [
                "Zeigt ifconfig",
                "Zählt die Wörter in den ersten 7 Zeilen von ifconfig",
                "Löscht ifconfig",
                "Kopiert ifconfig",
              ],
              correctIndex: 1,
              explanation:
                "`ifconfig` Ausgabe → erste 7 Zeilen (`head -n 7`) → Wörter zählen (`wc -w`) – nützlich für schnelle Analyse.",
            },

            {
              level: "schwer",
              type: "command",
              prompt:
                "Zaehle die Woerter in `README.md` und schreibe die Zahl in `words.txt`.",
              correctCommand: "wc -w README.md > words.txt",
              acceptedVariants: [
                "wc -w README.md > words.txt",
                "cat README.md | wc -w > words.txt",
              ],
              explanation:
                "`wc -w` liefert die Wortanzahl, `>` leitet sie in `words.txt` um.",
            },
          ],
        },

        xargs: {
          title: "xargs",
          description: "Baut aus Eingabelisten Argumente fr einen Befehl.",
          explanation:
            "Liess stdin ein und ruft einen Befehl mit den gesammelten Argumenten auf.",
          simpleExample: "find . -name '*.log' -print0 | xargs -0 ls -lh",
          detail:
            "Mit -0 sicher fr Leerzeichen, -n begrenzt Pakete, -I{} setzt Platzhalter.",
          complexExample:
            'find . -type f -name "*.log" -print0 | xargs -0 -I{} cp "{}" backup/{}',
          complexExampleExplanation: [
            {
              line: 'find . -type f -name "*.log" -print0 | xargs -0 -I{} cp "{}" backup/{}',
              explanation:
                "find liefert Dateien nullterminiert, -0 liest sie sicher (Leerzeichen), -I{} ersetzt den Platzhalter und cp kopiert jedes File nach backup.",
            },
            {
              line: "xargs -n 5 -0 ls -lh",
              explanation:
                "-n 5 fhrt maximal 5 Argumente pro Aufruf aus (chunked Ausfhrung).",
            },
          ],
          flags: [
            {
              flag: "-0",
              description:
                "Null-terminierte Eingabe (find -print0, sicher bei Leerzeichen)",
            },
            {
              flag: "-n",
              description: "Anzahl der Argumente pro Aufruf begrenzen",
            },
            {
              flag: "-I{}",
              description: "Platzhalter fr jedes Element setzen",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Wofr nutzt du `xargs` typischerweise?",
              options: [
                "Es liest stdin und baut daraus Argumentlisten fr einen Befehl.",
                "Es ersetzt grep in Pipelines.",
                "Es erstellt tar-Archive automatisch.",
                "Es verschlsselt Eingaben per Default.",
              ],
              correctIndex: 0,
              explanation:
                "`xargs` nimmt die Eingabe einer Pipeline und h„ngt sie als Argumente an einen Befehl (z.B. rm, tar, ls).",
            },
            {
              level: "mittel",
              prompt:
                "Welche Variante kopiert alle .png Dateien (auch mit Leerzeichen) sicher ins Verzeichnis imgs/?",
              options: [
                'find . -name "*.png" | xargs cp -t imgs/',
                "find . -name *.png -exec cp {} imgs/ \\;",
                'find . -name "*.png" -print0 | xargs -0 cp -t imgs/',
                "ls *.png | cp -t imgs/",
              ],
              correctIndex: 2,
              explanation:
                "-print0 kombiniert mit -0 in xargs behandelt Leerzeichen korrekt; cp -t setzt das Zielverzeichnis.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Entferne alle `.tmp` Dateien unter `/tmp/cache` sicher (auch mit Leerzeichen) in einem Befehl.",
              correctCommand:
                'find /tmp/cache -type f -name "*.tmp" -print0 | xargs -0 rm --',
              acceptedVariants: [
                'find /tmp/cache -type f -name "*.tmp" -print0 | xargs -0 rm --',
                'find /tmp/cache -type f -name "*.tmp" -print0 | xargs -0 -r rm --',
              ],
              explanation:
                "find liefert Null-terminierte Pfade, -0 verarbeitet sie sicher und rm -- schtzt vor Optionen in Dateinamen.",
            },
          ],
        },

        tee: {
          title: "tee",
          description: "Spiegelt eine Pipeline-Ausgabe in Dateien und stdout.",
          explanation:
            "Schreibt stdin in eine oder mehrere Dateien und reicht weiter.",
          simpleExample: 'echo "OK" | tee status.log',
          detail: "Ohne -a wird berschrieben, mit -a angeh„ngt.",
          complexExample:
            "ping -c 3 example.com | tee -a logs/ping.log | grep time",
          complexExampleExplanation: [
            {
              line: "ping -c 3 example.com | tee -a logs/ping.log | grep time",
              explanation:
                "tee h„ngt die Ausgabe an logs/ping.log an und leitet sie weiter zu grep, damit du Zeiten direkt siehst.",
            },
          ],
          flags: [
            { flag: "-a", description: "h„ngt an bestehende Datei an" },
            { flag: "-i", description: "ignoriert Interrupt-Signale" },
          ],
          questions: [
            {
              level: "leicht",
              prompt: "Was macht `tee file.txt` in einer Pipeline?",
              options: [
                "Leitet die Ausgabe nur an stderr weiter.",
                "Spaltet die Ausgabe: auf Bildschirm und in file.txt.",
                "Stoppt die Pipeline nach dem Schreiben.",
                "Komprimiert die Ausgabe automatisch.",
              ],
              correctIndex: 1,
              explanation:
                "`tee` dupliziert stdin: schreibt in file.txt und gibt die Ausgabe weiter/aus.",
            },
            {
              level: "mittel",
              prompt:
                "Wie h„ngst du die Ausgabe von `uptime` an `logs/uptime.log` an und siehst sie trotzdem?",
              options: [
                "uptime >> logs/uptime.log",
                "uptime | tee -a logs/uptime.log",
                "uptime > logs/uptime.log",
                "uptime | tee logs/uptime.log && clear",
              ],
              correctIndex: 1,
              explanation:
                "`tee -a` h„ngt an, zeigt die Zeile an und gibt sie an Folgekommandos weiter.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Zeige stdout+stderr von `sudo systemctl status ssh` an und schreibe sie gleichzeitig (anh„ngen) in `ssh-status.log`.",
              correctCommand:
                "sudo systemctl status ssh |& tee -a ssh-status.log",
              acceptedVariants: [
                "sudo systemctl status ssh |& tee -a ssh-status.log",
                "sudo systemctl status ssh 2>&1 | tee -a ssh-status.log",
              ],
              explanation:
                "`|&` (oder 2>&1) kombiniert stdout+stderr, tee -a schreibt und zeigt weiter.",
            },
          ],
        },

        tar: {
          title: "tar",
          description: "Packt oder entpackt Dateien zu Archiven.",
          explanation:
            "Mit -c/-x erstellst oder entpackst, -z komprimiert mit gzip.",
          simpleExample: "tar -czf backup.tar.gz project/",
          detail:
            "Mit -t Inhalt anzeigen, mit -C entpacken in ein Zielverzeichnis.",
          complexExample:
            "tar -czf logs-$(date +%F).tar.gz /var/log --exclude='*.gz'",
          complexExampleExplanation: [
            {
              line: "tar -czf logs-$(date +%F).tar.gz /var/log --exclude='*.gz'",
              explanation:
                "Erstellt ein komprimiertes Archiv, l„sst vorhandene .gz aus und nutzt das aktuelle Datum im Dateinamen.",
            },
          ],
          flags: [
            { flag: "-c", description: "erstellt ein Archiv" },
            { flag: "-x", description: "entpackt ein Archiv" },
            { flag: "-z", description: "gzip-Kompression aktivieren" },
            { flag: "-f", description: "Dateiname des Archivs setzen" },
            { flag: "-C", description: "in Zielverzeichnis arbeiten" },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welcher Befehl erstellt ein gzip-komprimiertes Archiv von `docs/`?",
              options: [
                "tar -czf docs.tar.gz docs/",
                "tar -xf docs.tar.gz docs/",
                "tar -tvf docs.tar.gz docs/",
                "tar -rzf docs.tar.gz docs/",
              ],
              correctIndex: 0,
              explanation:
                "-c erstellt, -z komprimiert, -f setzt den Archivnamen.",
            },
            {
              level: "mittel",
              prompt: "Wie entpackst du `backup.tar.gz` nach `/tmp/restore`?",
              options: [
                "tar -xzf backup.tar.gz -C /tmp/restore",
                "tar -czf backup.tar.gz -C /tmp/restore",
                "tar -tvf backup.tar.gz -C /tmp/restore",
                "tar backup.tar.gz /tmp/restore",
              ],
              correctIndex: 0,
              explanation:
                "`-x` entpackt, `-z` fr gzip, `-C` wechselt ins Zielverzeichnis vor dem Extrahieren.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Packe `/etc/nginx` in `backup/nginx.tar.gz`, bewahre Rechte und zeige den Fortschritt.",
              correctCommand: "tar -czpvf backup/nginx.tar.gz /etc/nginx",
              acceptedVariants: [
                "tar -czpvf backup/nginx.tar.gz /etc/nginx",
                "tar -czvf backup/nginx.tar.gz /etc/nginx --same-permissions",
              ],
              explanation:
                "-c erstellt, -z komprimiert, -p/-v behalten Rechte und zeigen Fortschritt, -f setzt den Zielarchivnamen.",
            },
          ],
        },
        segment5: {
          title: "Masterquiz: Erweiterte Techniken",
          scenario:
            "Du baust ein kleines Deploy-Script: Es soll erstellt, ausfhrbar gemacht und mit sauberer Log-Trennung gestartet werden, ohne Logs zu berschreiben.",
          question:
            "Welche Sequenz erstellt ein Script, macht es ausfhrbar und fhrt es so aus, dass stdout an `deploy.log` angeh„ngt wird und Fehler separat in `deploy.err` landen?",
          options: [
            "nano deploy.sh && chmod +x deploy.sh && ./deploy.sh >> logs/deploy.log 2>> logs/deploy.err",
            "nano deploy.sh && ./deploy.sh > logs/deploy.log 2>&1",
            "chmod +x deploy.sh && ./deploy.sh > logs/deploy.log",
            "cat deploy.sh | bash >> logs/deploy.log",
          ],
          correctIndex: 0,
          explanation:
            "`nano` zum Schreiben, `chmod +x` macht ausfhrbar, `>>` h„ngt stdout an und `2>>` sammelt Fehler separat.",
        },
        segment6: {
          title: "Masterquiz: Fortgeschrittene Workflows",
          scenario:
            "Ein Log-Archiv soll t„glich gebaut werden: alle `.log` Dateien unter /var/log mssen robust (Leerzeichen-sicher) ins Archiv, und die Liste der archivierten Dateien soll mitgeschrieben werden.",
          question:
            "Welche Sequenz sammelt die Dateien sicher und baut ein Archiv `backups/logs-$(date +%F).tar.gz`, wobei die Dateiliste parallel in `/tmp/logs.list` landet?",
          options: [
            'find /var/log -type f -name "*.log" -print0 | tee /tmp/logs.list | xargs -0 tar -czf backups/logs-$(date +%F).tar.gz',
            'find /var/log -name "*.log" > /tmp/logs.list && tar -czf backups/logs-$(date +%F).tar.gz --files-from=/tmp/logs.list',
            "ls /var/log/*.log | tee /tmp/logs.list | tar -czf backups/logs-$(date +%F).tar.gz",
            "tar -czf backups/logs-$(date +%F).tar.gz /var/log/*.log",
          ],
          correctIndex: 0,
          explanation:
            "-print0/-0 halten Leerzeichen sicher, tee schreibt die Liste mit, xargs baut einen einzigen tar-Aufruf mit allen Dateien.",
        },

        flags_overview: {
          title: "Flags-Übersicht",
          description:
            "Komplette Übersicht aller Flags aus allen Kacheln mit Erklärungen und Beispielen.",
          explanation:
            "Diese Übersicht sammelt alle wichtigen Flags, die in den verschiedenen Quiz-Kacheln behandelt werden.",
          simpleExample: "Eine Referenz für alle häufig genutzten Flags.",
          detail:
            "Organisiert nach Befehlen, mit Erklärungen, Nützlichkeit und Beispielen.",
          flags: [
            // Navigation & Verzeichnisse
            {
              flag: "pwd -P",
              command: "pwd",
              description: "zeigt den physischen Pfad ohne Symlinks",
              utility: "mittel",
              risk: "niedrig",
              example: "pwd -P > current_path.log",
            },
            {
              flag: "cd (ohne Argument)",
              command: "cd",
              description: "wechselt ins Home-Verzeichnis",
              utility: "hoch",
              risk: "niedrig",
              example: "cd",
            },
            {
              flag: "cd -",
              command: "cd",
              description: "wechselt ins vorherige Verzeichnis (Toggle)",
              utility: "hoch",
              risk: "niedrig",
              example: "cd /var/log && cd -",
            },
            {
              flag: "cd ..",
              command: "cd",
              description: "Parent-Verzeichnis (eine Ebene nach oben)",
              utility: "hoch",
              risk: "niedrig",
              example: "cd ..",
            },
            {
              flag: "cd ~user",
              command: "cd",
              description: "ins Home von user",
              utility: "mittel",
              risk: "niedrig",
              example: "cd ~root",
            },

            // ls Flags
            {
              flag: "ls -l",
              command: "ls",
              description: "lange Ausgabe mit Rechten und Besitzer",
              utility: "hoch",
              risk: "niedrig",
              example: "ls -l /var/log",
            },
            {
              flag: "ls -a",
              command: "ls",
              description: "zeigt versteckte Dateien und ./.",
              utility: "hoch",
              risk: "niedrig",
              example: "ls -a ~",
            },
            {
              flag: "ls -h",
              command: "ls",
              description: "menschlich lesbare Größen (mit -l)",
              utility: "hoch",
              risk: "niedrig",
              example: "ls -lh",
            },
            {
              flag: "ls -R",
              command: "ls",
              description: "rekursives Auflisten aller Unterverzeichnisse",
              utility: "mittel",
              risk: "niedrig",
              example: "ls -R project/",
            },
            {
              flag: "ls -la",
              command: "ls",
              description: "Details + versteckte Dateien (Kombination)",
              utility: "sehr hoch",
              risk: "niedrig",
              example: "ls -la ~/.ssh",
            },
            {
              flag: "ls -aR",
              command: "ls",
              description: "rekursiv + versteckte Dateien",
              utility: "mittel",
              risk: "niedrig",
              example: "ls -aR ~",
            },

            // grep Flags
            {
              flag: "grep -n",
              command: "grep",
              description: "zeigt Zeilennummern",
              utility: "hoch",
              risk: "niedrig",
              example: 'grep -n "ERROR" log.txt',
            },
            {
              flag: "grep -i",
              command: "grep",
              description: "Groß-/Kleinschreibung ignorieren",
              utility: "hoch",
              risk: "niedrig",
              example: 'grep -i "error" log.txt',
            },
            {
              flag: "grep -r",
              command: "grep",
              description: "rekursiv in Verzeichnissen suchen",
              utility: "hoch",
              risk: "niedrig",
              example: 'grep -r "TODO" .',
            },
            {
              flag: "grep --include",
              command: "grep",
              description: "filtert Dateien nach Pattern",
              utility: "hoch",
              risk: "niedrig",
              example: 'grep -r --include="*.log" "error" .',
            },

            // find Flags
            {
              flag: "find -name",
              command: "find",
              description: "Pfad-Pattern (mit Anführungszeichen)",
              utility: "sehr hoch",
              risk: "mittel",
              example: 'find . -name "*.txt"',
            },
            {
              flag: "find -type f",
              command: "find",
              description: "nur Dateien (d für Verzeichnisse)",
              utility: "sehr hoch",
              risk: "niedrig",
              example: "find . -type f -name '*.log'",
            },
            {
              flag: "find -type d",
              command: "find",
              description: "nur Verzeichnisse",
              utility: "hoch",
              risk: "niedrig",
              example: "find . -type d",
            },
            {
              flag: "find -maxdepth",
              command: "find",
              description: "Tiefe begrenzen, um Rauschen zu vermeiden",
              utility: "hoch",
              risk: "niedrig",
              example: "find . -maxdepth 2 -type f",
            },
            {
              flag: "find -exec",
              command: "find",
              description: "führt Befehl für jedes Ergebnis aus",
              utility: "hoch",
              risk: "hoch",
              example: 'find . -name "*.tmp" -exec rm {} \\;',
            },

            // mkdir Flags
            {
              flag: "mkdir -p",
              command: "mkdir",
              description: "erstellt fehlende Zwischenverzeichnisse (parents)",
              utility: "sehr hoch",
              risk: "niedrig",
              example: "mkdir -p projects/2025/january",
            },

            // cp Flags
            {
              flag: "cp -r / -R",
              command: "cp",
              description: "rekursives Kopieren von Verzeichnissen",
              utility: "sehr hoch",
              risk: "mittel",
              example: "cp -r source/ dest/",
            },
            {
              flag: "cp -a",
              command: "cp",
              description: "archiv-Modus (kopiert Rechte, Links, etc.)",
              utility: "hoch",
              risk: "niedrig",
              example: "cp -a source/ dest/",
            },
            {
              flag: "cp -i",
              command: "cp",
              description: "interaktiv (fragt vor Überschreiben)",
              utility: "hoch",
              risk: "niedrig",
              example: "cp -i file.txt backup/",
            },
            {
              flag: "cp -u",
              command: "cp",
              description: "nur neuere Dateien kopieren (update)",
              utility: "mittel",
              risk: "niedrig",
              example: "cp -u source/ dest/",
            },

            // rm Flags
            {
              flag: "rm -r / -R",
              command: "rm",
              description: "rekursives Löschen von Verzeichnissen",
              utility: "hoch",
              risk: "sehr hoch",
              example: "rm -r temp/",
            },
            {
              flag: "rm -f",
              command: "rm",
              description: "force (ohne Nachfrage) - GEFÄHRLICH",
              utility: "mittel",
              risk: "sehr hoch",
              example: "rm -rf temp/ # Vorsicht!",
            },
            {
              flag: "rm -i",
              command: "rm",
              description: "interaktiv (mit Nachfrage) - EMPFOHLEN",
              utility: "hoch",
              risk: "niedrig",
              example: "rm -i *.tmp",
            },

            // sort Flags
            {
              flag: "sort -n",
              command: "sort",
              description: "numerisches Sortieren (2 vor 10)",
              utility: "hoch",
              risk: "niedrig",
              example: "sort -n zahlen.txt",
            },
            {
              flag: "sort -r",
              command: "sort",
              description: "reverse (absteigend)",
              utility: "hoch",
              risk: "niedrig",
              example: "sort -r namen.txt",
            },
            {
              flag: "sort -k",
              command: "sort",
              description: "Sortierung nach Spalte",
              utility: "hoch",
              risk: "niedrig",
              example: "sort -n -k2 data.txt",
            },

            // uniq Flags
            {
              flag: "uniq -c",
              command: "uniq",
              description: "zählt Vorkommen jeder Zeile",
              utility: "hoch",
              risk: "niedrig",
              example: "sort file.txt | uniq -c",
            },

            // tree Flags
            {
              flag: "tree -d",
              command: "tree",
              description: "zeigt nur Verzeichnisse (directories)",
              utility: "mittel",
              risk: "niedrig",
              example: "tree -d project/",
            },
            {
              flag: "tree -L",
              command: "tree",
              description: "begrenzt die Tiefe (Level)",
              utility: "hoch",
              risk: "niedrig",
              example: "tree -L 3",
            },

            // chmod Flags
            {
              flag: "chmod -R",
              command: "chmod",
              description: "rekursiv (auf alle Unterverzeichnisse)",
              utility: "hoch",
              risk: "hoch",
              example: "chmod -R 755 scripts/",
            },

            // chown Flags
            {
              flag: "chown -R",
              command: "chown",
              description: "rekursiv (auf alle Unterverzeichnisse)",
              utility: "hoch",
              risk: "hoch",
              example: "chown -R user:group dir/",
            },

            // chgrp Flags
            {
              flag: "chgrp -R",
              command: "chgrp",
              description: "rekursiv Gruppe setzen",
              utility: "mittel",
              risk: "hoch",
              example: "chgrp -R www-data /var/www",
            },

            // touch Flags
            {
              flag: "touch -t",
              command: "touch",
              description: "setzt Zeitstempel manuell",
              utility: "niedrig",
              risk: "niedrig",
              example: "touch -t 202401011200 file.txt",
            },

            // head/tail Flags
            {
              flag: "head -n",
              command: "head",
              description: "zeigt nur erste N Zeilen",
              utility: "hoch",
              risk: "niedrig",
              example: "head -n 10 file.txt",
            },
            {
              flag: "tail -n",
              command: "tail",
              description: "zeigt nur letzte N Zeilen",
              utility: "hoch",
              risk: "niedrig",
              example: "tail -n 50 log.txt",
            },
            {
              flag: "tail -f",
              command: "tail",
              description: "folgt Datei in Echtzeit (follow)",
              utility: "hoch",
              risk: "niedrig",
              example: "tail -f app.log",
            },

            // wc Flags
            {
              flag: "wc -l",
              command: "wc",
              description: "zählt Zeilen",
              utility: "hoch",
              risk: "niedrig",
              example: "wc -l file.txt",
            },
            {
              flag: "wc -w",
              command: "wc",
              description: "zählt Wörter",
              utility: "mittel",
              risk: "niedrig",
              example: "wc -w file.txt",
            },
            {
              flag: "wc -c",
              command: "wc",
              description: "zählt Zeichen",
              utility: "niedrig",
              risk: "niedrig",
              example: "wc -c file.txt",
            },

            // xargs Flags
            {
              flag: "xargs -0",
              command: "xargs",
              description: "Null-terminierte Eingabe (find -print0)",
              utility: "hoch",
              risk: "mittel",
              example: "find . -print0 | xargs -0 rm",
            },
            {
              flag: "xargs -n",
              command: "xargs",
              description: "Anzahl der Argumente pro Aufruf begrenzen",
              utility: "mittel",
              risk: "niedrig",
              example: "echo '1 2 3' | xargs -n 1",
            },
            {
              flag: "xargs -I{}",
              command: "xargs",
              description: "Platzhalter für jedes Element setzen",
              utility: "mittel",
              risk: "niedrig",
              example: 'find . -name "*.txt" | xargs -I{} mv {} backup/',
            },

            // tee Flags
            {
              flag: "tee -a",
              command: "tee",
              description: "hängt an bestehende Datei an",
              utility: "hoch",
              risk: "niedrig",
              example: "command | tee -a log.txt",
            },
            {
              flag: "tee -i",
              command: "tee",
              description: "ignoriert Interrupt-Signale",
              utility: "niedrig",
              risk: "niedrig",
              example: "command | tee -i output.txt",
            },

            // tar Flags
            {
              flag: "tar -c",
              command: "tar",
              description: "erstellt ein Archiv",
              utility: "hoch",
              risk: "mittel",
              example: "tar -czf archive.tar.gz files/",
            },
            {
              flag: "tar -x",
              command: "tar",
              description: "entpackt ein Archiv",
              utility: "hoch",
              risk: "mittel",
              example: "tar -xzf archive.tar.gz",
            },
            {
              flag: "tar -z",
              command: "tar",
              description: "komprimiert/dekomprimiert mit gzip",
              utility: "hoch",
              risk: "niedrig",
              example: "tar -czf archive.tar.gz files/",
            },
            {
              flag: "tar -f",
              command: "tar",
              description: "gibt Archiv-Dateinamen an",
              utility: "sehr hoch",
              risk: "niedrig",
              example: "tar -czf archive.tar.gz files/",
            },
            {
              flag: "tar -v",
              command: "tar",
              description: "verbose (zeigt Details)",
              utility: "mittel",
              risk: "niedrig",
              example: "tar -czvf archive.tar.gz files/",
            },

            // Umleitung & Pipes
            {
              flag: ">",
              description: "überschreibt Datei (stdout)",
              utility: "sehr hoch",
              risk: "hoch",
              example: "ls > files.txt",
            },
            {
              flag: ">>",
              description: "hängt an Datei an (stdout)",
              utility: "sehr hoch",
              risk: "niedrig",
              example: 'echo "Neue Zeile" >> log.txt',
            },
            {
              flag: "2>",
              description: "leitet stderr um",
              utility: "hoch",
              risk: "niedrig",
              example: "command 2> error.log",
            },
            {
              flag: "2>&1",
              description: "leitet stderr auf stdout",
              utility: "hoch",
              risk: "niedrig",
              example: "command > all.log 2>&1",
            },
            {
              flag: "|",
              description: "Pipe - leitet stdout als stdin weiter",
              utility: "sehr hoch",
              risk: "niedrig",
              example: "ls | grep '.txt'",
            },
            {
              flag: "|&",
              description: "Pipe stdout+stderr",
              utility: "hoch",
              risk: "niedrig",
              example: "command |& tee log.txt",
            },
          ],
          questions: [
            {
              level: "leicht",
              prompt:
                "Welches Flag zeigt bei `ls` zusätzlich versteckte Dateien an?",
              options: ["`-l`", "`-a`", "`-h`", "`-R`"],
              correctIndex: 1,
              explanation:
                "`ls -a` zeigt alle Dateien inklusive versteckter Dateien, die mit einem Punkt beginnen.",
            },
            {
              level: "mittel",
              prompt:
                "Du musst ein verschachteltes Verzeichnis erstellen, auch wenn Zwischenverzeichnisse fehlen. Welches Flag benötigst du?",
              options: ["`mkdir -v`", "`mkdir -p`", "`mkdir -r`", "`mkdir -f`"],
              correctIndex: 1,
              explanation:
                "`mkdir -p` erstellt alle fehlenden Zwischenverzeichnisse automatisch.",
            },
            {
              level: "schwer",
              type: "command",
              prompt:
                "Du musst alle `.log`-Dateien rekursiv finden und sicher löschen (auch bei Leerzeichen im Dateinamen). Schreibe einen Befehl mit den passenden Flags.",
              correctCommand:
                'find . -type f -name "*.log" -print0 | xargs -0 rm',
              acceptedVariants: [
                'find . -type f -name "*.log" -print0 | xargs -0 rm',
                "find . -type f -name '*.log' -print0 | xargs -0 rm",
              ],
              explanation:
                "`find ... -print0` gibt null-terminierte Ausgabe, `xargs -0` verarbeitet diese sicher auch bei Leerzeichen in Dateinamen.",
            },
          ],
        },
      };

      const commandMeta = {
        ls: {
          title: "ls",
          summary:
            "Listet Dateien und Verzeichnisse – nutze passende Flags für Details oder versteckte Einträge.",
          flags: [
            {
              flag: "-l",
              description: "lange Ausgabe mit Rechten und Besitzer",
            },
            { flag: "-a", description: "zeigt versteckte Dateien und ./." },
            { flag: "-h", description: "menschlich lesbare Größen (mit -l)" },
          ],
          pitfalls: [
            "Falscher Pfad (z. B. ls log statt ls logs) führt zu 'No such file or directory'.",
            "Versteckte Dateien fehlen ohne -a (wichtig bei .env, .git, .ssh).",
          ],
          examples: [
            {
              command: "ls -lah /var/log",
              note: "Alle Logfiles mit Rechten und Größen – ideal für Fehlersuche.",
            },
            {
              command: "ls -lt ~/Downloads | head",
              note: "Neueste Downloads zuerst anzeigen (Zeitstempel).",
            },
          ],
          quizId: "ls",
        },
        cd: {
          title: "cd",
          summary:
            "Wechselt das Arbeitsverzeichnis sicher, inkl. Rücksprung mit OLDPWD.",
          flags: [
            { flag: "-", description: "springt ins vorherige Verzeichnis" },
          ],
          pitfalls: [
            "Leerzeichen im Pfad ohne Anführungszeichen verursachen 'No such file or directory'.",
            "Relativer Pfad aus falschem Startverzeichnis führt an unerwartete Orte.",
          ],
          examples: [
            {
              command: 'cd "/var/www/html" && ls',
              note: "Sichere Navigation in Webroot mit Anführungszeichen.",
            },
            {
              command: 'OLDPWD=$(pwd); cd /tmp && do-something; cd "$OLDPWD"',
              note: "Zurückspringen nach temporärer Aktion.",
            },
          ],
          quizId: "cd",
        },
        grep: {
          title: "grep",
          summary:
            "Filtert Text nach Mustern – ideal mit Zeilennummern und rekursiver Suche.",
          flags: [
            { flag: "-n", description: "zeigt Zeilennummern" },
            { flag: "-i", description: "Groß-/Kleinschreibung ignorieren" },
            { flag: "-r", description: "rekursiv in Verzeichnissen suchen" },
          ],
          pitfalls: [
            "Shell interpretiert Sonderzeichen (z. B. *) ohne Anführungszeichen.",
            "Ohne --include kann rekursive Suche viel Rauschen produzieren.",
          ],
          examples: [
            {
              command: 'grep -n "ERROR" /var/log/syslog',
              note: "Zeigt Fehlerzeilen mit Position – schnell für Troubleshooting.",
            },
            {
              command: 'grep -ri --include="*.conf" "Listen" /etc/apache2',
              note: "Nur relevante Config-Dateien durchsuchen.",
            },
          ],
          quizId: "grep",
        },
        find: {
          title: "find",
          summary:
            "Durchsucht Verzeichnisse rekursiv nach Namen, Typen oder Größe.",
          flags: [
            {
              flag: "-name",
              description: "Pfad-Pattern (mit Anführungszeichen)",
            },
            {
              flag: "-type f",
              description: "nur Dateien (d für Verzeichnisse)",
            },
            {
              flag: "-maxdepth",
              description: "Tiefe begrenzen, um Rauschen zu vermeiden",
            },
          ],
          pitfalls: [
            "-name ohne Anführungszeichen lässt die Shell das Pattern expandieren.",
            '-exec ohne "{}" oder fehlendes ";" führt zu Fehlern.',
          ],
          examples: [
            {
              command: 'find . -maxdepth 2 -type f -name "*.log"',
              note: "Nur Logfiles in den ersten zwei Ebenen finden.",
            },
            {
              command:
                'find /var/www -type f -name "*.php" -exec ls -lh {} \\;',
              note: "Gefundene Dateien direkt inspizieren.",
            },
          ],
          quizId: "find_name",
        },
        chmod: {
          title: "chmod",
          summary:
            "Setzt Rechte numerisch oder symbolisch – mit Bedacht auf Sicherheit.",
          flags: [
            { flag: "-R", description: "rekursiv auf Unterordner anwenden" },
            { flag: "+x", description: "Ausführungsbit setzen (symbolisch)" },
          ],
          pitfalls: [
            "777 unüberlegt gesetzt macht Dateien weltweit beschreibbar.",
            "Rechte rekursiv (-R) auf sensible Verzeichnisse kann Services brechen.",
          ],
          examples: [
            {
              command: "chmod 644 ~/.ssh/config",
              note: "Lesbare, aber nicht ausführbare Config.",
            },
            {
              command: "chmod -R 755 /var/www/html",
              note: "Standard-Webrechte für Ordner & Dateien (Owner behält Schreiben).",
            },
          ],
          quizId: "chmod",
        },
        chown: {
          title: "chown",
          summary: "Ändert Besitzer und Gruppe – oft mit sudo nötig.",
          flags: [
            {
              flag: "user:group",
              description: "Besitzer und Gruppe in einem Schritt",
            },
            { flag: "-R", description: "rekursiv anwenden" },
          ],
          pitfalls: [
            "Ohne sudo: Operation not permitted.",
            "Rekursive Änderungen auf /etc oder /usr können Systeme unbrauchbar machen.",
          ],
          examples: [
            {
              command: "sudo chown -R www-data:www-data /var/www/html",
              note: "Webserver-Besitz sicher auf Inhalte anwenden.",
            },
            {
              command: "sudo chown $USER:$USER ~/Downloads/report.txt",
              note: "Dateien nach Kopie mit Root-Rechten zurücksetzen.",
            },
          ],
          quizId: "chown",
        },
        touch: {
          title: "touch",
          summary: "Erstellt leere Dateien oder aktualisiert Zeitstempel.",
          flags: [
            { flag: "-t", description: "Zeitstempel manuell setzen" },
            {
              flag: "-a/-m",
              description: "nur Access oder Modified Time ändern",
            },
          ],
          pitfalls: [
            "Pfadverzeichnisse müssen existieren (vorher mkdir -p).",
            "Ruft Fehlermeldung auf read-only Filesystemen hervor.",
          ],
          examples: [
            { command: "touch notes.txt", note: "Schnell eine Datei anlegen." },
            {
              command: "touch -t 202401011200 backup.tar",
              note: "Zeitstempel für Dokumentation setzen.",
            },
          ],
          quizId: "touch",
        },
        head: {
          title: "head",
          summary:
            "Zeigt die ersten Zeilen einer Datei – ideal für Log-Quickchecks.",
          flags: [{ flag: "-n", description: "Anzahl Zeilen steuern" }],
          pitfalls: [
            "Ohne -n zu wenig/zu viele Zeilen, besonders bei großen Dateien.",
            "Berechtigungen verhindern Zugriff auf Systemlogs (sudo nutzen).",
          ],
          examples: [
            {
              command: "head -n 20 /var/log/auth.log",
              note: "Schneller Blick in Login-Events.",
            },
            {
              command: "grep -n ERROR app.log | head -n 5",
              note: "Die ersten fünf Fehlerstellen herausfiltern.",
            },
          ],
          quizId: "head",
        },
        tail: {
          title: "tail",
          summary:
            "Zeigt das Ende einer Datei, mit -f perfekt fürs Live-Monitoring.",
          flags: [
            { flag: "-f", description: "Folgt neuen Zeilen (follow)" },
            { flag: "-n", description: "Startzeilen vom Ende definieren" },
          ],
          pitfalls: [
            "Ohne sudo bei root-Logs Zugriff verweigert.",
            "Bei rotierenden Logs (logrotate) springt -f ggf. auf alte Datei, -F nutzen.",
          ],
          examples: [
            {
              command: "sudo tail -f /var/log/syslog",
              note: "Live-Ansicht der Systemmeldungen.",
            },
            {
              command: "tail -n 50 application.log | grep -i error",
              note: "Letzte Fehler in Applogs filtern.",
            },
          ],
          quizId: "tail",
        },
        "wc -l": {
          title: "wc -l",
          summary: "Zählt Zeilen – ideal kombiniert mit Pipes oder find.",
          flags: [
            { flag: "-l", description: "zählt Zeilen" },
            { flag: "-w", description: "zählt Wörter" },
            { flag: "-c", description: "zählt Bytes" },
            {
              flag: "--files0-from",
              description: "Dateiliste Null-terminiert verarbeiten",
            },
          ],
          pitfalls: [
            "Leerzeichen in Dateinamen ohne korrekte Quoting führen zu falschen Zählungen.",
            "Mit cat *.log | wc -l wird auch der Dateiname gezählt, wenn cat Fehler meldet.",
          ],
          examples: [
            {
              command: "find . -type f -name '*.log' | wc -l",
              note: "Anzahl der Logdateien ermitteln.",
            },
            {
              command: "grep -r 'ERROR' *.log | wc -l",
              note: "Fehlerzeilen über mehrere Dateien zählen.",
            },
          ],
          quizId: "wc_l",
        },
        pwd: {
          title: "pwd",
          summary: "Zeigt das aktuelle Arbeitsverzeichnis (absoluter Pfad).",
          flags: [
            {
              flag: "-P",
              description: "zeigt den physischen Pfad ohne Symlinks",
            },
          ],
          pitfalls: [
            "Verwechslung mit relativen Pfaden – pwd zeigt immer den absoluten Pfad.",
          ],
          examples: [
            {
              command: "pwd",
              note: "Zeigt den aktuellen Pfad, z.B. /home/user/Documents",
            },
            {
              command: 'echo "Aktuelles Verzeichnis: $(pwd)"',
              note: "Verwendung in Scripts zur Pfadausgabe",
            },
          ],
          quizId: "pwd",
        },
        "cd ..": {
          title: "cd ..",
          summary:
            "Wechselt eine Verzeichnisebene nach oben (Parent-Verzeichnis).",
          flags: [
            { flag: "../..", description: "zwei Ebenen nach oben" },
            { flag: "../../..", description: "drei Ebenen nach oben" },
          ],
          pitfalls: [
            "Zu viele .. können über das Root-Verzeichnis hinausgehen (bleibt bei /).",
          ],
          examples: [
            {
              command: "cd ..",
              note: "Eine Ebene nach oben wechseln",
            },
            {
              command: "cd ../..",
              note: "Zwei Ebenen nach oben wechseln",
            },
          ],
          quizId: "cd_parent",
        },
        "ls -a": {
          title: "ls -a",
          summary:
            "Listet alle Dateien inklusive versteckter Dateien (beginnend mit .).",
          flags: [
            {
              flag: "-a",
              description: "zeigt versteckte Dateien (beginnt mit .)",
            },
            { flag: "-la", description: "lange Liste mit versteckten Dateien" },
          ],
          pitfalls: [
            "Versteckte Dateien werden oft übersehen (wichtig bei .env, .git, .ssh).",
          ],
          examples: [
            {
              command: "ls -a",
              note: "Alle Dateien inklusive versteckter anzeigen",
            },
            {
              command: "ls -la",
              note: "Detaillierte Liste mit versteckten Dateien",
            },
          ],
          quizId: "ls_a",
        },
        "ls -la": {
          title: "ls -la",
          summary:
            "Detaillierte Liste aller Dateien mit Rechten, Besitzer, Größe und versteckten Dateien.",
          flags: [
            { flag: "-l", description: "lange Ausgabe mit Details" },
            { flag: "-a", description: "inklusive versteckter Dateien" },
            { flag: "-h", description: "menschlich lesbare Größen (mit -l)" },
          ],
          pitfalls: [
            "Ohne -h sind Dateigrößen schwer lesbar (Bytes statt KiB/MiB).",
          ],
          examples: [
            {
              command: "ls -lah",
              note: "Alle Details inklusive versteckter Dateien, Größen lesbar",
            },
            {
              command: "ls -la ~/.ssh",
              note: "SSH-Keys mit Rechten prüfen",
            },
          ],
          quizId: "ls_la",
        },
        mkdir: {
          title: "mkdir",
          summary: "Erstellt ein neues Verzeichnis.",
          flags: [
            {
              flag: "-p",
              description: "erstellt fehlende Elternverzeichnisse rekursiv",
            },
            { flag: "-v", description: "zeigt erstellte Verzeichnisse an" },
          ],
          pitfalls: [
            "Ohne -p bricht mkdir ab, wenn Elternverzeichnisse fehlen.",
            "Verzeichnis existiert bereits → Fehler ohne -p.",
          ],
          examples: [
            {
              command: "mkdir projects",
              note: "Erstellt ein Verzeichnis namens projects",
            },
            {
              command: "mkdir -p projects/demo/src",
              note: "Erstellt verschachtelte Verzeichnisse in einem Schritt",
            },
          ],
          quizId: "mkdir",
        },
        "mkdir -p": {
          title: "mkdir -p",
          summary:
            "Erstellt Verzeichnisse rekursiv, auch wenn Elternverzeichnisse fehlen.",
          flags: [
            {
              flag: "-p",
              description: "erstellt fehlende Elternverzeichnisse",
            },
            {
              flag: "-v",
              description: "verbose: zeigt erstellte Verzeichnisse",
            },
          ],
          pitfalls: [
            "Idempotent: erstellt nur, was fehlt – sicher für Scripts.",
          ],
          examples: [
            {
              command: "mkdir -p logs/app/2024",
              note: "Erstellt komplette Verzeichnisstruktur in einem Schritt",
            },
            {
              command: "mkdir -p backup/$(date +%Y-%m-%d)",
              note: "Erstellt Backup-Verzeichnis mit Datum",
            },
          ],
          quizId: "mkdir_p",
        },
        mv: {
          title: "mv",
          summary: "Verschiebt oder benennt Dateien/Ordner um.",
          flags: [
            { flag: "-i", description: "interaktiv: fragt vor Überschreibung" },
            { flag: "-v", description: "verbose: zeigt verschobene Dateien" },
            {
              flag: "-n",
              description: "keine Überschreibung existierender Dateien",
            },
          ],
          pitfalls: [
            "Ohne -i werden existierende Dateien ohne Warnung überschrieben.",
            "Falscher Zielpfad kann Dateien an unerwartete Orte verschieben.",
          ],
          examples: [
            {
              command: "mv file.txt backup/",
              note: "Verschiebt Datei ins backup-Verzeichnis",
            },
            {
              command: "mv oldname.txt newname.txt",
              note: "Benennt Datei um",
            },
          ],
          quizId: "mv",
        },
        cp: {
          title: "cp",
          summary: "Kopiert Dateien.",
          flags: [
            { flag: "-r", description: "rekursiv: kopiert Verzeichnisse" },
            { flag: "-i", description: "interaktiv: fragt vor Überschreibung" },
            { flag: "-v", description: "verbose: zeigt kopierte Dateien" },
            {
              flag: "-a",
              description: "archiv: behält Rechte, Links, Zeitstempel",
            },
          ],
          pitfalls: [
            "Ohne -r schlägt cp bei Verzeichnissen fehl.",
            "Rechte werden standardmäßig nicht übernommen (nutze -a).",
          ],
          examples: [
            {
              command: "cp file.txt backup/",
              note: "Kopiert Datei ins backup-Verzeichnis",
            },
            {
              command: "cp -a source/ dest/",
              note: "Kopiert mit allen Metadaten (Rechte, Zeitstempel)",
            },
          ],
          quizId: "cp",
        },
        "cp -r": {
          title: "cp -r",
          summary: "Kopiert Verzeichnisse rekursiv mit allen Inhalten.",
          flags: [
            { flag: "-r", description: "rekursiv: kopiert Verzeichnisse" },
            {
              flag: "-a",
              description: "archiv: behält Rechte, Links, Zeitstempel",
            },
            { flag: "-v", description: "verbose: zeigt kopierte Dateien" },
          ],
          pitfalls: [
            "Ohne -r kopiert cp Verzeichnisse nicht.",
            "Große Verzeichnisse können lange dauern.",
          ],
          examples: [
            {
              command: "cp -r site/ backup/site",
              note: "Kopiert gesamtes Verzeichnis rekursiv",
            },
            {
              command: "cp -ra /var/www/html /backup/",
              note: "Kopiert mit allen Metadaten",
            },
          ],
          quizId: "cp_r",
        },
        rm: {
          title: "rm",
          summary: "Löscht Dateien (endgültig, keine Wiederherstellung).",
          flags: [
            { flag: "-i", description: "interaktiv: fragt vor jedem Löschen" },
            {
              flag: "-f",
              description: "force: ignoriert Fehler und fragt nicht",
            },
            { flag: "-v", description: "verbose: zeigt gelöschte Dateien" },
          ],
          pitfalls: [
            "Löschung ist endgültig – keine Wiederherstellung möglich.",
            "Ohne -i werden Dateien ohne Warnung gelöscht.",
          ],
          examples: [
            {
              command: "rm file.txt",
              note: "Löscht eine Datei",
            },
            {
              command: "rm -i *.tmp",
              note: "Löscht alle .tmp-Dateien mit Bestätigung",
            },
          ],
          quizId: "rm",
        },
        "rm -r": {
          title: "rm -r",
          summary: "Löscht Verzeichnisse rekursiv mit allen Inhalten.",
          flags: [
            { flag: "-r", description: "rekursiv: löscht Verzeichnisse" },
            { flag: "-f", description: "force: ignoriert Fehler" },
            { flag: "-i", description: "interaktiv: fragt vor jedem Löschen" },
          ],
          pitfalls: [
            "rm -rf ist sehr gefährlich – löscht alles ohne Warnung.",
            "Falscher Pfad kann große Datenmengen unwiederbringlich löschen.",
          ],
          examples: [
            {
              command: "rm -r old_directory/",
              note: "Löscht Verzeichnis mit Inhalt",
            },
            {
              command: "rm -rf /tmp/cleanup/*",
              note: "Löscht alles in cleanup (Vorsicht!)",
            },
          ],
          quizId: "rm_r",
        },
        cat: {
          title: "cat",
          summary: "Gibt den Inhalt von Dateien aus (concatenate).",
          flags: [
            { flag: "-n", description: "zeigt Zeilennummern" },
            { flag: "-b", description: "nummeriert nur nicht-leere Zeilen" },
            { flag: "-s", description: "unterdrückt mehrfache Leerzeilen" },
          ],
          pitfalls: [
            "Bei sehr großen Dateien kann cat den Terminal überfluten.",
            "Nutze head oder less für große Dateien.",
          ],
          examples: [
            {
              command: "cat file.txt",
              note: "Zeigt Inhalt einer Datei",
            },
            {
              command: "cat file1.txt file2.txt > combined.txt",
              note: "Verkettet mehrere Dateien",
            },
          ],
          quizId: "cat",
        },
        sort: {
          title: "sort",
          summary: "Sortiert Zeilen alphabetisch oder numerisch.",
          flags: [
            { flag: "-n", description: "numerisch statt alphabetisch" },
            { flag: "-r", description: "umgekehrte Reihenfolge" },
            { flag: "-u", description: "entfernt Duplikate" },
            { flag: "-k", description: "sortiert nach Spalte" },
          ],
          pitfalls: [
            "Ohne -n werden Zahlen alphabetisch sortiert (2 > 10).",
            "Große Dateien können langsam sortiert werden.",
          ],
          examples: [
            {
              command: "sort file.txt",
              note: "Sortiert alphabetisch",
            },
            {
              command: "sort -n -r numbers.txt",
              note: "Sortiert numerisch absteigend",
            },
          ],
          quizId: "sort",
        },
        "sort -n": {
          title: "sort -n",
          summary: "Sortiert Zeilen numerisch (nicht alphabetisch).",
          flags: [
            { flag: "-n", description: "numerische Sortierung" },
            { flag: "-r", description: "umgekehrte Reihenfolge" },
            { flag: "-k", description: "sortiert nach Spalte" },
          ],
          pitfalls: [
            "Ohne -n wird 10 vor 2 sortiert (alphabetisch).",
            "Kombiniere mit -k für Spalten-Sortierung.",
          ],
          examples: [
            {
              command: "sort -n numbers.txt",
              note: "Sortiert Zahlen korrekt (1, 2, 10 statt 1, 10, 2)",
            },
            {
              command: "sort -n -k2 data.txt",
              note: "Sortiert nach zweiter Spalte numerisch",
            },
          ],
          quizId: "sort_n",
        },
        uniq: {
          title: "uniq",
          summary: "Entfernt aufeinanderfolgende doppelte Zeilen.",
          flags: [
            { flag: "-c", description: "zählt Vorkommen jeder Zeile" },
            { flag: "-d", description: "zeigt nur Duplikate" },
            { flag: "-u", description: "zeigt nur eindeutige Zeilen" },
          ],
          pitfalls: [
            "uniq entfernt nur aufeinanderfolgende Duplikate – vorher sortieren.",
            "Ohne vorheriges sort bleiben Duplikate erhalten.",
          ],
          examples: [
            {
              command: "sort file.txt | uniq",
              note: "Entfernt alle Duplikate (nach Sortierung)",
            },
            {
              command: "sort file.txt | uniq -c",
              note: "Zeigt Häufigkeit jeder Zeile",
            },
          ],
          quizId: "uniq",
        },
        "find . -name": {
          title: "find . -name",
          summary: "Sucht Dateien nach Namen (Pattern-Matching).",
          flags: [
            { flag: "-name", description: "sucht nach Dateinamen (Pattern)" },
            { flag: "-iname", description: "case-insensitive Suche" },
            {
              flag: "-type f",
              description: "nur Dateien (d für Verzeichnisse)",
            },
          ],
          pitfalls: [
            "Pattern muss in Anführungszeichen, sonst expandiert die Shell.",
            "Ohne -type kann auch Verzeichnisse finden.",
          ],
          examples: [
            {
              command: 'find . -name "*.log"',
              note: "Findet alle .log-Dateien im aktuellen Verzeichnis",
            },
            {
              command: 'find /var -name "*.conf" -type f',
              note: "Findet Config-Dateien in /var",
            },
          ],
          quizId: "find_name",
        },
        "find . -maxdepth 1 -type d": {
          title: "find . -maxdepth 1 -type d",
          summary: "Findet Verzeichnisse mit begrenzter Tiefe.",
          flags: [
            { flag: "-maxdepth", description: "begrenzt Suchtiefe" },
            { flag: "-type d", description: "nur Verzeichnisse" },
            { flag: "-mindepth", description: "minimale Suchtiefe" },
          ],
          pitfalls: [
            "Ohne -maxdepth sucht find rekursiv in allen Unterverzeichnissen.",
            "Große Verzeichnisbäume können sehr lange dauern.",
          ],
          examples: [
            {
              command: "find . -maxdepth 1 -type d",
              note: "Zeigt nur direkte Unterverzeichnisse",
            },
            {
              command: "find /var -maxdepth 2 -type d",
              note: "Verzeichnisse bis 2 Ebenen tief",
            },
          ],
          quizId: "find_maxdepth",
        },
        "ls -R": {
          title: "ls -R",
          summary: "Listet Verzeichnisse rekursiv (alle Unterverzeichnisse).",
          flags: [
            {
              flag: "-R",
              description: "rekursiv: zeigt alle Unterverzeichnisse",
            },
            { flag: "-l", description: "lange Ausgabe mit Details" },
            { flag: "-h", description: "menschlich lesbare Größen" },
          ],
          pitfalls: [
            "Bei großen Verzeichnisbäumen kann die Ausgabe sehr lang werden.",
            "Nutze tree für übersichtlichere Darstellung.",
          ],
          examples: [
            {
              command: "ls -R",
              note: "Listet alle Verzeichnisse rekursiv",
            },
            {
              command: "ls -Rl project/",
              note: "Detaillierte rekursive Liste",
            },
          ],
          quizId: "ls_R",
        },
        "ls -aR": {
          title: "ls -aR",
          summary:
            "Listet alle Dateien rekursiv inklusive versteckter Dateien.",
          flags: [
            { flag: "-a", description: "inklusive versteckter Dateien" },
            {
              flag: "-R",
              description: "rekursiv in allen Unterverzeichnissen",
            },
            { flag: "-l", description: "lange Ausgabe mit Details" },
          ],
          pitfalls: [
            "Kann sehr viele Dateien ausgeben – nutze | less oder | head.",
          ],
          examples: [
            {
              command: "ls -aR",
              note: "Alle Dateien rekursiv inklusive versteckter",
            },
            {
              command: "ls -aRl | head -n 50",
              note: "Erste 50 Zeilen der rekursiven Liste",
            },
          ],
          quizId: "ls_aR",
        },
        tree: {
          title: "tree",
          summary:
            "Zeigt Verzeichnisstruktur als Baum (muss installiert sein).",
          flags: [
            { flag: "-d", description: "nur Verzeichnisse, keine Dateien" },
            { flag: "-L", description: "begrenzt Tiefe" },
            { flag: "-a", description: "inklusive versteckter Dateien" },
          ],
          pitfalls: [
            "tree ist nicht standardmäßig installiert (apt install tree).",
            "Ohne -L kann bei großen Bäumen die Ausgabe sehr lang werden.",
          ],
          examples: [
            {
              command: "tree",
              note: "Zeigt Verzeichnisstruktur als Baum",
            },
            {
              command: "tree -L 2",
              note: "Zeigt nur 2 Ebenen tief",
            },
          ],
          quizId: "tree",
        },
        "tree -d": {
          title: "tree -d",
          summary: "Zeigt nur Verzeichnisse (keine Dateien) als Baum.",
          flags: [
            { flag: "-d", description: "nur Verzeichnisse" },
            { flag: "-L", description: "begrenzt Tiefe" },
          ],
          pitfalls: [
            "Nützlich für Übersicht über Verzeichnisstruktur ohne Dateien.",
          ],
          examples: [
            {
              command: "tree -d",
              note: "Zeigt nur Verzeichnisstruktur",
            },
            {
              command: "tree -d -L 3",
              note: "Verzeichnisse bis 3 Ebenen tief",
            },
          ],
          quizId: "tree_d",
        },
        "tree -L": {
          title: "tree -L",
          summary: "Begrenzt die Tiefe der Baumdarstellung.",
          flags: [
            { flag: "-L N", description: "zeigt nur N Ebenen tief" },
            { flag: "-d", description: "nur Verzeichnisse" },
            { flag: "-a", description: "inklusive versteckter Dateien" },
          ],
          pitfalls: ["Ohne -L zeigt tree alle Ebenen (kann sehr lang werden)."],
          examples: [
            {
              command: "tree -L 2",
              note: "Zeigt nur 2 Ebenen tief",
            },
            {
              command: "sudo tree -L 3 /",
              note: "Oberste 3 Ebenen des Systems (benötigt sudo)",
            },
          ],
          quizId: "tree_L",
        },
        echo: {
          title: "echo",
          summary: "Gibt Text im Terminal aus.",
          flags: [
            { flag: "-n", description: "kein Zeilenumbruch am Ende" },
            {
              flag: "-e",
              description: "interpretiert Escape-Sequenzen (\\n, \\t)",
            },
          ],
          pitfalls: [
            "Ohne Anführungszeichen werden Variablen expandiert.",
            "Sonderzeichen müssen escaped werden.",
          ],
          examples: [
            {
              command: 'echo "Hello World"',
              note: "Gibt Text aus",
            },
            {
              command: 'echo -e "Line 1\\nLine 2"',
              note: "Gibt mehrere Zeilen aus",
            },
          ],
          quizId: "echo",
        },
        redirect: {
          title: "Umleitung",
          summary: "Leitet Ausgaben in Dateien um oder kombiniert Befehle.",
          flags: [
            { flag: ">", description: "überschreibt Datei" },
            { flag: ">>", description: "hängt an Datei an" },
            { flag: "2>", description: "leitet Fehlerausgabe um" },
            { flag: "|", description: "Pipe: Ausgabe → Eingabe" },
          ],
          pitfalls: [
            "Einzelnes > überschreibt Dateien ohne Warnung.",
            "Nutze >> für Logs, um Daten nicht zu verlieren.",
          ],
          examples: [
            {
              command: "ls > files.txt",
              note: "Speichert Ausgabe in Datei (überschreibt)",
            },
            {
              command: 'echo "New line" >> log.txt',
              note: "Hängt Text an Datei an",
            },
          ],
          quizId: "redirect",
        },
        whoami: {
          title: "whoami",
          summary: "Zeigt den aktuellen Benutzernamen.",
          flags: [],
          pitfalls: [
            "Unterschied zu who: whoami zeigt nur den aktuellen Benutzer.",
          ],
          examples: [
            {
              command: "whoami",
              note: "Zeigt aktuellen Benutzer, z.B. kali oder root",
            },
            {
              command: "whoami && pwd",
              note: "Kombiniert mit pwd für Kontext",
            },
          ],
          quizId: "whoami",
        },
        "chmod -R": {
          title: "chmod -R",
          summary:
            "Ändert Dateirechte rekursiv für Verzeichnisse und Unterverzeichnisse.",
          flags: [
            { flag: "-R", description: "rekursiv auf alle Unterverzeichnisse" },
            {
              flag: "+x",
              description: "Ausführungsrechte hinzufügen (symbolisch)",
            },
            { flag: "755", description: "Standard-Webrechte (numerisch)" },
          ],
          pitfalls: [
            "chmod -R 777 ist sehr gefährlich – macht alles beschreibbar.",
            "Rekursive Änderungen können Services brechen.",
          ],
          examples: [
            {
              command: "chmod -R 755 /var/www/html",
              note: "Setzt Standard-Webrechte rekursiv",
            },
            {
              command: "chmod -R +x scripts/",
              note: "Macht alle Scripts ausführbar",
            },
          ],
          quizId: "chmod_R",
        },
        chgrp: {
          title: "chgrp",
          summary: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          flags: [
            { flag: "-R", description: "rekursiv auf Unterverzeichnisse" },
            { flag: "groupname", description: "Name der neuen Gruppe" },
          ],
          pitfalls: [
            "Unterschied zu chown: chgrp ändert nur die Gruppe, nicht den Besitzer.",
          ],
          examples: [
            {
              command: "chgrp developers project/",
              note: "Ändert Gruppe auf developers",
            },
            {
              command: "sudo chgrp -R www-data /var/www/html",
              note: "Setzt Gruppe rekursiv für Webroot",
            },
          ],
          quizId: "chgrp",
        },
        "wc -w": {
          title: "wc -w",
          summary: "Zählt Wörter in einer Datei oder Eingabe.",
          flags: [
            { flag: "-w", description: "zählt Wörter" },
            { flag: "-l", description: "zählt Zeilen" },
            { flag: "-c", description: "zählt Bytes" },
          ],
          pitfalls: ["Wörter werden durch Whitespace getrennt gezählt."],
          examples: [
            {
              command: "wc -w file.txt",
              note: "Zählt Wörter in Datei",
            },
            {
              command: "echo 'Hello World' | wc -w",
              note: "Zählt Wörter in Eingabe",
            },
          ],
          quizId: "wc_w",
        },
        ">": {
          title: ">",
          summary:
            "Leitet Ausgabe in Datei um (überschreibt existierende Datei).",
          flags: [
            { flag: ">", description: "überschreibt Datei oder erstellt sie" },
            {
              flag: ">>",
              description: "hängt an Datei an (keine Überschreibung)",
            },
          ],
          pitfalls: [
            "Überschreibt ohne Warnung – alle bisherigen Inhalte gehen verloren.",
            "Nutze >> für Logs, um Daten nicht zu verlieren.",
          ],
          examples: [
            {
              command: 'echo "Hallo" > info.txt',
              note: "Speichert Text in Datei (überschreibt)",
            },
            {
              command: "ls > files.txt",
              note: "Speichert Dateiliste in Datei",
            },
          ],
          quizId: "redirect_overwrite",
        },
        ">>": {
          title: ">>",
          summary: "Hängt Ausgabe an Datei an (ohne Überschreibung).",
          flags: [
            { flag: ">>", description: "hängt an Datei an" },
            { flag: ">", description: "überschreibt Datei" },
          ],
          pitfalls: ["Ideal für Logs, um alle Einträge zu behalten."],
          examples: [
            {
              command: 'echo "Neue Zeile" >> log.txt',
              note: "Hängt Text an Datei an",
            },
            {
              command: 'echo "$(date): Start" >> system.log',
              note: "Hängt Zeitstempel an Log an",
            },
          ],
          quizId: "redirect_append",
        },
        "2>": {
          title: "2>",
          summary: "Leitet Fehlerausgabe (stderr) in Datei um.",
          flags: [
            { flag: "2>", description: "leitet stderr (Fehler) um" },
            { flag: "2>&1", description: "leitet stderr auf stdout um" },
            { flag: "> file 2>&1", description: "beide Streams in eine Datei" },
          ],
          pitfalls: [
            "Fehler werden standardmäßig im Terminal angezeigt – 2> isoliert sie.",
          ],
          examples: [
            {
              command: "command 2> errors.txt",
              note: "Speichert nur Fehler in Datei",
            },
            {
              command: "find / -name '*.conf' 2> /dev/null",
              note: "Versteckt Fehler (z.B. Permission denied)",
            },
          ],
          quizId: "redirect_stderr",
        },
        nano_flow: {
          title: "Nano + Script-Workflow",
          summary: "Script erstellen, ausführbar machen und starten.",
          flags: [
            { flag: "STRG+O", description: "speichert Datei in nano" },
            { flag: "STRG+X", description: "beendet nano" },
            { flag: "chmod +x", description: "macht Script ausführbar" },
            { flag: "./script.sh", description: "führt Script aus" },
          ],
          pitfalls: [
            "Ohne chmod +x kann Script nicht direkt ausgeführt werden.",
            "Vergiss nicht STRG+O zum Speichern in nano.",
          ],
          examples: [
            {
              command: "nano script.sh && chmod +x script.sh && ./script.sh",
              note: "Kompletter Workflow: erstellen, ausführbar machen, starten",
            },
            {
              command: "chmod +x script.sh && ./script.sh",
              note: "Script ausführbar machen und starten",
            },
          ],
          quizId: "nano_flow",
        },
        // Commands mit Flags im Namen
        ls_a: {
          title: "ls -a",
          summary: "Listet alle Dateien inklusive versteckter Dateien.",
          flags: [
            { flag: "-a", description: "zeigt versteckte Dateien und ./." },
          ],
          pitfalls: [
            "Versteckte Dateien beginnen mit Punkt (z.B. .env, .gitignore).",
          ],
          examples: [
            {
              command: "ls -a ~/.ssh",
              note: "Zeigt alle SSH-Konfigurationsdateien inklusive versteckter.",
            },
          ],
          quizId: "ls_a",
        },
        ls_la: {
          title: "ls -la",
          summary:
            "Listet alle Dateien mit Details inklusive versteckter Dateien.",
          flags: [
            {
              flag: "-l",
              description: "lange Ausgabe mit Rechten und Besitzer",
            },
            { flag: "-a", description: "zeigt versteckte Dateien und ./." },
          ],
          pitfalls: ["Kombination -la zeigt auch . und .. Verzeichnisse."],
          examples: [
            {
              command: "ls -la /var/log",
              note: "Vollständige Übersicht über Log-Dateien mit Rechten.",
            },
          ],
          quizId: "ls_la",
        },
        ls_R: {
          title: "ls -R",
          summary: "Listet Dateien rekursiv in allen Unterverzeichnissen.",
          flags: [
            {
              flag: "-R",
              description: "rekursives Auflisten aller Unterverzeichnisse",
            },
          ],
          pitfalls: [
            "Kann bei großen Verzeichnisbäumen sehr viel Output produzieren.",
          ],
          examples: [
            {
              command: "ls -R /etc/apache2",
              note: "Zeigt alle Dateien in Apache-Konfigurationsverzeichnis rekursiv.",
            },
          ],
          quizId: "ls_R",
        },
        ls_aR: {
          title: "ls -aR",
          summary:
            "Listet alle Dateien rekursiv inklusive versteckter Dateien.",
          flags: [
            { flag: "-a", description: "zeigt versteckte Dateien und ./." },
            {
              flag: "-R",
              description: "rekursives Auflisten aller Unterverzeichnisse",
            },
          ],
          pitfalls: [
            "Kombination kann sehr viel Output produzieren - nutze | head oder | less.",
          ],
          examples: [
            {
              command: "ls -aR ~/projects | head -n 50",
              note: "Erste 50 Zeilen der rekursiven Auflistung.",
            },
          ],
          quizId: "ls_aR",
        },
        mkdir_p: {
          title: "mkdir -p",
          summary: "Erstellt Verzeichnisse und fehlende Zwischenverzeichnisse.",
          flags: [
            {
              flag: "-p",
              description: "erstellt fehlende Zwischenverzeichnisse (parents)",
            },
          ],
          pitfalls: [
            "Ohne -p schlägt mkdir fehl, wenn Zwischenverzeichnisse fehlen.",
          ],
          examples: [
            {
              command: "mkdir -p /var/www/html/myapp/logs",
              note: "Erstellt kompletten Pfad auch wenn /var/www/html/myapp nicht existiert.",
            },
          ],
          quizId: "mkdir_p",
        },
        cp_r: {
          title: "cp -r",
          summary: "Kopiert Verzeichnisse rekursiv.",
          flags: [
            {
              flag: "-r",
              description: "rekursives Kopieren von Verzeichnissen",
            },
            {
              flag: "-R",
              description: "rekursives Kopieren (Alternative zu -r)",
            },
            {
              flag: "-a",
              description: "archiv-Modus (kopiert Rechte, Links, etc.)",
            },
          ],
          pitfalls: [
            "Ohne -r kann cp keine Verzeichnisse kopieren.",
            "-a kopiert auch versteckte Dateien und behält alle Attribute.",
          ],
          examples: [
            {
              command: "cp -r /home/user/documents /backup/",
              note: "Kopiert gesamtes Verzeichnis rekursiv.",
            },
            {
              command: "cp -a /var/www/html /backup/",
              note: "Kopiert mit allen Rechten und Attributen (archiv-Modus).",
            },
          ],
          quizId: "cp_r",
        },
        rm_r: {
          title: "rm -r",
          summary: "Löscht Verzeichnisse rekursiv.",
          flags: [
            {
              flag: "-r",
              description: "rekursives Löschen von Verzeichnissen",
            },
            {
              flag: "-R",
              description: "rekursives Löschen (Alternative zu -r)",
            },
            { flag: "-f", description: "force (ohne Nachfrage)" },
            { flag: "-i", description: "interaktiv (mit Nachfrage)" },
          ],
          pitfalls: [
            "rm -rf ist gefährlich - löscht ohne Rückfrage alles rekursiv!",
            "Verwende -i für Sicherheit bei wichtigen Dateien.",
          ],
          examples: [
            {
              command: "rm -r /tmp/old_files",
              note: "Löscht Verzeichnis rekursiv (mit Nachfrage bei geschützten Dateien).",
            },
            {
              command: "rm -rf /tmp/cache",
              note: "Löscht ohne Nachfrage - Vorsicht!",
            },
          ],
          quizId: "rm_r",
        },
        sort_n: {
          title: "sort -n",
          summary: "Sortiert numerisch statt alphabetisch.",
          flags: [
            { flag: "-n", description: "numerisches Sortieren" },
            { flag: "-r", description: "reverse (absteigend)" },
            { flag: "-k", description: "Sortierung nach Spalte" },
          ],
          pitfalls: [
            "Ohne -n werden Zahlen alphabetisch sortiert (1, 10, 2 statt 1, 2, 10).",
          ],
          examples: [
            {
              command: "sort -n numbers.txt",
              note: "Sortiert Zahlen korrekt numerisch.",
            },
            {
              command: "sort -rn numbers.txt",
              note: "Sortiert absteigend numerisch.",
            },
          ],
          quizId: "sort_n",
        },
        tree_d: {
          title: "tree -d",
          summary: "Zeigt nur Verzeichnisse in Baumstruktur.",
          flags: [
            {
              flag: "-d",
              description: "zeigt nur Verzeichnisse (directories)",
            },
          ],
          pitfalls: [
            "Ohne -d zeigt tree auch alle Dateien, was bei großen Verzeichnissen unübersichtlich wird.",
          ],
          examples: [
            {
              command: "tree -d /var/www",
              note: "Zeigt nur Verzeichnisstruktur ohne Dateien.",
            },
          ],
          quizId: "tree_d",
        },
        tree_L: {
          title: "tree -L",
          summary: "Begrenzt die Tiefe der Baumstruktur.",
          flags: [{ flag: "-L", description: "begrenzt die Tiefe (Level)" }],
          pitfalls: [
            "Ohne -L zeigt tree alle Ebenen, was bei tiefen Strukturen unübersichtlich wird.",
          ],
          examples: [
            {
              command: "tree -L 2 /var/www",
              note: "Zeigt nur die ersten 2 Ebenen der Verzeichnisstruktur.",
            },
          ],
          quizId: "tree_L",
        },
        // Basis-Commands ohne commandMeta
        mkdir: {
          title: "mkdir",
          summary: "Erstellt neue Verzeichnisse.",
          flags: [
            {
              flag: "-p",
              description: "erstellt fehlende Zwischenverzeichnisse (parents)",
            },
            {
              flag: "-v",
              description: "verbose (zeigt erstellte Verzeichnisse)",
            },
          ],
          pitfalls: [
            "Ohne -p schlägt mkdir fehl, wenn Zwischenverzeichnisse fehlen.",
          ],
          examples: [
            {
              command: "mkdir -p project/{src,docs,tests}",
              note: "Erstellt mehrere Verzeichnisse auf einmal.",
            },
            {
              command: "mkdir -pv /var/www/html/myapp",
              note: "Erstellt mit Ausgabe der erstellten Verzeichnisse.",
            },
          ],
          quizId: "mkdir",
        },
        cp: {
          title: "cp",
          summary: "Kopiert Dateien und Verzeichnisse.",
          flags: [
            {
              flag: "-r",
              description: "rekursives Kopieren von Verzeichnissen",
            },
            {
              flag: "-R",
              description: "rekursives Kopieren (Alternative zu -r)",
            },
            {
              flag: "-a",
              description: "archiv-Modus (kopiert Rechte, Links, etc.)",
            },
            {
              flag: "-i",
              description: "interaktiv (mit Nachfrage bei Überschreiben)",
            },
            { flag: "-u", description: "update (nur wenn Quelle neuer ist)" },
          ],
          pitfalls: [
            "Ohne -i überschreibt cp ohne Warnung existierende Dateien.",
            "-a ist ideal für Backups, da alle Attribute erhalten bleiben.",
          ],
          examples: [
            {
              command: "cp -i file.txt backup/",
              note: "Kopiert mit Nachfrage bei Überschreiben.",
            },
            {
              command: "cp -u *.log /backup/",
              note: "Kopiert nur neuere Dateien (update-Modus).",
            },
          ],
          quizId: "cp",
        },
        rm: {
          title: "rm",
          summary: "Löscht Dateien und Verzeichnisse.",
          flags: [
            {
              flag: "-r",
              description: "rekursives Löschen von Verzeichnissen",
            },
            {
              flag: "-R",
              description: "rekursives Löschen (Alternative zu -r)",
            },
            { flag: "-f", description: "force (ohne Nachfrage)" },
            { flag: "-i", description: "interaktiv (mit Nachfrage)" },
          ],
          pitfalls: [
            "rm -rf ist extrem gefährlich - löscht ohne Rückfrage alles!",
            "Verwende -i für Sicherheit bei wichtigen Dateien.",
          ],
          examples: [
            {
              command: "rm -i important.txt",
              note: "Löscht mit Nachfrage zur Sicherheit.",
            },
            {
              command: "rm -rf /tmp/old_cache",
              note: "Löscht rekursiv ohne Nachfrage - Vorsicht!",
            },
          ],
          quizId: "rm",
        },
        sort: {
          title: "sort",
          summary: "Sortiert Zeilen alphabetisch oder numerisch.",
          flags: [
            { flag: "-n", description: "numerisches Sortieren" },
            { flag: "-r", description: "reverse (absteigend)" },
            { flag: "-k", description: "Sortierung nach Spalte" },
            { flag: "-u", description: "unique (entfernt Duplikate)" },
          ],
          pitfalls: [
            "Ohne -n werden Zahlen alphabetisch sortiert (1, 10, 2 statt 1, 2, 10).",
          ],
          examples: [
            {
              command: "sort file.txt",
              note: "Sortiert alphabetisch.",
            },
            {
              command: "sort -nu numbers.txt",
              note: "Sortiert numerisch und entfernt Duplikate.",
            },
          ],
          quizId: "sort",
        },
        tree: {
          title: "tree",
          summary: "Zeigt Verzeichnisstruktur als Baum.",
          flags: [
            { flag: "-d", description: "zeigt nur Verzeichnisse" },
            { flag: "-L", description: "begrenzt die Tiefe (Level)" },
            { flag: "-a", description: "zeigt auch versteckte Dateien" },
          ],
          pitfalls: [
            "Ohne -L kann tree bei tiefen Strukturen sehr lang werden.",
          ],
          examples: [
            {
              command: "tree -L 3 /var/www",
              note: "Zeigt Verzeichnisstruktur bis 3 Ebenen tief.",
            },
            {
              command: "tree -da /home/user",
              note: "Zeigt nur Verzeichnisse inklusive versteckter.",
            },
          ],
          quizId: "tree",
        },
        mv: {
          title: "mv",
          summary: "Verschiebt oder benennt Dateien und Verzeichnisse um.",
          flags: [
            {
              flag: "-i",
              description: "interaktiv (mit Nachfrage bei Überschreiben)",
            },
            { flag: "-v", description: "verbose (zeigt verschobene Dateien)" },
            { flag: "-n", description: "no-clobber (überschreibt nicht)" },
          ],
          pitfalls: [
            "Ohne -i überschreibt mv ohne Warnung existierende Dateien.",
            "-n verhindert Überschreiben, aber gibt keine Fehlermeldung.",
          ],
          examples: [
            {
              command: "mv -i old.txt new.txt",
              note: "Benennt um mit Nachfrage bei Überschreiben.",
            },
            {
              command: "mv -v *.txt /backup/",
              note: "Verschiebt mit Ausgabe der verschobenen Dateien.",
            },
          ],
          quizId: "mv",
        },
        chgrp: {
          title: "chgrp",
          summary: "Ändert nur die Gruppenzugehörigkeit einer Datei.",
          flags: [
            { flag: "-R", description: "rekursiv auf Unterverzeichnisse" },
            { flag: "-v", description: "verbose (zeigt Änderungen)" },
            { flag: "groupname", description: "Name der neuen Gruppe" },
          ],
          pitfalls: [
            "Unterschied zu chown: chgrp ändert nur die Gruppe, nicht den Besitzer.",
          ],
          examples: [
            {
              command: "chgrp -v developers project/",
              note: "Ändert Gruppe mit Ausgabe der Änderungen.",
            },
            {
              command: "sudo chgrp -Rv www-data /var/www/html",
              note: "Setzt Gruppe rekursiv mit Ausgabe.",
            },
          ],
          quizId: "chgrp",
        },
        cat: {
          title: "cat",
          summary: "Zeigt Dateiinhalt an oder verkettet mehrere Dateien.",
          flags: [
            { flag: "-n", description: "zeigt Zeilennummern" },
            {
              flag: "-b",
              description: "zeigt Zeilennummern (nur nicht-leere Zeilen)",
            },
          ],
          pitfalls: [
            "Bei großen Dateien kann cat den Terminal überfluten - nutze | less.",
          ],
          examples: [
            {
              command: "cat -n script.sh",
              note: "Zeigt Datei mit Zeilennummern.",
            },
            {
              command: "cat file1.txt file2.txt > combined.txt",
              note: "Verkettet mehrere Dateien zu einer.",
            },
          ],
          quizId: "cat",
        },
        uniq: {
          title: "uniq",
          summary: "Entfernt doppelte aufeinanderfolgende Zeilen.",
          flags: [
            { flag: "-c", description: "zählt Vorkommen" },
            { flag: "-d", description: "zeigt nur Duplikate" },
            { flag: "-u", description: "zeigt nur eindeutige Zeilen" },
          ],
          pitfalls: [
            "uniq entfernt nur aufeinanderfolgende Duplikate - nutze sort | uniq für alle Duplikate.",
          ],
          examples: [
            {
              command: "sort file.txt | uniq -c",
              note: "Sortiert und zählt Vorkommen jeder Zeile.",
            },
            {
              command: "sort file.txt | uniq -d",
              note: "Zeigt nur Zeilen, die mehrfach vorkommen.",
            },
          ],
          quizId: "uniq",
        },
        // Basis-Command wc (optional, aber sinnvoll für Vollständigkeit)
        wc: {
          title: "wc",
          summary: "Zählt Zeilen, Wörter und Bytes in Dateien oder Eingabe.",
          flags: [
            { flag: "-l", description: "zählt Zeilen" },
            { flag: "-w", description: "zählt Wörter" },
            { flag: "-c", description: "zählt Bytes" },
          ],
          pitfalls: [
            "Ohne Flag zeigt wc alle drei Werte (Zeilen, Wörter, Bytes).",
            "Leerzeichen in Dateinamen ohne korrekte Quoting führen zu falschen Zählungen.",
          ],
          examples: [
            {
              command: "wc file.txt",
              note: "Zeigt Zeilen, Wörter und Bytes einer Datei.",
            },
            {
              command: "wc -l *.log",
              note: "Zählt Zeilen in allen Log-Dateien.",
            },
          ],
          quizId: "wc",
        },

        xargs: {
          title: "xargs",
          summary: "Baut Befehlsaufrufe aus stdin-Listen (sicher mit -0/-I).",
          flags: [
            {
              flag: "-0",
              description: "Null-terminierte Eingabe (find -print0)",
            },
            { flag: "-n", description: "maximale Argumente pro Aufruf" },
            { flag: "-I{}", description: "Platzhalter je Element" },
          ],
          pitfalls: [
            "Ohne -0 brechen Leerzeichen in Dateinamen die Befehle.",
            "-n begrenzen, um zu lange Argumentlisten zu vermeiden.",
          ],
          examples: [
            {
              command: 'find . -name "*.log" -print0 | xargs -0 rm --',
              note: "Logs sicher lschen, auch mit Leerzeichen.",
            },
            {
              command:
                "printf '%s\\0' *.txt | xargs -0 -n 5 tar -czf batch.tar.gz",
              note: "Bndelt Dateien in Paketen von 5.",
            },
          ],
          quizId: "xargs",
        },

        tee: {
          title: "tee",
          summary: "Schreibt Pipeline-Ausgabe auf Bildschirm und in Datei.",
          flags: [
            { flag: "-a", description: "an Datei anh„ngen statt berschreiben" },
            { flag: "-i", description: "Interrupt-Signale ignorieren" },
          ],
          pitfalls: [
            "Ohne -a wird die Zieldatei berschrieben.",
            "stderr muss ggf. mit |& oder 2>&1 umgeleitet werden.",
          ],
          examples: [
            {
              command: "uptime | tee -a logs/uptime.log",
              note: "Ausgabe sehen und anh„ngen.",
            },
            {
              command: "command |& tee -a full.log | grep ERROR",
              note: "stdout+stderr loggen und weiterfiltern.",
            },
          ],
          quizId: "tee",
        },

        tar: {
          title: "tar",
          summary: "Erstellt/entpackt Archive, optional gzip (-z).",
          flags: [
            { flag: "-c", description: "Archiv erstellen" },
            { flag: "-x", description: "Archiv entpacken" },
            { flag: "-z", description: "gzip-Kompression" },
            { flag: "-f", description: "Zieldatei fr Archiv" },
            {
              flag: "-C",
              description: "Zielverzeichnis beim Entpacken/Packen",
            },
          ],
          pitfalls: [
            "-f direkt vor Archivnamen setzen, sonst interpretiert tar die n„chste Datei falsch.",
            "Ohne -p gehen Dateirechte beim Entpacken verloren.",
          ],
          examples: [
            {
              command: "tar -czf backups/www.tar.gz /var/www",
              note: "Verzeichnis komprimiert sichern.",
            },
            {
              command: "tar -xzf backup.tar.gz -C /tmp/restore",
              note: "Archiv in Zielverzeichnis entpacken.",
            },
          ],
          quizId: "tar",
        },
        flags_overview: {
          title: "Flags-Übersicht",
          summary:
            "Komplette Übersicht aller wichtigen Flags aus allen Quiz-Kacheln - organisiert nach Befehlen mit Erklärungen, Nützlichkeit und praktischen Beispielen.",
          flags: [
            {
              flag: "Navigation",
              description: "--- Navigation & Verzeichnisse ---",
            },
            {
              flag: "pwd -P",
              description: "zeigt den physischen Pfad ohne Symlinks",
            },
            { flag: "cd (ohne)", description: "wechselt ins Home-Verzeichnis" },
            {
              flag: "cd -",
              description: "wechselt ins vorherige Verzeichnis (Toggle)",
            },
            {
              flag: "cd ..",
              description: "Parent-Verzeichnis (eine Ebene nach oben)",
            },

            { flag: "ls Flags", description: "--- ls (Auflisten) ---" },
            {
              flag: "ls -l",
              description: "lange Ausgabe mit Rechten und Besitzer",
            },
            { flag: "ls -a", description: "zeigt versteckte Dateien und ./. " },
            {
              flag: "ls -h",
              description: "menschlich lesbare Größen (mit -l)",
            },
            {
              flag: "ls -R",
              description: "rekursives Auflisten aller Unterverzeichnisse",
            },
            {
              flag: "ls -la",
              description: "Details + versteckte Dateien (Kombination)",
            },
            { flag: "ls -aR", description: "rekursiv + versteckte Dateien" },

            { flag: "grep Flags", description: "--- grep (Suche) ---" },
            { flag: "grep -n", description: "zeigt Zeilennummern" },
            {
              flag: "grep -i",
              description: "Groß-/Kleinschreibung ignorieren",
            },
            {
              flag: "grep -r",
              description: "rekursiv in Verzeichnissen suchen",
            },
            {
              flag: "grep --include",
              description: "filtert Dateien nach Pattern",
            },

            { flag: "find Flags", description: "--- find (Dateisuche) ---" },
            {
              flag: "find -name",
              description: "Pfad-Pattern (mit Anführungszeichen!)",
            },
            {
              flag: "find -type f",
              description: "nur Dateien (d für Verzeichnisse)",
            },
            { flag: "find -type d", description: "nur Verzeichnisse" },
            {
              flag: "find -maxdepth",
              description: "Tiefe begrenzen, um Rauschen zu vermeiden",
            },
            {
              flag: "find -exec",
              description: "führt Befehl für jedes Ergebnis aus",
            },

            {
              flag: "Datei-Operationen",
              description: "--- Datei-Operationen ---",
            },
            {
              flag: "mkdir -p",
              description: "erstellt fehlende Zwischenverzeichnisse",
            },
            {
              flag: "cp -r / -R",
              description: "rekursives Kopieren von Verzeichnissen",
            },
            {
              flag: "cp -a",
              description: "archiv-Modus (kopiert Rechte, Links, etc.)",
            },
            {
              flag: "cp -i",
              description: "interaktiv (fragt vor Überschreiben)",
            },
            {
              flag: "rm -r / -R",
              description: "rekursives Löschen - GEFÄHRLICH!",
            },
            {
              flag: "rm -i",
              description: "interaktiv (mit Nachfrage) - EMPFOHLEN",
            },
            {
              flag: "rm -f",
              description: "force (ohne Nachfrage) - SEHR GEFÄHRLICH!",
            },

            {
              flag: "Text-Verarbeitung",
              description: "--- Text-Verarbeitung ---",
            },
            {
              flag: "sort -n",
              description: "numerisches Sortieren (2 vor 10)",
            },
            { flag: "sort -r", description: "reverse (absteigend)" },
            { flag: "sort -k", description: "Sortierung nach Spalte" },
            { flag: "uniq -c", description: "zählt Vorkommen jeder Zeile" },
            { flag: "head -n", description: "zeigt nur erste N Zeilen" },
            { flag: "tail -n", description: "zeigt nur letzte N Zeilen" },
            {
              flag: "tail -f",
              description: "folgt Datei in Echtzeit (follow)",
            },
            { flag: "wc -l", description: "zählt Zeilen" },
            { flag: "wc -w", description: "zählt Wörter" },

            {
              flag: "Rechte & Besitzer",
              description: "--- Rechte & Besitzer ---",
            },
            {
              flag: "chmod -R",
              description: "rekursiv (auf alle Unterverzeichnisse)",
            },
            {
              flag: "chown -R",
              description: "rekursiv (auf alle Unterverzeichnisse)",
            },
            { flag: "chgrp -R", description: "rekursiv Gruppe setzen" },

            { flag: "Weitere Tools", description: "--- Weitere Tools ---" },
            { flag: "tree -d", description: "zeigt nur Verzeichnisse" },
            { flag: "tree -L", description: "begrenzt die Tiefe (Level)" },
            {
              flag: "xargs -0",
              description: "Null-terminierte Eingabe (sicher bei Leerzeichen)",
            },
            { flag: "tee -a", description: "hängt an bestehende Datei an" },
            { flag: "tar -czf", description: "erstellt komprimiertes Archiv" },
            { flag: "tar -xzf", description: "entpackt komprimiertes Archiv" },

            { flag: "Umleitung", description: "--- Umleitung & Pipes ---" },
            { flag: ">", description: "überschreibt Datei (stdout)" },
            { flag: ">>", description: "hängt an Datei an (stdout)" },
            { flag: "2>", description: "leitet stderr um" },
            { flag: "2>&1", description: "leitet stderr auf stdout" },
            { flag: "|", description: "Pipe - leitet stdout als stdin weiter" },
            { flag: "|&", description: "Pipe stdout+stderr" },
          ],
          pitfalls: [
            "Flags ohne Anführungszeichen bei Mustern (find -name *.log) expandieren durch die Shell.",
            "Rekursive Flags (-R, -r) mit Löschoperationen sind extrem gefährlich - immer zuerst testen!",
            "rm -f kombiniert mit Wildcards kann unbeabsichtigt alles löschen.",
            "> überschreibt Dateien sofort - bei Logs immer >> verwenden.",
          ],
          examples: [
            {
              command: "ls -lah /var/log",
              note: "Alle Dateien mit Details und versteckte Einträge - ideal für Fehlersuche.",
            },
            {
              command: "find . -name '*.log' -print0 | xargs -0 rm",
              note: "Sicheres Löschen auch bei Leerzeichen in Dateinamen.",
            },
            {
              command: "mkdir -p projects/2025/january",
              note: "Erstellt verschachtelte Verzeichnisse in einem Schritt.",
            },
            {
              command: "command > all.log 2>&1",
              note: "Leitet stdout und stderr in dieselbe Datei um.",
            },
          ],
          quizId: "flags_overview",
        },
      };

      const baseCheatSheetCategories = {
        fileHandling: {
          id: "fileHandling",
          name: "Datei-Handling",
          icon: "📂",
          colorClass: "badge-operator",
          matchers: [
            "ls",
            "cp",
            "mv",
            "rm",
            "mkdir",
            "touch",
            "cat",
            "grep",
            "sort",
            "uniq",
            "find",
            "tree",
            "head",
            "tail",
            "wc",
            "redirect",
            "nano",
          ],
          quizIds: [],
        },
        processManagement: {
          id: "processManagement",
          name: "Prozess-Management",
          icon: "🧠",
          colorClass: "badge-connoisseur",
          matchers: [
            "ps",
            "top",
            "kill",
            "jobs",
            "fg",
            "bg",
            "chmod",
            "chown",
            "chgrp",
            "whoami",
          ],
          quizIds: [],
        },
        networking: {
          id: "networking",
          name: "Netzwerk",
          icon: "🌐",
          colorClass: "badge-navigator",
          matchers: ["ssh", "wget", "curl", "netcat", "nc", "ping", "hydra"],
          quizIds: [],
        },
        systemInfo: {
          id: "systemInfo",
          name: "System & Monitoring",
          icon: "🖥️",
          colorClass: "badge-voyer",
          matchers: ["pwd", "cd", "history", "whoami", "df", "du", "pipe"],
          quizIds: [],
        },
        misc: {
          id: "misc",
          name: "Allgemein",
          icon: "✨",
          colorClass: "badge-morelinux",
          matchers: [],
          quizIds: [],
        },
      };

      // Haupt-Badge-Konfiguration (5 zentrale Kompetenz-Badges)
      const mainBadges = [
        {
          id: "badge-file",
          categoryKey: "fileHandling",
          segmentFilters: ["segment2", "segment3", "segment5"],
        },
        {
          id: "badge-process",
          categoryKey: "processManagement",
          segmentFilters: ["segment4"],
        },
        {
          id: "badge-network",
          categoryKey: "networking",
          segmentFilters: [],
        },
        {
          id: "badge-system",
          categoryKey: "systemInfo",
          segmentFilters: ["segment1"],
        },
        {
          id: "badge-misc",
          categoryKey: "misc",
          segmentFilters: [],
        },
      ].map((badge, index) => ({
        ...badge,
        name: baseCheatSheetCategories[badge.categoryKey].name,
        icon: baseCheatSheetCategories[badge.categoryKey].icon,
        colorClass:
          baseCheatSheetCategories[badge.categoryKey].colorClass ||
          [
            "badge-voyer",
            "badge-operator",
            "badge-connoisseur",
            "badge-navigator",
            "badge-morelinux",
          ][index],
      }));

      // Legacy mainBadges mit segments für Kompatibilität
      const legacyMainBadges = [
        {
          id: "linux_voyer",
          name: "Linux Voyer",
          icon: "👁️",
          colorClass: "badge-voyer",
          subSegments: ["segment4", "segment5"], // System & Rechte + Erweiterte Techniken
          segments: [
            {
              id: "segment4",
              name: "System & Rechte",
              icon: "🔐",
              colorClass: "segment-4",
              quizIds: [
                "whoami",
                "chmod",
                "chmod_R",
                "chown",
                "chgrp",
                "touch",
                "head",
                "tail",
                "wc_l",
                "wc_w",
              ],
            },
            {
              id: "segment5",
              name: "Erweiterte Techniken",
              icon: "⚙️",
              colorClass: "segment-5",
              quizIds: ["redirect", "nano_flow"],
            },
          ],
        },
        {
          id: "linux_operator",
          name: "Linux Operator",
          icon: "⚙️",
          colorClass: "badge-operator",
          subSegments: ["segment2"], // Dateioperationen & Suche
          segments: [
            {
              id: "segment2",
              name: "Dateioperationen & Suche",
              icon: "🔍",
              colorClass: "segment-2",
              quizIds: [
                "cp_r",
                "rm",
                "rm_r",
                "cat",
                "grep",
                "sort",
                "sort_n",
                "uniq",
                "find_name",
                "find_maxdepth",
              ],
            },
          ],
        },
        {
          id: "cli_connoisseur",
          name: "CLI-Konnoisseur",
          icon: "🎯",
          colorClass: "badge-connoisseur",
          subSegments: ["segment3"], // Auflistung & Umleitung
          segments: [
            {
              id: "segment3",
              name: "Auflistung & Umleitung",
              icon: "📋",
              colorClass: "segment-3",
              quizIds: [
                "ls_R",
                "ls_aR",
                "tree",
                "tree_d",
                "tree_L",
                "echo",
                "redirect_overwrite",
                "redirect_append",
                "redirect_stderr",
                "pipe",
              ],
            },
          ],
        },
        {
          id: "linux_navigator",
          name: "Linux Navigator",
          icon: "🧭",
          colorClass: "badge-navigator",
          subSegments: ["segment1"], // Navigation & Grundlagen
          segments: [
            {
              id: "segment1",
              name: "Navigation & Grundlagen",
              icon: "🧭",
              colorClass: "segment-1",
              quizIds: [
                "pwd",
                "cd",
                "cd_parent",
                "ls",
                "ls_a",
                "ls_la",
                "mkdir",
                "mkdir_p",
                "mv",
                "cp",
              ],
            },
          ],
        },
        {
          id: "morelinux",
          name: "MoreLinux",
          icon: "👑",
          colorClass: "badge-morelinux",
          subSegments: [], // Bisheriges Linux Master
          segments: [],
        },
      ];

      // Legacy badgeSegments für Kompatibilität (wird später entfernt)
      const badgeSegments = [
        {
          id: "segment1",
          name: "Navigation & Grundlagen",
          icon: "🧭",
          colorClass: "segment-1",
          quizIds: [
            "pwd",
            "cd",
            "cd_parent",
            "ls",
            "ls_a",
            "ls_la",
            "mkdir",
            "mkdir_p",
            "mv",
            "cp",
          ],
        },
        {
          id: "segment2",
          name: "Dateioperationen & Suche",
          icon: "🔍",
          colorClass: "segment-2",
          quizIds: [
            "cp_r",
            "rm",
            "rm_r",
            "cat",
            "grep",
            "sort",
            "sort_n",
            "uniq",
            "find_name",
            "find_maxdepth",
          ],
        },
        {
          id: "segment3",
          name: "Auflistung & Umleitung",
          icon: "📋",
          colorClass: "segment-3",
          quizIds: [
            "ls_R",
            "ls_aR",
            "tree",
            "tree_d",
            "tree_L",
            "echo",
            "redirect_overwrite",
            "redirect_append",
            "redirect_stderr",
            "pipe",
          ],
        },
        {
          id: "segment4",
          name: "System & Rechte",
          icon: "🔐",
          colorClass: "segment-4",
          quizIds: [
            "whoami",
            "chmod",
            "chmod_R",
            "chown",
            "chgrp",
            "touch",
            "head",
            "tail",
            "wc_l",
            "wc_w",
          ],
        },
        {
          id: "segment5",
          name: "Erweiterte Techniken",
          icon: "⚙️",
          colorClass: "segment-5",
          quizIds: ["redirect", "nano_flow"],
        },
        {
          id: "segment6",
          name: "Fortgeschrittene Workflows",
          icon: "🚀",
          colorClass: "segment-6",
          quizIds: ["xargs", "tee", "tar"],
        },
      ];

      // Mache Daten global verfügbar für quiz.html
      window.quizData = quizData;
      window.badgeSegments = badgeSegments;

      // Speichere Daten auch in sessionStorage für quiz.html
      try {
        sessionStorage.setItem("quizDataCache", JSON.stringify(quizData));
        sessionStorage.setItem("badgeSegmentsCache", JSON.stringify(badgeSegments));
      } catch (e) {
        console.warn("Konnte Daten nicht in sessionStorage speichern:", e);
      }

      // Masterquiz-Daten
      const masterQuizData = {
        segment1: {
          title: "Masterquiz: Navigation & Grundlagen",
          scenario:
            "Du bist Systemadministrator und musst ein Backup-System für tägliche Dokumente einrichten. Das Backup-Verzeichnis soll mit dem aktuellen Datum benannt werden, und alle wichtigen Dateien sollen automatisch gesichert werden.",
          question:
            "Du musst ein tägliches Backup-System erstellen. Welche Befehlssequenz erstellt ein Backup-Verzeichnis mit dem aktuellen Datum, kopiert alle `.txt`-Dateien dorthin, wechselt in das Backup-Verzeichnis und zeigt den aktuellen Pfad an?",
          options: [
            "mkdir backups/$(date +%Y-%m-%d) && cp *.txt backups/$(date +%Y-%m-%d)/ && cd backups/$(date +%Y-%m-%d) && pwd",
            "cd backups && mkdir $(date +%Y-%m-%d) && cp *.txt",
            "mkdir -p backups && cp *.txt backups/ && pwd",
            "ls -la backups/$(date +%Y-%m-%d)",
          ],
          correctIndex: 0,
          explanation:
            "Die Sequenz nutzt `mkdir` für das Verzeichnis (mit Datum), kopiert alle `.txt`-Dateien, wechselt ins Backup-Verzeichnis und zeigt den Pfad mit `pwd`. Die Kombination aus `mkdir`, `cp`, `cd` und `pwd` ist essentiell.",
        },
        segment2: {
          title: "Masterquiz: Dateioperationen & Suche",
          scenario:
            "Du musst eine Log-Analyse durchführen: Finde alle `.log`-Dateien im aktuellen Verzeichnisbaum, filtere nach Fehler-Einträgen, entferne Duplikate und erstelle eine sortierte Zusammenfassung.",
          question:
            'Du musst alle Fehlermeldungen aus Log-Dateien extrahieren. Welche Befehlssequenz findet alle `.log`-Dateien, sucht nach "ERROR", sortiert die Ergebnisse, entfernt Duplikate und zählt die eindeutigen Treffer?',
          options: [
            'find . -name "*.log" | grep "ERROR" | sort | uniq | wc -l',
            'find . -name "*.log" -type f -exec grep "ERROR" {} \\; | sort | uniq | wc -l',
            'grep -r "ERROR" *.log | sort | uniq',
            'cat *.log | grep "ERROR" | sort',
          ],
          correctIndex: 1,
          explanation:
            "`find` sucht rekursiv nach `.log`-Dateien, `-exec grep` durchsucht jede gefundene Datei, `sort` sortiert die Ergebnisse, `uniq` entfernt Duplikate, und `wc -l` zählt die Zeilen. Die Kombination aus `find`, `grep`, `sort` und `uniq` ist typisch für Log-Analysen.",
        },
        segment3: {
          title: "Masterquiz: Auflistung & Umleitung",
          scenario:
            "Du richtest ein Logging-System für eine Anwendung ein. Die Anwendung soll ihre Ausgaben in eine Logdatei schreiben, Fehler sollen separat gespeichert werden, und du musst die Verzeichnisstruktur dokumentieren.",
          question:
            "Du richtest ein Logging-System ein. Welche Befehlssequenz erstellt die Verzeichnisstruktur `logs/app`, schreibt eine Startnachricht mit Datum in die Logdatei, und dokumentiert die Verzeichnisstruktur (Fehler sollen in eine separate Datei)?",
          options: [
            'mkdir logs/app && echo "$(date)" >> logs/app/application.log && tree -L 2 logs/ > structure.txt 2> errors.log',
            'mkdir -p logs/app && echo "$(date): Started" >> logs/app/application.log && tree -L 2 logs/ > logs/app/structure.txt 2> logs/app/errors.log',
            'cd logs && mkdir app && echo "Started" > application.log',
            'tree logs/ > structure.txt && echo "Started" >> application.log',
          ],
          correctIndex: 1,
          explanation:
            "`mkdir -p` erstellt die Struktur, `echo` mit `>>` hängt an (ideal für Logs), `tree -L 2` zeigt die Struktur begrenzt, und `2>` leitet Fehler separat um. Die Kombination aus `echo`, `>>`, `2>`, und `tree` ist typisch für Logging-Setups.",
        },
        segment4: {
          title: "Masterquiz: System & Rechte",
          scenario:
            "Du installierst ein Web-Server-Script und musst sicherstellen, dass es mit den richtigen Berechtigungen läuft. Das Script muss ausführbar sein, und du musst prüfen, wer es ausführt.",
          question:
            "Du installierst ein Web-Server-Script. Welche Sequenz erstellt das Script, setzt die Rechte auf 755 (Besitzer: rwx, Gruppe/Andere: rx), ändert Besitzer und Gruppe auf www-data, und prüft, wer es ausführen würde?",
          options: [
            "touch deploy.sh && chmod 755 deploy.sh && sudo chown www-data:www-data deploy.sh && whoami",
            "chmod +x deploy.sh && chown www-data deploy.sh",
            "touch deploy.sh && chmod 777 deploy.sh && whoami",
            "mkdir deploy.sh && chmod 755 deploy.sh",
          ],
          correctIndex: 0,
          explanation:
            "`touch` erstellt die Datei, `chmod 755` setzt die Standard-Web-Server-Rechte, `chown user:group` ändert Besitzer und Gruppe, und `whoami` prüft den aktuellen Benutzer. Die Kombination aus `touch`, `chmod`, `chown` und `whoami` ist essentiell für sichere Script-Installationen.",
        },
      };

      const commandCards = Array.from(
        document.querySelectorAll(".command-card")
      );
      // Map visible category text to normalized category keys and add category classes
      (function assignCategoryClasses() {
        const categoryMap = {
          Navigation: "navigation",
          Auflisten: "listing",
          Suche: "search",
          Pipes: "pipes",
          Umleitung: "redirect",
          Workflow: "workflow",
          Dateien: "files",
          System: "system",
          Rechte: "permissions",
        };
        commandCards.forEach((card) => {
          const tagEl = card.querySelector(".command-tag");
          if (!tagEl) return;
          const raw = tagEl.textContent.trim();
          const key =
            categoryMap[raw] || raw.toLowerCase().replace(/\s+/g, "-");
          card.classList.add("category-" + key);
        });
      })();

      const quizRoot = document.getElementById("quiz-root");

      const commandModalTitle = document.getElementById("command-modal-title");
      const commandModalSubtitle = document.getElementById(
        "command-modal-subtitle"
      );
      const commandModalSummary = document.getElementById(
        "command-modal-summary"
      );
      const commandModalFlags = document.getElementById("command-modal-flags");
      const commandModalPitfalls = document.getElementById(
        "command-modal-pitfalls"
      );
      const commandModalExamples = document.getElementById(
        "command-modal-examples"
      );
      const commandModalCloseBtn = document.getElementById(
        "command-modal-close-btn"
      );
      const commandModalFeedback = document.getElementById(
        "command-modal-feedback"
      );

      // Modal Controller Dependencies
      let activeFocusTrap = null;

      function activateFocusTrap(modal, { onEscape } = {}) {
        const focusableSelectors =
          'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';
        const focusables = Array.from(
          modal.querySelectorAll(focusableSelectors)
        ).filter((el) => !el.hasAttribute("disabled"));
        if (focusables.length === 0) return;

        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const previous = document.activeElement;

        function handleKeydown(event) {
          if (event.key === "Tab") {
            if (focusables.length === 1) {
              event.preventDefault();
              first.focus();
              return;
            }
            if (event.shiftKey && document.activeElement === first) {
              event.preventDefault();
              last.focus();
            } else if (!event.shiftKey && document.activeElement === last) {
              event.preventDefault();
              first.focus();
            }
          } else if (event.key === "Escape" && typeof onEscape === "function") {
            event.preventDefault();
            onEscape();
          }
        }

        modal.addEventListener("keydown", handleKeydown);
        first.focus();
        activeFocusTrap = { modal, handleKeydown, previous };
      }

      function releaseFocusTrap(modal) {
        if (!activeFocusTrap) return;
        const { modal: trappedModal, handleKeydown, previous } = activeFocusTrap;
        if (modal && trappedModal !== modal) return;
        trappedModal.removeEventListener("keydown", handleKeydown);
        if (previous && typeof previous.focus === "function") {
          previous.focus();
        }
        activeFocusTrap = null;
      }

      // Zentraler Modal-Controller für konsistente Steuerung aller Modale
      const modalController = (() => {
        const registry = new Map();
        const openStack = [];

        function register(key, config) {
          const root = document.getElementById(config.rootId);
          if (!root) {
            console.warn(`[ModalController] Root not found for ${key}`);
            return;
          }

          const entry = {
            key,
            root,
            closeButtons: config.closeButtons || [],
            closeOnBackdrop: config.closeOnBackdrop !== false,
            closeOnEscape: config.closeOnEscape !== false,
            trapFocus: Boolean(config.trapFocus),
            onOpen: config.onOpen || null,
            onClose: config.onClose || null,
          };

          entry.closeButtons.forEach((btnId) => {
            const btn = document.getElementById(btnId);
            if (btn) btn.addEventListener("click", () => close(key));
          });

          if (entry.closeOnBackdrop) {
            root.addEventListener("click", (event) => {
              const isBackdrop =
                event.target === root ||
                event.target.classList.contains("quiz-backdrop");
              if (isBackdrop) {
                close(key);
              }
            });
          }

          registry.set(key, entry);
        }

        function open(key, context) {
          const entry = registry.get(key);
          if (!entry) return;

          if (typeof entry.onOpen === "function") {
            entry.onOpen(context);
          }

          entry.root.classList.remove("hidden");
          entry.root.setAttribute("aria-hidden", "false");

          if (entry.trapFocus) {
            activateFocusTrap(entry.root, {
              onEscape: entry.closeOnEscape ? () => close(key) : null,
            });
          }

          if (!openStack.includes(key)) {
            openStack.push(key);
          }
        }

        function close(key) {
          const entry = registry.get(key);
          if (!entry) return;

          if (activeFocusTrap?.modal === entry.root) {
            releaseFocusTrap(entry.root);
          }

          entry.root.classList.add("hidden");
          entry.root.setAttribute("aria-hidden", "true");

          if (typeof entry.onClose === "function") {
            entry.onClose();
          }

          const idx = openStack.indexOf(key);
          if (idx !== -1) openStack.splice(idx, 1);
        }

        function handleEscape(event) {
          if (event.key !== "Escape" || openStack.length === 0) return;
          for (let i = openStack.length - 1; i >= 0; i--) {
            const entry = registry.get(openStack[i]);
            if (entry && entry.closeOnEscape) {
              event.preventDefault();
              close(entry.key);
              break;
            }
          }
        }

        document.addEventListener("keydown", handleEscape);

        return {
          register,
          open,
          close,
          getRoot: (key) => registry.get(key)?.root || null,
        };
      })();

      // Register all modal roots with the central modal controller
      modalController.register("quiz", {
        rootId: "quiz-root",
        closeButtons: ["quiz-close-btn", "quiz-close-btn-back"],
        closeOnBackdrop: true,
        closeOnEscape: true,
        onClose: () => resetQuizUI(),
      });

      modalController.register("command", {
        rootId: "command-modal-root",
        closeButtons: ["command-modal-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
        trapFocus: true,
      });

      modalController.register("masterQuiz", {
        rootId: "master-quiz-root",
        closeButtons: ["master-quiz-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
        onClose: () => {
          const feedbackEl = document.getElementById("master-quiz-feedback");
          if (feedbackEl) feedbackEl.textContent = "";
          currentMasterQuizSegment = null;
        },
      });

      modalController.register("hotkeys", {
        rootId: "hotkeys-root",
        closeButtons: ["hotkeys-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
      });

      modalController.register("kaliTools", {
        rootId: "kali-tools-root",
        closeButtons: ["kali-tools-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
      });

      modalController.register("mistakes", {
        rootId: "mistakes-root",
        closeButtons: ["mistakes-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
      });

      modalController.register("faq", {
        rootId: "faq-modal-root",
        closeButtons: ["faq-modal-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
      });

      modalController.register("modernTools", {
        rootId: "modern-tools-root",
        closeButtons: ["modern-tools-close-btn"],
        closeOnBackdrop: true,
        closeOnEscape: true,
      });

      modalController.register("kaliExampleOverlay", {
        rootId: "kali-tools-example-overlay",
        closeButtons: ["kali-tools-example-overlay-close"],
        closeOnBackdrop: true,
        closeOnEscape: true,
        trapFocus: true,
      });

      let currentQuizId = null;
      let activeFilterSegment = null; // Aktives Filter-Segment (null = kein Filter)
      let activeFilterAchievement = null; // Aktives Achievement-Filter (null = kein Filter)

      // Achievement System
      const achievements = [
        { threshold: 10, name: "Linux Voyeur", icon: "👁️", class: "badge-10" },
        {
          threshold: 20,
          name: "Linux Operator",
          icon: "⚙️",
          class: "badge-20",
        },
        {
          threshold: 30,
          name: "CLI Connoisseur",
          icon: "🎯",
          class: "badge-30",
        },
        {
          threshold: 40,
          name: "Linux Navigator",
          icon: "🧭",
          class: "badge-40",
        },
        { threshold: 50, name: "Linux Master", icon: "👑", class: "badge-50" },
        {
          threshold: 60,
          name: 'Linux Basics "it\'s something"',
          icon: "🏆",
          class: "badge-60",
        },
      ];

      function getTotalCorrectAnswers() {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return 0;
        try {
          const results = JSON.parse(stored);
          return Object.values(results).reduce((sum, count) => sum + count, 0);
        } catch {
          return 0;
        }
      }

      function isQuizCompleted(quizId) {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return false;

        try {
          const results = JSON.parse(stored);
          return results[quizId] === 3;
        } catch {
          return false;
        }
      }

      function saveQuizResult(quizId, correctCount) {
        const stored = localStorage.getItem("quizResults");
        let results = {};
        if (stored) {
          try {
            results = JSON.parse(stored);
          } catch {
            results = {};
          }
        }
        // Nur speichern, wenn alle Fragen richtig waren (3/3) und noch nicht gespeichert
        if (correctCount === 3 && !results[quizId]) {
          results[quizId] = correctCount;
          localStorage.setItem("quizResults", JSON.stringify(results));

          // Update badge progress
          updateBadgeProgress();

          return true; // New completion
        }
        return false; // Already completed or not all correct
      }

      // Migration: Convert quizResults to badgeProgress
      function migrateToBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (stored) return; // Already migrated

        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) {
          localStorage.setItem("badgeProgress", JSON.stringify({}));
          return;
        }

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Migration error:", e);
          localStorage.setItem("badgeProgress", JSON.stringify({}));
        }
      }

      // Get badge progress from localStorage
      function getBadgeProgress() {
        const stored = localStorage.getItem("badgeProgress");
        if (!stored) {
          migrateToBadgeProgress();
          return getBadgeProgress();
        }
        try {
          return JSON.parse(stored);
        } catch {
          return {};
        }
      }

      // Update badge progress based on quizResults
      function updateBadgeProgress() {
        const quizResults = localStorage.getItem("quizResults");
        if (!quizResults) return;

        try {
          const results = JSON.parse(quizResults);
          const badgeProgress = {};

          badgeSegments.forEach((segment) => {
            let count = 0;
            segment.quizIds.forEach((id) => {
              if (results[id] === 3) count++;
            });
            badgeProgress[segment.id] = count;
          });

          localStorage.setItem("badgeProgress", JSON.stringify(badgeProgress));
        } catch (e) {
          console.error("Update badge progress error:", e);
        }
      }

      // Get segment progress
      function getSegmentProgress(segmentId) {
        const progress = getBadgeProgress();
        return progress[segmentId] || 0;
      }

      // Check if master quiz is completed
      function isMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[segmentId] === true;
        } catch {
          return false;
        }
      }

      // Mark master quiz as completed
      function setMasterQuizCompleted(segmentId) {
        const stored = localStorage.getItem("masterQuizCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[segmentId] = true;
        localStorage.setItem("masterQuizCompleted", JSON.stringify(completed));
      }

      // Check if achievement master quiz is completed
      function isAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        if (!stored) return false;
        try {
          const completed = JSON.parse(stored);
          return completed[threshold] === true;
        } catch {
          return false;
        }
      }

      // Mark achievement master quiz as completed
      function setAchievementMasterCompleted(threshold) {
        const stored = localStorage.getItem("achievementMasterCompleted");
        let completed = {};
        if (stored) {
          try {
            completed = JSON.parse(stored);
          } catch {
            completed = {};
          }
        }
        completed[threshold] = true;
        localStorage.setItem(
          "achievementMasterCompleted",
          JSON.stringify(completed)
        );
      }

      // Get segment ID from achievement threshold
      function getSegmentIdFromThreshold(threshold) {
        const mapping = {
          10: "segment1",
          20: "segment2",
          30: "segment3",
          40: "segment4",
          50: "segment5",
          60: "segment6",
        };
        return mapping[threshold] || null;
      }

      // Get achievement threshold from segment ID
      function getAchievementThresholdFromSegment(segmentId) {
        const mapping = {
          segment1: 10,
          segment2: 20,
          segment3: 30,
          segment4: 40,
          segment5: 50,
          segment6: 60,
        };
        return mapping[segmentId] || null;
      }

      // Get all quiz IDs for an achievement threshold
      function getQuizIdsForAchievement(threshold) {
        const segmentMapping = {
          10: "segment1", // Linux Voyeur - Navigation & Grundlagen
          20: "segment2", // Linux Operator - Dateioperationen & Suche
          30: "segment3", // CLI Connoisseur - Auflistung & Umleitung
          40: "segment4", // Linux Navigator - System & Rechte
          50: "segment5", // Linux Master - Erweiterte Techniken
          60: "segment6", // Linux Basics - Fortgeschrittene Workflows
        };

        const segmentId = segmentMapping[threshold];
        if (segmentId) {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (segment) {
            return [...segment.quizIds]; // Return copy of quiz IDs for this segment
          }
        }

        // Fallback: return empty array
        return [];
      }

      // Check if all quizzes for an achievement are completed
      function areAllAchievementQuizzesCompleted(threshold) {
        const quizIds = getQuizIdsForAchievement(threshold);
        const stored = localStorage.getItem("quizResults");
        if (!stored) return false;

        try {
          const results = JSON.parse(stored);
          return quizIds.every((quizId) => results[quizId] === 3);
        } catch {
          return false;
        }
      }

      // Filter cards by achievement quiz IDs
      function filterCardsByAchievement(threshold) {
        if (threshold === null) {
          // Filter entfernen - alle Karten anzeigen (außer die durch Suche versteckten)
          const searchInput = document.getElementById("search-input");
          if (searchInput && searchInput.value.trim()) {
            // Suche ist aktiv, wird separat behandelt
            return;
          }
          commandCards.forEach((card) => {
            card.classList.remove("hidden");
          });
          // Segment-Filter auch zurücksetzen
          activeFilterSegment = null;
          updateBadgeDisplay();
          updateHeaderBadgeFilter();
          return;
        }

        const quizIds = getQuizIdsForAchievement(threshold);

        // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
        activeFilterSegment = null;
        updateBadgeDisplay();
        updateHeaderBadgeFilter();

        // Alle Karten durchgehen und entsprechend filtern
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          if (!quizId) return; // Skip cards without quiz ID

          const belongsToAchievement = quizIds.includes(quizId);
          // Wenn Karte zu Achievement gehört, anzeigen, sonst verstecken
          if (belongsToAchievement) {
            card.classList.remove("hidden");
          } else {
            card.classList.add("hidden");
          }
        });
      }

      function updateAchievements() {
        const totalCorrect = getTotalCorrectAnswers();
        const container = document.getElementById("achievements-container");
        const progressEl = document.getElementById("achievement-progress");

        if (!container || !progressEl) return;

        container.innerHTML = "";
        achievements.forEach((achievement) => {
          const isUnlocked = totalCorrect >= achievement.threshold;
          const isMasterCompleted = isAchievementMasterCompleted(
            achievement.threshold
          );
          const segmentId = getSegmentIdFromThreshold(achievement.threshold);

          const badge = document.createElement("div");
          let badgeClasses = `achievement-badge ${achievement.class} ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          if (isMasterCompleted) {
            badgeClasses += " golden";
          }

          badge.className = badgeClasses;
          badge.innerHTML = `<span class="achievement-icon">${achievement.icon}</span><span>${achievement.name}</span>`;

          // Click-Handler für alle Badges (auch gesperrte)
          badge.style.cursor = "pointer";
          const allQuizzesCompleted = isUnlocked
            ? areAllAchievementQuizzesCompleted(achievement.threshold)
            : false;

          if (isMasterCompleted) {
            badge.title = "Master-Quiz abgeschlossen! 🏆";
          } else if (allQuizzesCompleted) {
            badge.title = "Alle Quiz abgeschlossen! Klicken für Master-Quiz";
          } else if (isUnlocked) {
            badge.title = "Klicken um zugehörige Quiz anzuzeigen";
          } else {
            badge.title = `Noch gesperrt. Klicken um benötigte Quiz anzuzeigen (${achievement.threshold} Fragen nötig)`;
          }

          badge.addEventListener("click", () => {
            // Toggle Filter
            if (activeFilterAchievement === achievement.threshold) {
              // Filter entfernen
              activeFilterAchievement = null;
              filterCardsByAchievement(null);
            } else {
              // Filter setzen
              activeFilterAchievement = achievement.threshold;
              filterCardsByAchievement(achievement.threshold);

              // Wenn alle Quiz abgeschlossen sind, Master-Quiz anbieten
              if (isUnlocked && allQuizzesCompleted && segmentId) {
                setTimeout(() => {
                  if (
                    confirm(
                      `Alle Quiz für "${achievement.name}" sind abgeschlossen! Möchtest du das Master-Quiz starten?`
                    )
                  ) {
                    openMasterQuiz(segmentId);
                  }
                }, 100);
              }
            }

            // Segment-Filter zurücksetzen wenn Achievement-Filter aktiv
            if (activeFilterAchievement) {
              activeFilterSegment = null;
              updateBadgeDisplay();
              updateHeaderBadgeFilter();
            }
          });

          container.appendChild(badge);
        });

        progressEl.textContent = `Fortschritt: ${totalCorrect}/60 Fragen richtig beantwortet`;
      }

      let cheatSheetMap = null;

      function findCategoryKeyForQuiz(quizId) {
        const normalized = quizId.toLowerCase();
        const matchKey = Object.keys(baseCheatSheetCategories).find((key) => {
          const category = baseCheatSheetCategories[key];
          return (category.matchers || []).some((token) =>
            normalized.includes(token.toLowerCase())
          );
        });

        return matchKey || "misc";
      }

      function buildCheatSheetMap() {
        const categories = JSON.parse(JSON.stringify(baseCheatSheetCategories));
        Object.values(categories).forEach((category) => {
          category.quizIds = [];
        });

        const quizIds = new Set([
          ...Object.keys(quizData),
          ...commandCards.map((card) => card.dataset.quizId).filter(Boolean),
        ]);

        const quizToCategory = {};

        quizIds.forEach((quizId) => {
          const categoryKey = findCategoryKeyForQuiz(quizId);
          quizToCategory[quizId] = categoryKey;
          categories[categoryKey].quizIds.push(quizId);
        });

        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          if (!quizId) return;
          const categoryKey = quizToCategory[quizId] || "misc";
          card.dataset.cheatCategory = categoryKey;
        });

        cheatSheetMap = { categories, quizToCategory };
      }

      function getCategoryProgress(categoryKey) {
        if (!cheatSheetMap) buildCheatSheetMap();
        const category = cheatSheetMap.categories[categoryKey];
        if (!category) {
          return { completed: 0, total: 0, percentage: 0 };
        }

        const quizResults = localStorage.getItem("quizResults");
        let completed = 0;
        if (quizResults) {
          try {
            const results = JSON.parse(quizResults);
            category.quizIds.forEach((quizId) => {
              if (results[quizId] === 3) {
                completed++;
              }
            });
          } catch (e) {
            console.error(
              "Kategorie-Fortschritt konnte nicht berechnet werden:",
              e
            );
          }
        }

        const total = category.quizIds.length;
        const percentage =
          total > 0 ? Math.round((completed / total) * 100) : 0;

        return { completed, total, percentage };
      }

      // Berechne Fortschritt für ein Haupt-Badge basierend auf Cheat-Sheet-Kategorien
      function getMainBadgeProgress(mainBadge) {
        const categoryProgress = getCategoryProgress(mainBadge.categoryKey);
        if (categoryProgress.total > 0) {
          return {
            completed: categoryProgress.completed,
            total: categoryProgress.total,
            percentage: categoryProgress.percentage,
          };
        }

        // Legacy-Fallback über Segment-Definitionen
        const allQuizIds = [];
        (mainBadge.segments || []).forEach((segment) => {
          allQuizIds.push(...segment.quizIds);
        });

        if (allQuizIds.length === 0) {
          return {
            completed: 0,
            total: 0,
            percentage: 0,
          };
        }

        const quizResults = localStorage.getItem("quizResults");
        let totalCompleted = 0;
        if (quizResults) {
          try {
            const results = JSON.parse(quizResults);
            allQuizIds.forEach((quizId) => {
              if (results[quizId] === 3) {
                totalCompleted++;
              }
            });
          } catch (e) {
            console.error("Fallback-Badge-Fortschritt fehlgeschlagen:", e);
          }
        }

        return {
          completed: totalCompleted,
          total: allQuizIds.length,
          percentage:
            allQuizIds.length > 0
              ? Math.round((totalCompleted / allQuizIds.length) * 100)
              : 0,
        };
      }

      // Update Badge Display für neue Struktur
      function updateBadgeDisplay() {
        // Badges wurden entfernt - Funktion macht nichts mehr
        return;

        container.innerHTML = "";

        // Initialisiere Migration beim ersten Laden
        migrateToBadgeProgress();

        // Haupt-Badge Reihe
        const mainRow = document.createElement("div");
        mainRow.className = "main-badges-row";

        // Sub-Badges Reihe
        const subRow = document.createElement("div");
        subRow.className = "sub-badges-row";

        mainBadges.forEach((mainBadge) => {
          const progress = getMainBadgeProgress(mainBadge);

          const badge = document.createElement("div");
          badge.className = `main-badge ${mainBadge.colorClass}`;

          // Markiere aktives Badge
          if (
            activeFilterSegment &&
            mainBadge.segmentFilters.includes(activeFilterSegment)
          ) {
            badge.classList.add("active");
          }

          // Click-Handler für Filter-Funktion
          badge.addEventListener("click", () => {
            // Wenn bereits aktiv, Filter entfernen
            if (
              activeFilterSegment &&
              mainBadge.segmentFilters.includes(activeFilterSegment)
            ) {
              activeFilterSegment = null;
            } else {
              // Filter auf erstes Sub-Segment setzen
              if (mainBadge.segmentFilters.length > 0) {
                activeFilterSegment = mainBadge.segmentFilters[0];
              }
              activeFilterAchievement = null;
            }
            filterCardsBySegment();
            updateBadgeDisplay();
            updateHeaderBadgeFilter();
          });

          // Doppelklick-Handler für Master-Quiz (wenn alle Quiz abgeschlossen)
          if (
            progress.total > 0 &&
            progress.percentage === 100 &&
            mainBadge.segmentFilters.length > 0
          ) {
            badge.style.cursor = "pointer";
            badge.title = "Doppelklick für Master-Quiz";
            badge.addEventListener("dblclick", (e) => {
              e.stopPropagation();
              // Öffne Master-Quiz für erstes Sub-Segment
              if (mainBadge.segmentFilters.length > 0) {
                openMasterQuiz(mainBadge.segmentFilters[0]);
              }
            });
          } else {
            badge.title = `${mainBadge.name}: ${progress.completed}/${
              progress.total || "0"
            } Quiz abgeschlossen (${progress.percentage}%)`;
          }

          badge.innerHTML = `
                        <div class="main-badge-header">
                          <span class="main-badge-icon">${mainBadge.icon}</span>
                          <span class="main-badge-name">${mainBadge.name}</span>
                        </div>
                        <div class="main-badge-progress-container">
                          <div class="main-badge-progress-bar">
                            <div class="main-badge-progress-fill" style="width: ${
                              progress.percentage
                            }%"></div>
                          </div>
                          <div class="main-badge-progress-text">${
                            progress.completed
                          }/${progress.total || 0}</div>
                        </div>
                      `;

          mainRow.appendChild(badge);

          // Sub-Badge Container für dieses Haupt-Badge
          const subBadgeGroup = document.createElement("div");
          subBadgeGroup.className = "badge-group";
          const subBadgeContainer = document.createElement("div");
          subBadgeContainer.className = "sub-badge-container";

          // Füge Sub-Badges basierend auf segmentFilters hinzu
          if (mainBadge.segmentFilters && mainBadge.segmentFilters.length > 0) {
            mainBadge.segmentFilters.forEach((segmentId) => {
              const segment = badgeSegments.find((s) => s.id === segmentId);
              if (segment) {
                const subBadge = document.createElement("div");
                subBadge.className = `sub-badge ${segment.colorClass}`;
                subBadge.innerHTML = `
                              <span>${segment.icon}</span>
                              <span>${segment.name}</span>
                            `;
                subBadgeContainer.appendChild(subBadge);
              }
            });
          }

          subBadgeGroup.appendChild(subBadgeContainer);
          subRow.appendChild(subBadgeGroup);
        });

        container.appendChild(mainRow);
        container.appendChild(subRow);
      }

      // Filtere Kacheln nach Segment
      function filterCardsBySegment() {
        // Wenn Achievement-Filter aktiv ist, Segment-Filter ignorieren
        if (activeFilterAchievement) {
          return;
        }

        if (!activeFilterSegment) {
          // Kein Filter aktiv - alle Kacheln anzeigen (außer die, die durch Suche versteckt sind)
          commandCards.forEach((card) => {
            // Nur hidden entfernen, wenn es durch Segment-Filter gesetzt wurde
            // Die Suche wird separat behandelt
            const searchInput = document.getElementById("search-input");
            if (searchInput && searchInput.value.trim()) {
              // Wenn Suche aktiv ist, wird die Karte durch die Suchfunktion gefiltert
              return;
            }
            card.classList.remove("hidden");
          });
          return;
        }

        // Finde das aktive Segment
        const segment = badgeSegments.find((s) => s.id === activeFilterSegment);
        if (!segment) return;

        // Zeige nur Kacheln, die zu diesem Segment gehören
        commandCards.forEach((card) => {
          const quizId = card.dataset.quizId;
          const belongsToSegment = segment.quizIds.includes(quizId);
          card.classList.toggle("hidden", !belongsToSegment);
        });
      }

      // Erstelle und aktualisiere die Badge-Leiste im Header
      function updateHeaderBadgeFilter() {
        const container = document.getElementById("header-badge-filter");
        if (!container) return;

        container.innerHTML = "";

        // Zeige nur Segmente mit Quiz-IDs
        badgeSegments
          .filter((segment) => segment.quizIds && segment.quizIds.length > 0)
          .forEach((segment) => {
            // Wrapper für Badge-Item und Quiz-Button
            const wrapper = document.createElement("div");
            wrapper.className = "header-badge-item-wrapper";
            wrapper.setAttribute("data-segment-id", segment.id);

            const badgeItem = document.createElement("div");
            badgeItem.className = `header-badge-item ${segment.colorClass}`;
            if (activeFilterSegment === segment.id) {
              badgeItem.classList.add("active");
            }

            // Prüfe ob Badge gesättigt ist
            const badgeSaturated = localStorage.getItem("badgeSaturated");
            if (badgeSaturated) {
              try {
                const saturated = JSON.parse(badgeSaturated);
                if (saturated[segment.id]) {
                  badgeItem.classList.add("saturated");
                }
              } catch (e) {
                // Ignore parse errors
              }
            }

            badgeItem.innerHTML = `
                    <span>${segment.icon}</span>
                    <span>${segment.name}</span>
                  `;

            badgeItem.title = `Klicken um Kacheln nach "${segment.name}" zu filtern`;

            badgeItem.addEventListener("click", () => {
              // Toggle Filter
              if (activeFilterSegment === segment.id) {
                // Filter entfernen
                activeFilterSegment = null;
                activeFilterAchievement = null;
              } else {
                // Filter setzen
                activeFilterSegment = segment.id;
                activeFilterAchievement = null;
              }

              // Aktualisiere Anzeige
              updateHeaderBadgeFilter();
              filterCardsBySegment();
            });

            // Quiz-Button hinzufügen
            const quizBtn = document.createElement("button");
            quizBtn.className = "header-badge-quiz-btn";
            quizBtn.textContent = "Quiz";
            quizBtn.title = `Quiz für "${segment.name}" starten`;
            quizBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              window.location.href = `quiz.html?badge=${segment.id}`;
            });

            wrapper.appendChild(badgeItem);
            wrapper.appendChild(quizBtn);
            container.appendChild(wrapper);
          });
      }

      // Assign badges to cards
      function assignBadgeToCards() {
        badgeSegments.forEach((segment) => {
          segment.quizIds.forEach((quizId) => {
            const card = commandCards.find((c) => c.dataset.quizId === quizId);
            if (card) {
              const header = card.querySelector(".command-header");
              if (header && !header.querySelector(".badge-mini")) {
                const miniBadge = document.createElement("span");
                miniBadge.className = `badge-mini ${segment.colorClass}`;
                miniBadge.textContent = segment.icon;
                miniBadge.title = segment.name;
                header.insertBefore(miniBadge, header.firstChild);
              }
            }
          });
        });
        // Agent 4: FAQ-Badges hinzufügen
        showFaqBadgeOnCards();
      }

      // Agent 4: FAQ-Badge Integration
      function showFaqBadgeOnCards() {
        if (!faqData || !faqData.commandToFaqMap) return;

        commandCards.forEach((card) => {
          const commandId = card.dataset.command || card.dataset.quizId;
          if (!commandId) return;

          const hasFaq =
            faqData.commandToFaqMap[commandId] &&
            faqData.commandToFaqMap[commandId].length > 0;
          if (!hasFaq) return;

          const header = card.querySelector(".command-header");
          if (!header) return;

          // Prüfe ob Badge bereits existiert
          if (header.querySelector(".command-faq-badge")) return;

          const faqBadge = document.createElement("button");
          faqBadge.type = "button";
          faqBadge.className = "command-faq-badge";
          faqBadge.textContent = "❓";
          faqBadge.title = "FAQ verfügbar - Klicken für Details";
          faqBadge.setAttribute("aria-label", "FAQ verfügbar");
          faqBadge.dataset.commandId = commandId;

          faqBadge.addEventListener("click", (e) => {
            e.stopPropagation();
            handleFaqBadgeClick(commandId);
          });

          header.appendChild(faqBadge);
        });
      }

      function handleFaqBadgeClick(commandId) {
        if (!faqData || !faqData.commandToFaqMap) return;

        const faqIds = faqData.commandToFaqMap[commandId];
        if (faqIds && faqIds.length > 0) {
          closeCommandModal(); // Schließe Command Modal falls offen
          openFaqModal(null, faqIds[0]); // Öffne FAQ Modal und scrollt zur ersten FAQ
        }
      }

      // Open Master Quiz
      function openMasterQuiz(segmentId) {
        const masterQuiz = masterQuizData[segmentId];
        if (!masterQuiz) {
          console.warn("Kein Masterquiz für Segment:", segmentId);
          return;
        }

        const modal = modalController.getRoot("masterQuiz");
        const titleEl = document.getElementById("master-quiz-title");
        const bodyEl = document.getElementById("master-quiz-body");
        const feedbackEl = document.getElementById("master-quiz-feedback");

        if (!modal || !titleEl || !bodyEl) return;

        titleEl.textContent = masterQuiz.title;
        if (feedbackEl) feedbackEl.textContent = "";
        bodyEl.innerHTML = "";

        const scenarioDiv = document.createElement("div");
        scenarioDiv.className = "master-quiz-scenario";
        scenarioDiv.textContent = masterQuiz.scenario;
        bodyEl.appendChild(scenarioDiv);

        const questionDiv = document.createElement("div");
        questionDiv.className = "quiz-question";
        const optionsHTML = masterQuiz.options
          .map(
            (opt, idx) => `
              <label class="quiz-option" data-option-index="${idx}">
                <input type="radio" name="master-quiz-option" value="${idx}" />
                <span><code>${opt}</code></span>
              </label>
            `
          )
          .join("");
        questionDiv.innerHTML = `
          <div class="quiz-question-title">${masterQuiz.question}</div>
          <div class="quiz-options">
            ${optionsHTML}
          </div>
        `;

        const chickenBtn = document.createElement("button");
        chickenBtn.type = "button";
        chickenBtn.className = "quiz-chicken-btn";
        chickenBtn.textContent = "🐔 Lösung zeigen";
        chickenBtn.dataset.correctIndex = masterQuiz.correctIndex;
        chickenBtn.addEventListener("click", function () {
          const correctIdx = parseInt(this.dataset.correctIndex);
          const optionsDiv = questionDiv.querySelector(".quiz-options");
          const allLabels = optionsDiv.querySelectorAll("label");
          allLabels.forEach((label, labelIdx) => {
            if (labelIdx === correctIdx) {
              label.classList.add("highlight-correct");
              const radio = label.querySelector("input[type=radio]");
              if (radio) radio.checked = true;
            } else {
              label.classList.remove("highlight-correct");
            }
          });
          this.disabled = true;
          this.style.opacity = "0.5";
          this.style.cursor = "not-allowed";
        });
        questionDiv.appendChild(chickenBtn);
        bodyEl.appendChild(questionDiv);

        modalController.open("masterQuiz");
        currentMasterQuizSegment = segmentId;
      }

      function closeMasterQuiz() {
        modalController.close("masterQuiz");
      }

      // Parse Hotkeys Content
      // Parse Hotkeys Content
      function parseHotkeysContent() {
        return [
          {
            title: "Navigation & Bewegung",
            items: [
              {
                shortcut: "H, J, K, L",
                description: "Cursor/Navigation (vim-Style)",
              },
              {
                shortcut: "↑ / ↓ / ← / →",
                description: "Klassische Navigation",
              },
              {
                shortcut: "Ctrl + U / Ctrl + D",
                description: "Halbseite hoch/runter",
              },
              {
                shortcut: "Ctrl + B / Ctrl + F",
                description: "Ganze Seite hoch/runter",
              },
            ],
          },
          {
            title: "Dateien & Verzeichnisse",
            items: [
              { shortcut: "Tab", description: "Autocomplete" },
              {
                shortcut: "Ctrl + R",
                description: "Reverse Search (vergangene Befehle finden)",
              },
              {
                shortcut: "Ctrl + A",
                description: "Cursor an den Anfang der Zeile",
              },
              {
                shortcut: "Ctrl + E",
                description: "Cursor ans Ende der Zeile",
              },
              { shortcut: "Ctrl + W", description: "Vorheriges Wort löschen" },
              {
                shortcut: "Ctrl + K",
                description: "Alles rechts vom Cursor löschen",
              },
              { shortcut: "Ctrl + C", description: "Prozess abbrechen" },
              { shortcut: "Ctrl + Z", description: "Prozess pausieren" },
              { shortcut: "fg / bg", description: "Prozesse fortsetzen" },
            ],
          },
          {
            title: "Quality-of-Life-Improvements",
            items: [
              {
                shortcut: "alias",
                description: "Alias erstellen (z. B. alias ll='ls -la')",
              },
              {
                shortcut: "history",
                description: "History mit Zeitstempeln aktivieren",
              },
              {
                shortcut: "less",
                description: "Statt cat für lange Dateien nutzen",
              },
              {
                shortcut: "fzf",
                description: "Fuzzy Suche in Dateien + History",
              },
              {
                shortcut: "ripgrep (rg)",
                description: "Statt grep benutzen – deutlich schneller",
              },
            ],
          },
          {
            title: "Dateien & Navigation",
            items: [
              {
                shortcut: "nnn / ranger",
                description: "Visuelle Terminal-Dateimanager",
              },
              {
                shortcut: "zoxide",
                description: "Ultraschnelles Wechseln zwischen Verzeichnissen",
              },
              {
                shortcut: "bat",
                description: "Moderne cat-Alternative mit Syntax-Highlighting",
              },
              {
                shortcut: "fd",
                description: "Moderne, intuitive Alternative zu find",
              },
            ],
          },
          {
            title: "Skript-Workflow",
            items: [
              { shortcut: "#!/bin/bash", description: "Shell-Skripte starten" },
              { shortcut: "set -e", description: "Script stoppt bei Fehlern" },
              {
                shortcut: "chmod +x",
                description: "Skripte ausführbar machen",
              },
            ],
          },
          {
            title: "Produktivität",
            items: [
              {
                shortcut: "tmux",
                description: "Terminal in Sessions splitten",
              },
              { shortcut: "SSH-Keys", description: "Statt Passwort" },
              {
                shortcut: ".bashrc /.zshrc",
                description: "Custom prompts – schnelleres visuelles Feedback",
              },
            ],
          },
          {
            title: "Fehler vermeiden",
            items: [
              {
                shortcut: "--dry-run",
                description: "Optionen nutzen (wo verfügbar)",
              },
              {
                shortcut: "mv -i / cp -i / rm -i",
                description: "Interaktive Rückfrage aktivieren",
              },
              {
                shortcut: "Trash-CLI",
                description: "Statt sofortigem Löschen",
              },
            ],
          },
        ];
      }

      const beginnerMistakes = [
        {
          quizId: "rm_r",
          title: "Unbedachtes Löschen mit rm -r",
          description:
            "Ohne Pfad-Check oder Backup gelöschte Verzeichnisse sind weg. Nutze interaktive Abfragen in kritischen Pfaden.",
          example: "rm -r --interactive=once ~/Downloads/tmp",
          tip: "Vorher pwd && ls; bei produktiven Pfaden lieber Trash-CLI nutzen.",
          segmentClass: "segment-4",
        },
        {
          quizId: "mkdir_p",
          title: "Verzeichnistiefe ohne -p anlegen",
          description:
            "Ohne -p bricht mkdir bei fehlenden Elternverzeichnissen ab oder überschreibt nichts sichtbar.",
          example: "mkdir -p projects/demo/src",
          tip: "-p erstellt fehlende Ebenen sicher und ist idempotent.",
          segmentClass: "segment-1",
        },
        {
          quizId: "cp_r",
          title: "cp für Ordner ohne -r",
          description:
            "cp bricht bei Verzeichnissen ab, wenn -r fehlt – Ergebnis ist ein halbfertiger Kopiervorgang.",
          example: "cp -r site/ backup/site",
          tip: "Immer -r (oder -a für Rechte/Links) bei Ordnern setzen.",
          segmentClass: "segment-2",
        },
        {
          quizId: "mv",
          title: "mv mit falschem Zielpfad",
          description:
            "Ohne eindeutigen Zielpfad landen Dateien schnell im Arbeitsverzeichnis oder überschreiben Namen.",
          example: "mv notes.txt docs/notes.txt",
          tip: "Mit Tab-Completion prüfen, ob das Ziel existiert, und -i für Rückfragen nutzen.",
          segmentClass: "segment-3",
        },
        {
          quizId: "redirect_append",
          title: "Logs versehentlich überschrieben",
          description:
            "Ein einzelnes > leert Dateien sofort. Für Log- oder Messdaten immer >> verwenden.",
          example: 'echo "INFO: Start" >> logs/app.log',
          tip: "Vor dem Redirect Datei-Rechte prüfen und lieber append als overwrite.",
          segmentClass: "segment-5",
        },
        {
          quizId: "find_name",
          title: "find ohne Maskierung",
          description:
            "Ungequotete Patterns wie *.log expandieren durch die Shell und liefern falsche Treffer.",
          example: 'find . -name "*.log"',
          tip: "Muster immer in Anführungszeichen setzen und maxdepth nutzen, wenn nötig.",
          segmentClass: "segment-2",
        },
        {
          quizId: "grep",
          title: "grep nur auf einer Datei",
          description:
            "Ohne -R oder -n übersiehst du kontext und verschachtelte Treffer in Projekten.",
          example: 'grep -R "error" .',
          tip: "Mit -n Zeilennummern anzeigen und --color=auto für schnelle Sichtbarkeit.",
          segmentClass: "segment-1",
        },
        {
          quizId: "chmod_R",
          title: "chmod 777 als Allzwecklösung",
          description:
            "Zu breite Rechte öffnen Angriffsflächen. Setze nur benötigte Bits rekursiv und gezielt.",
          example: "chmod -R 640 secrets/",
          tip: "Vorher Besitzer prüfen und Rechte minimal halten (Principle of Least Privilege).",
          segmentClass: "segment-4",
        },
        {
          quizId: "chown",
          title: "Falscher Besitzer nach Deploy",
          description:
            "Dateien im falschen Account führen zu Permission-Denied oder Sicherheitslücken.",
          example: "sudo chown deploy:www-data /var/www/html -R",
          tip: "User:Gruppe immer explizit setzen und mit ls -l verifizieren.",
          segmentClass: "segment-3",
        },
        {
          quizId: "sort_n",
          title: "Lexikografisch statt numerisch sortiert",
          description:
            "Standard-sort ordnet Zahlen wie Strings (2 > 10). Für Metriken brauchst du -n/-k.",
          example: "sort -n -k2 metrics.txt",
          tip: "Mit -r für absteigend kombinieren und Spalten mit -k angeben.",
          segmentClass: "segment-6",
        },
      ];

      // Parse FAQ Data - Agent 1: Datenstruktur & Parsing
      function parseFaqData() {
        // FAQ-Kategorien basierend auf der FAQ-Datei
        const categories = [
          {
            id: "navigation",
            name: "Navigieren im Dateisystem",
            icon: "🧭",
            questions: [
              {
                id: "nav-001",
                question: "Wie wechsle ich in ein anderes Verzeichnis?",
                answer:
                  "Mit dem Befehl cd (change directory) kann man in ein gewünschtes Verzeichnis wechseln. Beispiel: cd Videos wechselt in den Unterordner Videos. Alternativ kann man auch den absoluten Pfad angeben, z. B. cd /home/kali/Documents/Videos.",
                relatedCommands: ["cd"],
                tags: ["cd", "verzeichnis", "navigation"],
              },
              {
                id: "nav-002",
                question: "Wie gelange ich in mein Home-Verzeichnis?",
                answer:
                  "Gibt man cd ohne Pfad an, wechselt man automatisch ins eigene Home-Verzeichnis. Dasselbe erreicht man mit cd ~ (Tilde steht für das Home-Verzeichnis).",
                relatedCommands: ["cd"],
                tags: ["cd", "home", "~"],
              },
              {
                id: "nav-003",
                question: "Wie wechsle ich ins Root-Verzeichnis (/)?",
                answer:
                  "Verwende cd /, um ins Wurzelverzeichnis des Dateisystems zu gelangen. Der Schrägstrich / steht in Linux für das Root-Verzeichnis (oberste Ebene des Dateisystems).",
                relatedCommands: ["cd"],
                tags: ["cd", "root", "/"],
              },
              {
                id: "nav-004",
                question: "Wie gehe ich eine Verzeichnisebene nach oben?",
                answer:
                  "Mit cd .. wechselt man in das übergeordnete Verzeichnis (ein Ordner nach oben). Die zwei Punkte .. stehen in Pfadangaben immer für das Parent-Verzeichnis.",
                relatedCommands: ["cd"],
                tags: ["cd", "parent", ".."],
              },
              {
                id: "nav-005",
                question: "Wie komme ich in das vorherige Verzeichnis zurück?",
                answer:
                  "Mit cd - wechselt man in das zuletzt besuchte Verzeichnis zurück. Dies ist praktisch, um schnell zwischen zwei Verzeichnissen hin- und herzuspringen.",
                relatedCommands: ["cd"],
                tags: ["cd", "vorherig", "-"],
              },
              {
                id: "nav-006",
                question:
                  "Wie kann ich mir mein aktuelles Verzeichnis anzeigen lassen?",
                answer:
                  "Der Befehl pwd (print working directory) zeigt den vollständigen Pfad des Verzeichnisses, in dem man sich befindet, an. Beispiel: Befindet sich der Benutzer kali im Ordner /home/kali/Desktop, dann zeigt pwd genau diesen Pfad an.",
                relatedCommands: ["pwd"],
                tags: ["pwd", "aktuelles", "verzeichnis"],
              },
              {
                id: "nav-007",
                question: "Wie liste ich den Inhalt eines Verzeichnisses auf?",
                answer:
                  "Mit ls werden Dateien und Unterordner im aktuellen Verzeichnis aufgelistet. Ohne Optionen zeigt ls die Namen der Inhalte. Beispielsweise listet ls /etc den Inhalt des /etc-Verzeichnisses auf.",
                relatedCommands: ["ls"],
                tags: ["ls", "auflisten", "verzeichnis"],
              },
              {
                id: "nav-008",
                question: "Wie kann ich auch versteckte Dateien anzeigen?",
                answer:
                  "Versteckte Dateien (deren Namen mit . beginnen) zeigt man mit ls -a an. Oft nutzt man ls -la für eine detaillierte Liste inklusive versteckter Dateien, da -l die lange Liste mit Rechten, Besitzer, Größe und Datum anzeigt.",
                relatedCommands: ["ls", "ls_a"],
                tags: ["ls", "-a", "versteckt"],
              },
              {
                id: "nav-009",
                question:
                  "Wie erhalte ich detaillierte Infos (Größe, Datum, Rechte) zu Dateien in einem Verzeichnis?",
                answer:
                  "Mit ls -l erhält man eine ausführliche Auflistung aller Dateien/Ordner mit Details wie Berechtigungen, Besitzer, Dateigröße und Änderungsdatum. Zusätzliche Optionen wie -h (human-readable) stellen Größen in lesbare Form (z. B. KiB/MiB) dar, also z. B. ls -lh.",
                relatedCommands: ["ls", "ls_la"],
                tags: ["ls", "-l", "-h", "details"],
              },
              {
                id: "nav-010",
                question: "Was bedeuten . und .. in Pfadangaben?",
                answer:
                  ". steht für das aktuelle Verzeichnis, .. für das übergeordnete Verzeichnis. Beispiel: cd . bleibt im aktuellen Ordner, und cd .. wechselt eine Ebene höher.",
                relatedCommands: ["cd"],
                tags: [".", "..", "pfad"],
              },
              {
                id: "nav-011",
                question:
                  "Wie navigiere ich in Pfaden mit Leerzeichen im Namen?",
                answer:
                  'Pfadnamen mit Leerzeichen müssen in Anführungszeichen gesetzt werden oder das Leerzeichen mit \\ maskiert werden. Beispiel: cd "Mein Ordner" oder cd Mein\\ Ordner wechselt in ein Verzeichnis namens "Mein Ordner".',
                relatedCommands: ["cd"],
                tags: ["pfad", "leerzeichen", "anführungszeichen"],
              },
              {
                id: "nav-012",
                question: "Gibt es eine Autovervollständigung für Dateinamen?",
                answer:
                  "Ja, durch Drücken der Tab-Taste während der Eingabe vervollständigt die Shell automatisch Dateinamen oder Befehle, sofern eindeutig. Dadurch muss man oft nur den Anfang eines Namens tippen und kann Tippfehler vermeiden (Tab-Autocompletion).",
                relatedCommands: [],
                tags: ["tab", "autocompletion"],
              },
            ],
          },
          {
            id: "fileManagement",
            name: "Dateiverwaltung (Dateien und Ordner)",
            icon: "📂",
            questions: [
              {
                id: "file-001",
                question: "Wie erstelle ich ein neues Verzeichnis?",
                answer:
                  "Mit mkdir <ordnername> erstellt man ein neues Verzeichnis. Beispiel: mkdir Projekte legt einen Ordner namens Projekte im aktuellen Verzeichnis an. Mit mkdir -p pfad/unterordner können auch verschachtelte Unterordner in einem Schritt erzeugt werden.",
                relatedCommands: ["mkdir", "mkdir_p"],
                tags: ["mkdir", "verzeichnis", "ordner"],
              },
              {
                id: "file-002",
                question: "Wie lösche ich einen Ordner?",
                answer:
                  "Leere Verzeichnisse können mit rmdir <ordnername> gelöscht werden. Enthält der Ordner Dateien oder Unterordner, verwendet man rm -r <ordnername> für rekursives Löschen. Vorsicht: Mit rm -r werden auch alle enthaltenen Dateien gelöscht. Für unwiederbringliches Löschen ohne Nachfragen kann zusätzlich -f (force) verwendet werden, z. B. rm -rf <ordner>.",
                relatedCommands: ["rm", "rm_r"],
                tags: ["rm", "rmdir", "löschen"],
              },
              {
                id: "file-003",
                question: "Wie lege ich eine neue (leere) Datei an?",
                answer:
                  "Der einfachste Weg ist touch <dateiname>. Wenn die angegebene Datei noch nicht existiert, wird durch touch eine leere Datei erstellt. Beispiel: touch notiz.txt erzeugt eine leere Datei notiz.txt.",
                relatedCommands: ["touch"],
                tags: ["touch", "datei", "erstellen"],
              },
              {
                id: "file-004",
                question: "Wie lösche ich eine Datei?",
                answer:
                  "Mit dem Befehl rm <datei> löscht man Dateien. Beispiel: rm test.txt löscht die Datei test.txt. Ohne weitere Optionen fragt rm in der Standardeinstellung nicht nach und entfernt die Datei endgültig.",
                relatedCommands: ["rm"],
                tags: ["rm", "löschen", "datei"],
              },
              {
                id: "file-005",
                question: "Wie kopiere ich eine Datei?",
                answer:
                  "Mit cp <quelle> <ziel> kopiert man eine Datei. Beispiel: cp original.txt kopie.txt erstellt eine Kopie von original.txt unter dem Namen kopie.txt im gleichen Verzeichnis. Um an einen anderen Ort zu kopieren, gibt man den Pfad zum Ziel an (z. B. cp datei.txt /tmp/).",
                relatedCommands: ["cp"],
                tags: ["cp", "kopieren"],
              },
              {
                id: "file-006",
                question: "Wie kopiere ich einen ganzen Ordner mit Inhalt?",
                answer:
                  "Mit dem Parameter -r kopiert cp auch Verzeichnisse rekursiv. Beispiel: cp -r bilder fotos_backup kopiert den gesamten Ordner bilder (mit allen Unterdateien/-ordnern) ins Verzeichnis fotos_backup.",
                relatedCommands: ["cp_r"],
                tags: ["cp", "-r", "rekursiv"],
              },
              {
                id: "file-007",
                question:
                  "Wie verschiebe oder benenne ich eine Datei/einen Ordner um?",
                answer:
                  "Das Verschieben erledigt man mit mv <quelle> <ziel>. Zum Umbenennen kann man mv im selben Verzeichnis nutzen: mv altername.txt neuername.txt ändert den Dateinamen. Verschieben in einen anderen Ordner funktioniert analog: mv datei.txt /pfad/zum/zielordner/.",
                relatedCommands: ["mv"],
                tags: ["mv", "verschieben", "umbenennen"],
              },
              {
                id: "file-008",
                question:
                  "Wie zeige ich den Inhalt einer Textdatei im Terminal an?",
                answer:
                  "Mit cat <datei> wird der gesamte Dateinhalt auf einmal angezeigt. Beispiel: cat info.txt druckt den Text der Datei info.txt auf die Konsole. Für lange Dateien ist less <datei> praktischer – damit kann man seitenweise blättern.",
                relatedCommands: ["cat"],
                tags: ["cat", "anzeigen", "datei"],
              },
              {
                id: "file-009",
                question:
                  "Wie bearbeite ich eine Textdatei direkt im Terminal?",
                answer:
                  "Dazu nutzt man einen Terminal-Texteditor wie nano oder vim. Für Einsteiger empfiehlt sich nano: nano <datei> öffnet die Datei im Nano-Editor. Unten werden die wichtigsten Steuerungstasten angezeigt (z. B. zum Speichern STRG+O, zum Beenden STRG+X). Alternativ kann man vi <datei> bzw. vim <datei> nutzen – Vim ist aber deutlich anspruchsvoller.",
                relatedCommands: ["nano_flow"],
                tags: ["nano", "vim", "editor"],
              },
              {
                id: "file-010",
                question: "Wie kann ich nach einer Datei suchen?",
                answer:
                  'Mit dem Befehl find lässt sich das Dateisystem durchsuchen. Beispiel: find / -name "*.conf" sucht unter / (dem Root-Verzeichnis) nach allen Dateien, die auf *.conf enden. Für eine schnelle Suche kann Kali auch locate <name> nutzen – dieses greift auf eine indexierte Datenbank zurück (vorher mit updatedb aktualisieren).',
                relatedCommands: ["find_name"],
                tags: ["find", "suchen"],
              },
              {
                id: "file-011",
                question: "Wie finde ich einen bestimmten Text in Dateien?",
                answer:
                  'Mit grep kann man in Dateien nach Textmustern suchen. Beispiel: grep "ERROR" /var/log/syslog sucht im System-Log nach Vorkommen von "ERROR". Standardmäßig gibt grep alle Zeilen aus, die den gesuchten Text enthalten.',
                relatedCommands: ["grep"],
                tags: ["grep", "text", "suchen"],
              },
              {
                id: "file-012",
                question:
                  "Wie erfahre ich den Dateityp oder Details einer Datei?",
                answer:
                  "Der Befehl file <datei> zeigt an, um welchen Dateityp es sich handelt (z. B. ASCII-Text, ELF-Binary etc.). Für ausführlichere Informationen, wie Größe, letztes Änderungsdatum, Berechtigungen, nutzt man stat <datei>, was alle Dateieigenschaften auflistet.",
                relatedCommands: [],
                tags: ["file", "stat", "dateityp"],
              },
            ],
          },
          {
            id: "packageManagement",
            name: "Paketmanagement (Software installieren/aktualisieren)",
            icon: "📦",
            questions: [
              {
                id: "pkg-001",
                question:
                  "Wie aktualisiere ich die Paketliste (Repository-Index)?",
                answer:
                  "Mit sudo apt update fragt man alle in /etc/apt/sources.list eingetragenen Paketquellen ab und lädt die neuesten Paketinformationen herunter. Dies sollte man regelmäßig tun, insbesondere bevor man neue Pakete installiert, damit die Paketdatenbank aktuell ist.",
                relatedCommands: [],
                tags: ["apt", "update", "paketliste"],
              },
              {
                id: "pkg-002",
                question:
                  "Wie aktualisiere ich installierte Pakete auf die neueste Version?",
                answer:
                  "Nach apt update kann man mit sudo apt upgrade alle installierten Pakete upgraden. Dieser Befehl spielt verfügbare Updates ein, ohne Pakete zu entfernen.",
                relatedCommands: [],
                tags: ["apt", "upgrade"],
              },
              {
                id: "pkg-003",
                question: "Wie installiere ich ein neues Programm/Paket?",
                answer:
                  "Mit sudo apt install <paketname>. Beispiel: sudo apt install nmap installiert das Paket nmap aus den Paketquellen. Man kann auch mehrere Pakete gleichzeitig installieren, indem man die Namen hintereinander angibt (getrennt durch Leerzeichen).",
                relatedCommands: [],
                tags: ["apt", "install"],
              },
              {
                id: "pkg-004",
                question: "Wie entferne ich ein installiertes Paket?",
                answer:
                  "Mit sudo apt remove <paketname> deinstalliert man ein Paket. Die Konfigurationsdateien bleiben dabei erhalten. Soll auch diese bereinigt werden, verwendet man sudo apt purge <paketname>, um das Paket komplett (inkl. Konfigurationsresten) zu entfernen.",
                relatedCommands: [],
                tags: ["apt", "remove", "purge"],
              },
              {
                id: "pkg-005",
                question: "Wie räume ich nicht mehr benötigte Pakete auf?",
                answer:
                  "Nach vielen Installationen bleiben manchmal ungenutzte Abhängigkeits-Pakete zurück. Mit sudo apt autoremove werden solche automatisch installierten, aber nicht mehr benötigten Pakete entfernt, um Speicherplatz freizugeben.",
                relatedCommands: [],
                tags: ["apt", "autoremove"],
              },
              {
                id: "pkg-006",
                question: "Wie suche ich nach Paketen?",
                answer:
                  'Mit apt search <schlüsselwort> kann man die Paketdatenbank nach Namen und Beschreibungen durchsuchen. Beispiel: apt search editor listet alle Pakete auf, die im Namen oder in der Beschreibung "editor" enthalten.',
                relatedCommands: [],
                tags: ["apt", "search"],
              },
              {
                id: "pkg-007",
                question: "Was ist der Unterschied zwischen apt und apt-get?",
                answer:
                  "apt ist ein etwas neueres Kommando, das viele häufig genutzte Funktionen von apt-get und apt-cache in einem Tool vereint. So entspricht z. B. apt install dem klassischen apt-get install. Für die meisten Anwendungsfälle kann man apt benutzen – es ist benutzerfreundlicher (z. B. Fortschrittsbalken).",
                relatedCommands: [],
                tags: ["apt", "apt-get"],
              },
            ],
          },
          {
            id: "networking",
            name: "Netzwerkgrundlagen",
            icon: "🌐",
            questions: [
              {
                id: "net-001",
                question:
                  "Wie finde ich meine IP-Adresse oder Netzwerk-Schnittstellen heraus?",
                answer:
                  "Der Befehl ifconfig (aus dem Paket net-tools) zeigt die konfigurierten Netzwerkinterfaces mit ihren IP-Adressen an. Unter neueren Linux-Systemen verwendet man bevorzugt ip a (oder ip addr), das ähnliche Informationen ausgibt.",
                relatedCommands: [],
                tags: ["ifconfig", "ip", "netzwerk"],
              },
              {
                id: "net-002",
                question:
                  "Wie teste ich die Erreichbarkeit eines anderen Hosts (Ping)?",
                answer:
                  "Mit ping <ziel> sendet man ICMP-Pakete an einen Host, um die Verbindung zu prüfen. Beispiel: ping google.com sendet kontinuierlich Pings an google.com. Eine erfolgreiche Antwort zeigt, dass Netzwerkverbindung besteht und gibt die Round-Trip-Zeit aus. Mit Ctrl+C bricht man den Vorgang ab.",
                relatedCommands: [],
                tags: ["ping", "netzwerk"],
              },
              {
                id: "net-003",
                question:
                  "Wie scanne ich einen Rechner oder ein Netzwerk nach offenen Ports (mit Nmap)?",
                answer:
                  "Nmap ist ein Port-Scanner. Ein einfacher Scan erfolgt mit nmap <IP-Adresse>. Beispielsweise führt nmap 192.168.0.5 einen Standard-Portscan der gängigsten 1000 Ports auf dem Host 192.168.0.5 durch und listet offene Ports samt Dienstnamen.",
                relatedCommands: [],
                tags: ["nmap", "portscan"],
              },
              {
                id: "net-004",
                question:
                  "Wie lade ich eine Datei per Kommandozeile aus dem Internet herunter?",
                answer:
                  "Einfache Methode: wget <URL>. Beispiel: wget https://kali.org/sample.iso lädt die Datei sample.iso aus dem Internet in das aktuelle Verzeichnis herunter. Alternativ kann curl -O <URL> verwendet werden.",
                relatedCommands: [],
                tags: ["wget", "curl", "download"],
              },
            ],
          },
          {
            id: "permissions",
            name: "Rechte und Berechtigungen",
            icon: "🔐",
            questions: [
              {
                id: "perm-001",
                question:
                  "Wie ändere ich Dateiberechtigungen (Lese/Schreib/Execute-Rechte)?",
                answer:
                  "Mit dem Befehl chmod kann man Unix-Dateirechte ändern. Man kann die Rechte entweder symbolisch (mit Buchstaben) oder numerisch (mit Oktalzahlen) angeben. Beispiel numerisch: chmod 755 script.sh setzt die Rechte auf rwxr-xr-x (Besitzer darf lesen/schreiben/ausführen =7, Gruppe und andere nur lesen/ausführen =5 und 5).",
                relatedCommands: ["chmod", "chmod_R"],
                tags: ["chmod", "rechte"],
              },
              {
                id: "perm-002",
                question: "Wie mache ich eine Datei ausführbar?",
                answer:
                  "Mit chmod +x <datei> fügt man das Ausführungsrecht (execute) für die Datei hinzu. Danach kann die Datei (z. B. ein Skript) direkt gestartet werden, etwa mit ./script.sh.",
                relatedCommands: ["chmod"],
                tags: ["chmod", "+x", "ausführbar"],
              },
              {
                id: "perm-003",
                question:
                  "Wie ändere ich den Besitzer einer Datei oder eines Ordners?",
                answer:
                  "Mit chown <benutzer>:<gruppe> <datei> ändert man den Eigentümer (Besitzer) und optional die Gruppe einer Datei. Beispiel: sudo chown kali:kali datei.txt ändert Besitzer und Gruppe von datei.txt auf den Benutzer kali.",
                relatedCommands: ["chown"],
                tags: ["chown", "besitzer"],
              },
              {
                id: "perm-004",
                question: "Wozu dient sudo und wie verwende ich es?",
                answer:
                  "sudo (substitute user do) erlaubt es, Befehle mit administrativen Rechten (als root) auszuführen. In Kali ist der Standarduser häufig schon root; existiert ein normaler Benutzer, muss man sudo voranstellen, um Systembefehle auszuführen, die erhöhte Rechte brauchen.",
                relatedCommands: [],
                tags: ["sudo", "root"],
              },
              {
                id: "perm-005",
                question:
                  'Was bedeutet die Fehlermeldung "Permission denied" und wie behebe ich sie?',
                answer:
                  '"Permission denied" heißt, dass die aktuellen Berechtigungen nicht ausreichen, um die gewünschte Aktion durchzuführen. Lösung: Entweder als root ausführen (Befehl mit sudo voranstellen) oder die Dateirechte anpassen. Beispiel: ./script.sh ergibt Permission denied, weil das Skript nicht ausführbar ist – hier hilft chmod +x script.sh.',
                relatedCommands: ["chmod"],
                tags: ["permission", "denied", "sudo"],
              },
            ],
          },
          {
            id: "shell",
            name: "Grundlagen der Shell (Bash & nützliche Hilfen)",
            icon: "💻",
            questions: [
              {
                id: "shell-001",
                question:
                  "Wie kann ich mir meine bisherigen Befehle anzeigen lassen (Befehls-Historie)?",
                answer:
                  'Mit dem Befehl history werden alle zuletzt eingegebenen Befehle der aktuellen Shell-Sitzung aufgelistet. Jeder Eintrag hat eine Nummer, und mit !<Nummer> kann man einen bestimmten Befehl erneut ausführen. Praktische Kürzel: !! wiederholt den letzten Befehl, !ls würde z. B. den letzten Befehl, der mit "ls" begann, erneut ausführen.',
                relatedCommands: [],
                tags: ["history", "befehle"],
              },
              {
                id: "shell-002",
                question: "Wie definiere ich eigene Kurzbefehle (Aliases)?",
                answer:
                  'Mit alias kann man ein Kürzel für einen längeren Befehl definieren. Syntax: alias kurz="langer Befehl mit Optionen". Beispiel: alias ll="ls -l --color=auto" definiert ll als Alias, der farbig und im Langformat listet. Nach Eingabe von ll führt die Shell dann ls -l --color=auto aus.',
                relatedCommands: [],
                tags: ["alias", "kurzbefehle"],
              },
              {
                id: "shell-003",
                question:
                  "Wie kann ich einen gerade laufenden Befehl abbrechen?",
                answer:
                  "Durch Drücken von Strg + C (Control + C) im Terminal wird das aktuelle Vordergrund-Programm sofort beendet. Dies sendet das SIGINT-Signal an den Prozess. Beispiel: Wenn ping endlos läuft, beendet Strg+C den Vorgang.",
                relatedCommands: [],
                tags: ["ctrl+c", "abbrechen"],
              },
            ],
          },
          {
            id: "errors",
            name: "Fehlermeldungen und ihre Behebung",
            icon: "⚠️",
            questions: [
              {
                id: "err-001",
                question:
                  'Fehlermeldung: "command not found" – was bedeutet das und was kann ich tun?',
                answer:
                  '"Command not found" bedeutet, dass die Shell den eingegebenen Befehl nicht finden konnte. Häufige Ursachen: Tippfehler im Befehlsnamen oder das Programm ist nicht installiert bzw. nicht im PATH. Zuerst sollte man prüfen, ob man sich nicht vertippt hat. Ist der Name korrekt, überprüft man mit which befehl, ob das Programm im Suchpfad liegt.',
                relatedCommands: [],
                tags: ["command", "not", "found"],
              },
              {
                id: "err-002",
                question:
                  'Fehlermeldung: "No such file or directory" – was läuft falsch?',
                answer:
                  "Diese Meldung bedeutet, dass eine angegebene Datei oder Pfad nicht existiert. Entweder wurde der Pfad falsch eingegeben (Tippfehler, Groß-/Kleinschreibung beachten, da Linux case-sensitiv ist) oder das Objekt ist tatsächlich nicht vorhanden. Lösung: Pfadangabe überprüfen (ls im betreffenden Verzeichnis ausführen, Tab-Autocomplete nutzen) und ggf. korrigieren.",
                relatedCommands: [],
                tags: ["no", "such", "file"],
              },
            ],
          },
          {
            id: "systemInfo",
            name: "Systeminformationen und -überwachung",
            icon: "🖥️",
            questions: [
              {
                id: "sys-001",
                question:
                  "Wie finde ich heraus, welche Linux-Version und Kernel-Version ich benutze?",
                answer:
                  "Mit uname -a erhält man einen Überblick über Systemname, Kernel-Version, Architektur usw. Für die Distribution kann man auch lsb_release -a verwenden, das z. B. Kali-Version und Codename anzeigt.",
                relatedCommands: [],
                tags: ["uname", "version"],
              },
              {
                id: "sys-002",
                question:
                  "Wie überwache ich die aktuelle Auslastung der CPU und des RAM?",
                answer:
                  "Mit top erhält man eine dynamische Live-Ansicht der laufenden Prozesse und ihrer CPU-/Speicherauslastung. Oben zeigt top außerdem Gesamtwerte für CPU (in %), RAM und Swap an. Ein besser lesbares, alternatives Tool ist htop (falls installiert).",
                relatedCommands: [],
                tags: ["top", "htop", "cpu", "ram"],
              },
              {
                id: "sys-003",
                question:
                  "Wie prüfe ich, wie viel Festplattenplatz belegt bzw. frei ist?",
                answer:
                  "Dafür verwendet man df -h. df (disk free) listet alle eingehängten Dateisysteme mit genutztem und freiem Speicherplatz; die Option -h zeigt die Werte in menschenlesbarer Form (KiB/ MiB/ GiB).",
                relatedCommands: [],
                tags: ["df", "festplatte"],
              },
            ],
          },
          {
            id: "tools",
            name: "Nützliche Tools und Befehle",
            icon: "🛠️",
            questions: [
              {
                id: "tool-001",
                question: "Wie verwende ich Nmap, um mein Netzwerk zu scannen?",
                answer:
                  "Nmap ist ein Netzwerkscanner. Einige Beispiele: Ping-Scan: nmap -sn 192.168.1.0/24 pingt ein ganzes Netz an und listet aktive Hosts. Port-Scan: nmap 192.168.1.100 scannt die häufigsten 1000 TCP-Ports auf Host .100. Service-/OS-Scan: nmap -sV -O 192.168.1.100 versucht, Dienste-Versionen und das Betriebssystem des Ziels zu erkennen.",
                relatedCommands: [],
                tags: ["nmap", "netzwerk"],
              },
              {
                id: "tool-002",
                question: "Wie bekomme ich Hilfe zu Befehlen (Man-Pages)?",
                answer:
                  "Linux bietet zu den meisten Befehlen Handbuchseiten. Mit man <befehl> öffnet man die Manual-Page zum jeweiligen Befehl. Diese enthalten Beschreibung, Aufrufsyntax, Optionen und oft Beispiele. Beispiel: man ls erklärt alle Optionen von ls. Mit Q verlässt man die man-Page wieder. Alternativ zeigen viele Befehle mit --help eine Kurzinfo an, z. B. ls --help.",
                relatedCommands: [],
                tags: ["man", "help"],
              },
            ],
          },
        ];

        // Erstelle commandToFaqMap automatisch aus relatedCommands
        const commandToFaqMap = {};
        categories.forEach((category) => {
          category.questions.forEach((question) => {
            question.relatedCommands.forEach((cmd) => {
              if (!commandToFaqMap[cmd]) {
                commandToFaqMap[cmd] = [];
              }
              commandToFaqMap[cmd].push(question.id);
            });
          });
        });

        return {
          categories,
          commandToFaqMap,
        };
      }

      // Initialisiere FAQ-Daten
      const faqData = parseFaqData();

      // Parse Kali Tools Content
      function parseKaliToolsContent() {
        return [
          {
            title: "Grund-Setup nach Installation",
            items: [
              {
                name: "System aktualisieren",
                command: "sudo apt update && sudo apt full-upgrade -y",
                description:
                  "Aktualisiert alle Pakete und das System auf den neuesten Stand.",
                benefit:
                  "Stellt sicher, dass alle Tools aktuell und sicherheitsrelevante Updates installiert sind.",
                example:
                  "Nach der Installation von Kali Linux sollte dies dein erster Befehl sein. Führt eine vollständige Systemaktualisierung durch und installiert alle verfügbaren Updates für maximalen Schutz und Kompatibilität.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Kali-Tweaks",
                command: "sudo kali-tweaks",
                description:
                  "Interaktives Konfigurationstool für Shell, Mirrors, VM-Optimierungen und Hardening.",
                benefit:
                  "Ermöglicht schnelle Systemoptimierung ohne manuelle Konfiguration mehrerer Dateien.",
                example:
                  "Öffnet ein interaktives Menü, in dem du Shell-Einstellungen (z.B. Zsh), Repository-Mirrors, VM-Optimierungen und Sicherheits-Hardening-Optionen konfigurieren kannst. Perfekt für eine schnelle Erstkonfiguration.",
                badgeRequired: null,
                difficulty: "easy",
              },
              {
                name: "Firewall einrichten (UFW)",
                command:
                  "sudo apt install ufw\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nsudo ufw enable",
                description:
                  "Konfiguriert eine einfache Firewall: blockiert eingehende, erlaubt ausgehende Verbindungen.",
                benefit:
                  "Grundlegender Schutz vor unerwünschten Netzwerkzugriffen während Pentesting-Aktivitäten.",
                example:
                  "Installiert und konfiguriert UFW (Uncomplicated Firewall): Blockiert standardmäßig alle eingehenden Verbindungen, erlaubt aber alle ausgehenden. Überprüfe den Status mit 'sudo ufw status'.",
                badgeRequired: null,
                difficulty: "easy",
              },
            ],
          },
          {
            title: "Wichtige Metapackages",
            items: [
              {
                name: "kali-linux-top10",
                command: "sudo apt install kali-linux-top10",
                description:
                  "Installiert die 10 wichtigsten Standardtools von Kali Linux in einem Paket.",
                benefit:
                  "Perfekt für Einsteiger – installiert automatisch die essentiellen Tools, die du am häufigsten brauchst.",
                example:
                  "Installiert in einem Schritt: Nmap, Wireshark, Metasploit, Aircrack-ng, Burp Suite, John the Ripper, Hydra, sqlmap, OWASP ZAP und Social Engineering Toolkit. Perfekt für den Start!",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-linux-default",
                command: "sudo apt install kali-linux-default",
                description:
                  "Vollständige Desktop-Grundausstattung mit allen Standardtools.",
                benefit:
                  "Ideal für eine komplette Kali-Installation mit allen wichtigen Tools auf einmal.",
                example:
                  "Installiert alle Standard-Pentesting-Tools die in Kali Linux enthalten sind. Ideal für eine vollständige Installation, benötigt aber mehr Speicherplatz und Zeit.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "kali-tools-web",
                command: "sudo apt install kali-tools-web",
                description:
                  "Tool-Sammlung speziell für Web-Pentesting und Web-Anwendungs-Tests.",
                benefit:
                  "Konzentriert alle Web-Testing-Tools an einem Ort – effizient für Web-Sicherheitstests.",
                example:
                  "Installiert Tools wie Burp Suite, OWASP ZAP, sqlmap, Nikto, dirb, wpscan und viele weitere Web-Pentesting-Tools. Ideal wenn du dich auf Web-Anwendungstests spezialisierst.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "kali-tools-802-11",
                command: "sudo apt install kali-tools-802-11",
                description:
                  "Tools für WLAN-Sicherheitstests und Wireless-Netzwerk-Analyse.",
                benefit:
                  "Unverzichtbar für Wireless-Pentesting – alles was du für WLAN-Tests brauchst.",
                example:
                  "Installiert Aircrack-ng Suite, Reaver, Wifite, Fern WiFi Cracker und weitere WLAN-Testing-Tools. Erfordert eine kompatible WLAN-Karte mit Monitor-Mode-Unterstützung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
              {
                name: "kali-tools-reverse-engineering",
                command: "sudo apt install kali-tools-reverse-engineering",
                description:
                  "Umfangreiche Toolsammlung für Reverse Engineering und Exploit-Entwicklung.",
                benefit:
                  "Für fortgeschrittene Sicherheitsforschung und Malware-Analyse essentiell.",
                example:
                  "Installiert Tools wie Ghidra, Radare2, IDA Free, Binary Ninja, APKTool, JD-GUI und weitere Reverse-Engineering-Tools. Für Malware-Analyse und Exploit-Entwicklung.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Netzwerk & Reconnaissance",
            items: [
              {
                name: "Nmap",
                command: "sudo apt install nmap",
                description:
                  "Der Standard-Portscanner zum Erkunden von Netzwerken und offenen Ports.",
                benefit:
                  "Das wichtigste Tool für Netzwerk-Reconnaissance – zeigt dir alle erreichbaren Dienste auf.",
                example:
                  "Beispiel: 'nmap -sV -p 80,443 192.168.1.1' scannt die Ports 80 und 443 auf einem Host und versucht die Dienstversionen zu identifizieren. 'nmap -sn 192.168.1.0/24' führt einen Ping-Scan eines ganzen Netzwerks durch.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "Wireshark",
                command: "sudo apt install wireshark",
                description:
                  "GUI-basierter Netzwerk-Protokoll-Analysator für tiefgreifende Traffic-Analyse.",
                benefit:
                  "Unverzichtbar zum Verstehen von Netzwerk-Kommunikation und zum Identifizieren von Anomalien.",
                example:
                  "Starte Wireshark mit 'wireshark' (GUI) oder verwende 'tshark' (CLI). Fange Traffic auf einer Netzwerkschnittstelle ab, filtere nach Protokollen (z.B. 'http' oder 'tcp.port == 80') und analysiere Pakete im Detail.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Web & Dienste",
            items: [
              {
                name: "Burp Suite Community",
                command: "sudo apt install burpsuite",
                description:
                  "HTTP/HTTPS-Proxy zum Abfangen und Manipulieren von Web-Anfragen.",
                benefit:
                  "Das Standard-Tool für Web-Pentesting – ermöglicht detaillierte Analyse und Exploitation von Web-Apps.",
                example:
                  "Starte Burp Suite mit 'burpsuite'. Konfiguriere deinen Browser auf localhost:8080 als Proxy. Alle HTTP/HTTPS-Requests werden abgefangen. Verwende den Repeater um Anfragen zu manipulieren, den Intruder für Bruteforce-Angriffe oder den Scanner für automatische Schwachstellensuche.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "sqlmap",
                command: "sudo apt install sqlmap",
                description:
                  "Automatisiertes Tool zum Testen und Exploitieren von SQL-Injection-Schwachstellen.",
                benefit:
                  "Spart enorm Zeit bei SQL-Injection-Tests und zeigt dir direkt verwertbare Exploits.",
                example:
                  "Beispiel: 'sqlmap -u \"http://example.com/page?id=1\" --dbs' testet auf SQL-Injection und listet Datenbanken auf. Mit '--dump -D database_name -T table_name' kannst du Tabellen auslesen. '--os-shell' versucht eine interaktive Shell zu erhalten.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "Exploitation",
            items: [
              {
                name: "Metasploit Framework",
                command: "sudo apt install metasploit-framework",
                description:
                  "Umfassendes Framework für Exploit-Entwicklung, -Testing und Post-Exploitation.",
                benefit:
                  "Das mächtigste Exploitation-Tool – bietet tausende vorgefertigte Exploits und Payloads.",
                example:
                  "Starte msfconsole mit 'msfconsole'. Suche nach Exploits mit 'search [dienst]', z.B. 'search apache'. Nutze einen Exploit mit 'use exploit/...', setze Parameter mit 'set RHOSTS 192.168.1.1', und führe aus mit 'exploit'. Mit 'show payloads' siehst du verfügbare Payloads.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Passwörter & Credentials",
            items: [
              {
                name: "Hydra",
                command: "sudo apt install hydra",
                description:
                  "Bruteforce-Tool für Passwörter und verschiedene Netzwerkdienste (SSH, FTP, HTTP, etc.).",
                benefit:
                  "Ermöglicht schnelles Testen von Login-Credentials gegen verschiedene Dienste.",
                example:
                  "Beispiel SSH: 'hydra -l admin -P passwords.txt ssh://192.168.1.1' testet das Passwort 'admin' mit einer Passwortliste. Für HTTP-Basic-Auth: 'hydra -l admin -P passwords.txt http-get://192.168.1.1/login'. Verwende 'hydra -h' für alle Optionen.",
                badgeRequired: "segment3",
                difficulty: "advanced",
              },
              {
                name: "John the Ripper",
                command: "sudo apt install john",
                description:
                  "Schneller Passwort-Cracker für offline Hash-Cracking und Passwort-Analyse.",
                benefit:
                  "Effizient beim Knacken gehashter Passwörter – unterstützt viele Hash-Algorithmen.",
                example:
                  "Speichere Hashes in einer Datei (z.B. hashes.txt). Verwende 'john hashes.txt' für Standard-Cracking. Mit 'john --wordlist=passwords.txt hashes.txt' verwendest du eine Passwortliste. 'john --show hashes.txt' zeigt geknackte Passwörter an.",
                badgeRequired: "segment4",
                difficulty: "advanced",
              },
            ],
          },
          {
            title: "WLAN (optional)",
            items: [
              {
                name: "Aircrack-ng Suite",
                command: "sudo apt install aircrack-ng",
                description:
                  "Komplett-Suite für WLAN-Sicherheitstests: Sniffing, Cracking, Angriffe auf WLAN-Netzwerke.",
                benefit:
                  "Das Standard-Tool für Wireless-Pentesting – von Netzwerk-Analyse bis Passwort-Cracking.",
                example:
                  "Workflow: 1) 'airmon-ng start wlan0' aktiviert Monitor-Mode, 2) 'airodump-ng wlan0mon' listet WLAN-Netzwerke, 3) 'airodump-ng -c [Kanal] --bssid [MAC] -w capture wlan0mon' fängt Handshakes ab, 4) 'aircrack-ng -w wordlist.txt capture.cap' crackt das Passwort. Benötigt kompatible WLAN-Karte.",
                badgeRequired: "segment5",
                difficulty: "expert",
              },
            ],
          },
          {
            title: "Shell & Workflow",
            items: [
              {
                name: "Zsh",
                command: "sudo apt install zsh",
                description:
                  "Erweiterte Shell mit besserer Autovervollständigung, Plugins und Themes.",
                benefit:
                  "Verbessert deine Produktivität drastisch – besonders mit Oh My Zsh für Customization.",
                example:
                  "Nach Installation: 'chsh -s $(which zsh)' setzt Zsh als Standard-Shell. Installiere Oh My Zsh mit: 'sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"'. Konfiguriere Plugins und Themes in ~/.zshrc.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "tmux",
                command: "sudo apt install tmux",
                description:
                  "Terminal-Multiplexer zum Splitten von Terminal-Fenstern und Session-Management.",
                benefit:
                  "Ermöglicht paralleles Arbeiten mit mehreren Terminal-Sessions – essentiell für komplexe Pentests.",
                example:
                  "Starte tmux mit 'tmux'. Tastenkombinationen (Standard-Präfix: Ctrl+b): Split horizontal 'C-b %', split vertikal 'C-b \"', wechsle zwischen Panes mit 'C-b Pfeiltasten', erstelle neues Fenster 'C-b c', liste Sessions 'tmux ls', attach Session 'tmux attach -t [name]'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Entwicklungsumgebung",
            items: [
              {
                name: "Git",
                command: "sudo apt install git",
                description:
                  "Versionskontroll-System für Code- und Script-Verwaltung.",
                benefit:
                  "Unverzichtbar für Organisierung deiner Exploits, Scripts und Pentesting-Tools.",
                example:
                  "Konfiguriere Git: 'git config --global user.name \"Dein Name\"' und 'git config --global user.email \"email@example.com\"'. Erstelle Repo: 'git init', füge Dateien hinzu: 'git add .', committe: 'git commit -m \"Message\"', klone Repos: 'git clone https://github.com/user/repo.git'.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
              {
                name: "curl",
                command: "sudo apt install curl",
                description:
                  "Kommandozeilen-Tool für HTTP/HTTPS-Anfragen und API-Testing.",
                benefit:
                  "Schnelle Möglichkeit Web-Requests zu testen und API-Endpunkte zu analysieren.",
                example:
                  "Einfacher GET-Request: 'curl http://example.com'. POST mit Daten: 'curl -X POST -d \"key=value\" http://example.com/api'. Mit Headers: 'curl -H \"Authorization: Bearer token\" http://example.com/api'. Output speichern: 'curl -o file.html http://example.com'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "build-essential",
                command: "sudo apt install build-essential",
                description:
                  "Grundlegende Compiler und Build-Tools (gcc, make, etc.) für Software-Kompilierung.",
                benefit:
                  "Benötigt um viele Exploits und Tools aus Source-Code zu kompilieren.",
                example:
                  "Enthält gcc (C-Compiler), g++ (C++-Compiler), make (Build-Automation) und weitere Entwickler-Tools. Nach Installation kannst du Source-Code kompilieren: 'gcc program.c -o program' oder 'make' in einem Projekt-Verzeichnis ausführen.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "Neovim",
                command: "sudo apt install neovim",
                description:
                  "Moderner Vim-Editor mit verbesserter Plugin-Unterstützung und Konfiguration.",
                benefit:
                  "Ermöglicht effizientes Scripting und Code-Editieren direkt im Terminal.",
                example:
                  "Starte Neovim mit 'nvim datei.txt'. Basis-Befehle: Insert-Mode 'i', Normal-Mode ESC, speichern und beenden ':wq', speichern ':w', beenden ohne speichern ':q!'. Erweitere mit Plugins über Plugin-Manager wie vim-plug in ~/.config/nvim/init.vim.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "kali-system-gui",
                command: "sudo apt install kali-system-gui",
                description:
                  "GUI-Werkzeuge und Desktop-Umgebungskomponenten für Kali Linux.",
                benefit:
                  "Stellt sicher, dass alle grafischen Tools und Desktop-Funktionen verfügbar sind.",
                example:
                  "Installiert alle GUI-Komponenten und Desktop-Umgebungstools für Kali Linux. Erforderlich wenn du grafische Tools wie Wireshark GUI, Burp Suite oder andere GUI-basierte Pentesting-Tools verwenden möchtest.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
          {
            title: "Netzwerk, VPN & Remote",
            items: [
              {
                name: "OpenVPN / Wireguard",
                command: "sudo apt install openvpn wireguard",
                description:
                  "VPN-Lösungen für sichere, verschlüsselte Verbindungen zu Remote-Netzwerken.",
                benefit:
                  "Essentiell für sicheres Pentesting über das Internet und Zugriff auf isolierte Netzwerke.",
                example:
                  "OpenVPN: Verbinde dich mit 'sudo openvpn --config client.ovpn'. Wireguard: Konfiguriere in /etc/wireguard/wg0.conf, starte mit 'sudo wg-quick up wg0', stoppe mit 'sudo wg-quick down wg0'. Status prüfen: 'sudo wg show'.",
                badgeRequired: "segment2",
                difficulty: "medium",
              },
              {
                name: "SSH Server",
                command: "sudo apt install openssh-server",
                description:
                  "Ermöglicht Remote-Zugriff auf dein Kali-System via Secure Shell.",
                benefit:
                  "Ermöglicht Remote-Zugriff auf dein System – nützlich für Pentests von verschiedenen Standorten.",
                example:
                  "Nach Installation startet der SSH-Service automatisch. Verbinde dich von einem anderen System: 'ssh benutzer@kali-ip'. Mit SSH-Key-Authentifizierung: 'ssh-keygen -t rsa' erstellt Keys, 'ssh-copy-id benutzer@kali-ip' kopiert öffentlichen Key. SSH-Konfiguration in /etc/ssh/sshd_config.",
                badgeRequired: "segment1",
                difficulty: "medium",
              },
            ],
          },
        ];
      }

      // Parse Modern Tools Content
      function parseModernToolsContent() {
        return {
          installation: {
            title: "Installation auf Kali Linux",
            description: "Installiere alle modernen Tools mit einem Befehl:",
            command:
              "sudo apt update && sudo apt install -y exa fd-find ripgrep bat htop btop zoxide fzf duf tldr",
            note: "Hinweis: Einige Tools haben andere Paketnamen (z.B. 'fd-find' statt 'fd', 'bat' statt 'batcat'). Nach der Installation kannst du Aliase erstellen oder die Befehle direkt verwenden.",
          },
          tools: [
            {
              id: "exa",
              name: "EXA vs. LS",
              description:
                "Modernes File-Listing, farbig, Icons, besser lesbar.",
              examples: [
                {
                  level: "Einfach",
                  new: "exa",
                  old: "ls",
                },
                {
                  level: "Mittel",
                  new: "exa -lh --icons",
                  old: "ls -lh",
                  note: "→ zeigt Größen + Icons + human readable",
                },
                {
                  level: "Komplex",
                  new: "exa -lah --git --sort=name --group-directories-first",
                  old: "ls -lah --sort=name --group-directories-first",
                },
              ],
            },
            {
              id: "fd",
              name: "FD vs. FIND",
              description: "Viel einfacher, viel schneller.",
              examples: [
                {
                  level: "Einfach",
                  new: "fd test",
                  old: 'find . -name "*test*"',
                },
                {
                  level: "Mittel",
                  new: 'fd ".conf" /etc',
                  old: 'find /etc -name "*.conf"',
                },
                {
                  level: "Komplex",
                  new: "fd \"listen\" /etc/apache2 --type f --exec sed -n '1,5p' {}",
                  old: "find /etc/apache2 -type f -exec sed -n '1,5p' {} \\;",
                },
              ],
            },
            {
              id: "ripgrep",
              name: "RIPGREP (rg) vs. GREP",
              description: "Extrem schnelle Suchmaschine.",
              examples: [
                {
                  level: "Einfach",
                  new: "rg ssh",
                  old: "grep ssh -r .",
                },
                {
                  level: "Mittel",
                  new: 'rg "Listen" /etc/apache2',
                  old: 'grep -R "Listen" /etc/apache2',
                },
                {
                  level: "Komplex",
                  new: 'rg --type=conf "port" /etc --ignore-case',
                  old: 'find /etc -name "*.conf" -exec grep -i "port" {} \\;',
                },
              ],
            },
            {
              id: "bat",
              name: "BAT vs. CAT",
              description: "Schöner Dateiinhalt.",
              examples: [
                {
                  level: "Einfach",
                  new: "bat config.txt",
                  old: "cat config.txt",
                },
                {
                  level: "Mittel",
                  new: "bat -n script.sh",
                  old: "cat -n script.sh",
                  note: "→ zeigt Zeilennummern",
                },
                {
                  level: "Komplex",
                  new: "bat --paging=never --theme=Dracula *.txt",
                  old: "cat *.txt | less",
                },
              ],
            },
            {
              id: "htop",
              name: "HTOP/BTOP vs. TOP",
              description: "Bessere Übersicht über Prozesse.",
              examples: [
                {
                  level: "Einfach",
                  new: "htop",
                  old: "top",
                },
                {
                  level: "Mittel",
                  new: "btop --utf-force",
                  old: "top",
                  note: "→ animierte Charts",
                },
                {
                  level: "Komplex",
                  new: "htop --sort-key=MEMORY",
                  old: "top -o %MEM",
                },
              ],
            },
            {
              id: "zoxide",
              name: "ZOXIDE vs. CD",
              description: "Merkt sich deine Lieblingsordner.",
              examples: [
                {
                  level: "Einfach",
                  new: "z proj",
                  old: "cd /home/user/projects",
                  note: '→ springt in Ordner, der "proj" am ähnlichsten ist.',
                },
                {
                  level: "Mittel",
                  new: "z ~/Downloads",
                  old: "cd ~/Downloads",
                },
                {
                  level: "Komplex",
                  new: "zoxide add /var/www/html\nz html",
                  old: "cd /var/www/html",
                  note: "Ordner merken: zoxide add /var/www/html\nSpringen: z html",
                },
              ],
            },
            {
              id: "fzf",
              name: "FZF",
              description: "Fuzzy-Search für alles.",
              examples: [
                {
                  level: "Einfach",
                  new: "fzf",
                  old: "-",
                  note: "→ interaktive Dateisuche",
                },
                {
                  level: "Mittel",
                  new: "ctrl + r",
                  old: "-",
                  note: "→ ersetzt normales history browsen",
                },
                {
                  level: "Komplex",
                  new: "vim $(fzf)",
                  old: "-",
                  note: "Datei auswählen und öffnen",
                },
              ],
            },
            {
              id: "duf",
              name: "DUF vs. DF",
              description: "Schönere Festplattenübersicht.",
              examples: [
                {
                  level: "Einfach",
                  new: "duf",
                  old: "df -h",
                },
                {
                  level: "Mittel",
                  new: "duf /home",
                  old: "df -h /home",
                },
                {
                  level: "Komplex",
                  new: "duf --json",
                  old: "df -h | awk '{...}'",
                },
              ],
            },
            {
              id: "tldr",
              name: "TLDR vs. MAN",
              description: "Kurz & verständlich.",
              examples: [
                {
                  level: "Einfach",
                  new: "tldr find",
                  old: "man find",
                },
              ],
            },
          ],
          syntax: {
            title: "Mini-Syntax-Tutorial",
            description: "Einfach, klar, ohne Overkill",
            sections: [
              {
                title: "1. Grundstruktur fast aller Linux-Commands",
                content: "command [optionen] [argumente]",
                examples: [
                  "ls -lh /etc",
                  'grep -R "ssh" /etc',
                  'find . -name "*.txt"',
                ],
              },
              {
                title: "2. Wildcards (Regex light)",
                table: {
                  headers: ["Zeichen", "Bedeutung"],
                  rows: [
                    ["*", "alles"],
                    ["?", "genau ein Zeichen"],
                    ["[abc]", "eines aus a,b,c"],
                    ["{a,b}", "mehrere Varianten"],
                  ],
                },
                examples: ["*.txt", "config?.yml", "file{1,2,3}.txt"],
              },
              {
                title: "3. Pipes (Output eines Commands → Input des nächsten)",
                examples: ['ls -lh | grep ".txt"'],
              },
              {
                title: "4. Redirects",
                table: {
                  headers: ["Zeichen", "Bedeutung"],
                  rows: [
                    [">", "schreibt / überschreibt Datei"],
                    [">>", "hängt an Datei an"],
                  ],
                },
                examples: ['echo "test" > file.txt', "ls >> output.txt"],
              },
              {
                title: "5. Kurzformen / Shortcuts",
                table: {
                  headers: ["Shortcut", "Bedeutung"],
                  rows: [
                    ["~", "Home"],
                    ["/", "Root"],
                    [".", "current directory"],
                    ["..", "parent directory"],
                    ["ctrl+r", "search history"],
                    ["!!", "letzten Befehl wiederholen"],
                    ["!sudo", "letzten Befehl mit sudo wiederholen"],
                  ],
                },
                examples: ["cd ..", "sudo !!"],
              },
            ],
          },
        };
      }

      // Open Hotkeys Modal
      function openHotkeysModal() {
        const modal = modalController.getRoot("hotkeys");
        const bodyEl = document.getElementById("hotkeys-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseHotkeysContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "hotkeys-section";

          const title = document.createElement("div");
          title.className = "hotkeys-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "hotkeys-item";
            itemDiv.innerHTML = `
              <span class="hotkeys-shortcut">${item.shortcut}</span>
              <span class="hotkeys-description">• ${item.description}</span>
            `;
            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        modalController.open("hotkeys");
      }

      // Close Hotkeys Modal
      function closeHotkeysModal() {
        modalController.close("hotkeys");
      }

      // Open Kali Tools Modal
      function openKaliToolsModal() {
        const modal = modalController.getRoot("kaliTools");
        const bodyEl = document.getElementById("kali-tools-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const sections = parseKaliToolsContent();

        sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "kali-tools-section";

          const title = document.createElement("div");
          title.className = "kali-tools-section-title";
          title.textContent = section.title;
          sectionDiv.appendChild(title);

          section.items.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "kali-tools-item";

            // Check if item is locked
            const isUnlocked = checkBadgeUnlocked(item.badgeRequired);

            // Get badge info if required
            let badgeHtml = "";
            if (item.badgeRequired) {
              const segment = badgeSegments.find(
                (s) => s.id === item.badgeRequired
              );
              if (segment) {
                const progress = getSegmentProgress(item.badgeRequired);
                const totalQuizzes = segment.quizIds.length;
                badgeHtml = `<div class="kali-tools-item-badge" style="display: inline-flex; align-items: center; gap: 0.3rem; margin-bottom: 0.4rem; padding: 0.2rem 0.5rem; border-radius: 0.4rem; background: ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.15)"
                    : "rgba(239, 68, 68, 0.15)"
                }; border: 1px solid ${
                  isUnlocked
                    ? "rgba(34, 197, 94, 0.4)"
                    : "rgba(239, 68, 68, 0.4)"
                }; font-size: 0.8rem;">
                              <span>${segment.icon}</span>
                              <span style="color: ${
                                isUnlocked ? "#86efac" : "#fca5a5"
                              }; font-weight: 500;">${segment.name}</span>
                              <span style="color: ${
                                isUnlocked ? "#86efac" : "#fca5a5"
                              }; opacity: 0.8; font-size: 0.75rem;">${progress}/${totalQuizzes}</span>
                            </div>`;
              }
            }

            let html = badgeHtml;
            html += `<span class="kali-tools-name">${item.name}</span>`;
            html += `<div class="kali-tools-description">${item.description}</div>`;

            if (item.benefit) {
              html += `<div class="kali-tools-benefit">💡 ${item.benefit}</div>`;
            }

            if (item.command) {
              // Format multi-line commands
              const formattedCommand = item.command
                .split("\n")
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
                .join("\n");

              // Add chicken button for command if locked
              let commandHtml = `<div class="kali-tools-command">${formattedCommand.replace(
                /\n/g,
                "<br>"
              )}</div>`;

              // Add unlock button for command section if locked
              if (!isUnlocked && item.badgeRequired) {
                commandHtml += `<div style="margin-top: 0.5rem;">
                              <button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                                /"/g,
                                "&quot;"
                              )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="command" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>
                            </div>`;
              }

              html += commandHtml;
            }

            // Add example with blur logic
            if (item.example) {
              const blurredClass = isUnlocked
                ? ""
                : "kali-tools-example-blurred";

              html += `<div class="kali-tools-example ${blurredClass}">`;
              html += `<div class="kali-tools-example-title">`;
              html += `📝 Anwendungsbeispiel`;
              if (!isUnlocked && item.badgeRequired) {
                html += `<button type="button" class="kali-tools-chicken-btn" data-tool-name="${item.name.replace(
                  /"/g,
                  "&quot;"
                )}" data-segment-id="${
                  item.badgeRequired
                }" data-unlock-type="example" title="Klicken um Inhalt ohne Quiz freizuschalten">🐔 Freischalten</button>`;
              }
              html += `</div>`;
              html += `<div class="kali-tools-example-content">${item.example}</div>`;
              html += `</div>`;
            }

            itemDiv.innerHTML = html;

            // Add data attribute for badge requirement
            if (item.badgeRequired) {
              itemDiv.setAttribute("data-badge-required", item.badgeRequired);
            }

            // Attach chicken button event handlers for all chicken buttons
            if (!isUnlocked && item.badgeRequired) {
              const chickenBtns = itemDiv.querySelectorAll(
                ".kali-tools-chicken-btn"
              );
              chickenBtns.forEach((chickenBtn) => {
                chickenBtn.addEventListener("click", (e) => {
                  e.stopPropagation();

                  // Unlock via chicken button
                  unlockBadgeViaChicken(item.badgeRequired);

                  // Remove blur from example if present
                  const exampleDiv = itemDiv.querySelector(
                    ".kali-tools-example"
                  );
                  if (exampleDiv) {
                    exampleDiv.classList.remove("kali-tools-example-blurred");
                  }

                  // Remove all chicken buttons from this item
                  const allChickenBtns = itemDiv.querySelectorAll(
                    ".kali-tools-chicken-btn"
                  );
                  allChickenBtns.forEach((btn) => {
                    const btnParent = btn.parentElement;
                    if (btnParent && btnParent.tagName === "DIV") {
                      btn.remove();
                    } else {
                      btn.remove();
                    }
                  });

                  // Update badge display in item
                  const segment = badgeSegments.find(
                    (s) => s.id === item.badgeRequired
                  );
                  if (segment) {
                    const progress = getSegmentProgress(item.badgeRequired);
                    const totalQuizzes = segment.quizIds.length;
                    const badgeDiv = itemDiv.querySelector(
                      ".kali-tools-item-badge"
                    );
                    if (badgeDiv) {
                      badgeDiv.style.background = "rgba(34, 197, 94, 0.15)";
                      badgeDiv.style.borderColor = "rgba(34, 197, 94, 0.4)";
                      const spans = badgeDiv.querySelectorAll("span");
                      spans.forEach((span) => {
                        if (!span.textContent.match(/[\u{1F300}-\u{1F9FF}]/u)) {
                          span.style.color = "#86efac";
                        }
                      });
                    }
                  }

                  // Update badges display in header
                  updateKaliToolsBadges();

                  // Re-render the entire modal to update all items
                  setTimeout(() => {
                    openKaliToolsModal();
                  }, 100);

                  // Show feedback
                  const feedback = document.createElement("div");
                  feedback.style.cssText = `
                                position: fixed;
                                top: 20px;
                                right: 20px;
                                background: rgba(34, 197, 94, 0.9);
                                color: white;
                                padding: 1rem 1.5rem;
                                border-radius: 0.5rem;
                                z-index: 100;
                                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                                animation: slideIn 0.3s ease-out;
                              `;
                  feedback.textContent = `🐔 Inhalt freigeschaltet!`;
                  document.body.appendChild(feedback);
                  setTimeout(() => {
                    feedback.style.animation = "slideOut 0.3s ease-out";
                    setTimeout(() => feedback.remove(), 300);
                  }, 2000);

                  // Open overlay for example if it was an example button
                  const unlockType =
                    chickenBtn.getAttribute("data-unlock-type");
                  if (unlockType === "example" && item.example) {
                    openExampleOverlay(item);
                  }
                });
              });
            }

            sectionDiv.appendChild(itemDiv);
          });

          bodyEl.appendChild(sectionDiv);
        });

        // Update badges display AFTER rendering content
        setTimeout(() => {
          updateKaliToolsBadges();
        }, 0);

        modalController.open("kaliTools");
      }

      // Close Kali Tools Modal
      function closeKaliToolsModal() {
        modalController.close("kaliTools");
      }

      // Check if badge is unlocked (including chicken button unlocks)
      function checkBadgeUnlocked(segmentId) {
        if (!segmentId) return true; // No badge required = always unlocked

        // Check if unlocked via chicken button
        const chickenUnlocks = localStorage.getItem("kaliToolsChickenUnlocks");
        if (chickenUnlocks) {
          try {
            const unlocks = JSON.parse(chickenUnlocks);
            if (unlocks[segmentId]) return true;
          } catch (e) {
            // Ignore parse errors
          }
        }

        const stored = localStorage.getItem("badgeProgress");
        if (!stored) return false;

        try {
          const badgeProgress = JSON.parse(stored);
          const progress = badgeProgress[segmentId] || 0;

          // Find segment
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return false;

          // Check if segment is complete (all quizzes done)
          const isComplete = progress >= segment.quizIds.length;

          // Check if master quiz is completed
          const masterStored = localStorage.getItem("masterQuizResults");
          if (masterStored) {
            try {
              const masterResults = JSON.parse(masterStored);
              if (masterResults[segmentId]) return true; // Master quiz completed = unlocked
            } catch (e) {
              // Ignore parse errors
            }
          }

          return isComplete;
        } catch (e) {
          return false;
        }
      }

      // Unlock badge via chicken button
      function unlockBadgeViaChicken(segmentId) {
        if (!segmentId) return;

        let unlocks = {};
        const stored = localStorage.getItem("kaliToolsChickenUnlocks");
        if (stored) {
          try {
            unlocks = JSON.parse(stored);
          } catch (e) {
            unlocks = {};
          }
        }

        unlocks[segmentId] = true;
        localStorage.setItem(
          "kaliToolsChickenUnlocks",
          JSON.stringify(unlocks)
        );
      }

      // Update badges display in Kali Tools Modal
      function updateKaliToolsBadges() {
        const container = document.getElementById(
          "kali-tools-badges-container"
        );
        if (!container) return;

        container.innerHTML = "";

        // Get all unique badge requirements from Kali Tools items
        const sections = parseKaliToolsContent();
        const requiredSegments = new Set();

        sections.forEach((section) => {
          section.items.forEach((item) => {
            if (item.badgeRequired) {
              requiredSegments.add(item.badgeRequired);
            }
          });
        });

        // Display badges for required segments
        Array.from(requiredSegments).forEach((segmentId) => {
          const segment = badgeSegments.find((s) => s.id === segmentId);
          if (!segment) return;

          const isUnlocked = checkBadgeUnlocked(segmentId);
          const progress = getSegmentProgress(segmentId);
          const totalQuizzes = segment.quizIds.length;
          const progressPercentage =
            totalQuizzes > 0 ? Math.round((progress / totalQuizzes) * 100) : 0;

          const badge = document.createElement("div");
          badge.className = `kali-tools-badge ${
            isUnlocked ? "unlocked" : "locked"
          }`;

          badge.innerHTML = `
                        <span class="kali-tools-badge-icon">${segment.icon}</span>
                        <span class="kali-tools-badge-name">${segment.name}</span>
                        <span class="kali-tools-badge-progress">${progress}/${totalQuizzes}</span>
                      `;

          badge.title = isUnlocked
            ? `${segment.name} freigeschaltet (${progressPercentage}%)`
            : `${segment.name} benötigt: ${progress}/${totalQuizzes} Quiz abgeschlossen (${progressPercentage}%)`;

          // Click handler: scroll to relevant section or show info
          badge.addEventListener("click", () => {
            // Find first item with this badge requirement and scroll to it
            const firstItem = document.querySelector(
              `.kali-tools-item[data-badge-required="${segmentId}"]`
            );
            if (firstItem) {
              firstItem.scrollIntoView({ behavior: "smooth", block: "center" });
              // Highlight briefly
              firstItem.style.background = "rgba(239, 68, 68, 0.2)";
              setTimeout(() => {
                firstItem.style.background = "";
              }, 2000);
            }
          });

          container.appendChild(badge);
        });
      }

      // Open example overlay
      function openExampleOverlay(tool) {
        const overlay = modalController.getRoot("kaliExampleOverlay");
        const overlayInner = document.getElementById(
          "kali-tools-example-overlay-inner"
        );
        const overlayTitle = document.getElementById(
          "kali-tools-example-overlay-title"
        );
        const overlayContent = document.getElementById(
          "kali-tools-example-overlay-content"
        );

        if (!overlay || !overlayInner || !overlayTitle || !overlayContent)
          return;

        overlayTitle.textContent = tool.name;

        let contentHTML = `<div class="kali-tools-name">${tool.name}</div>`;
        contentHTML += `<div class="kali-tools-description">${tool.description}</div>`;

        if (tool.benefit) {
          contentHTML += `<div class="kali-tools-benefit">💡 ${tool.benefit}</div>`;
        }

        if (tool.command) {
          const formattedCommand = tool.command
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0)
            .join("\n");
          contentHTML += `<div class="kali-tools-command">${formattedCommand.replace(
            /\n/g,
            "<br>"
          )}</div>`;
        }

        if (tool.example) {
          contentHTML += `<div class="kali-tools-example" style="margin-top: 1rem;">
                        <div class="kali-tools-example-title">📝 Anwendungsbeispiel</div>
                        <div class="kali-tools-example-content">${tool.example}</div>
                      </div>`;
        }

        overlayContent.innerHTML = contentHTML;
        modalController.open("kaliExampleOverlay");
      }

      // Close example overlay
      function closeExampleOverlay() {
        modalController.close("kaliExampleOverlay");
      }

      let currentMasterQuizSegment = null;

      // Initial load achievements and badges
      migrateToBadgeProgress();
      buildCheatSheetMap(); // Initialisiere Cheat-Sheet-Map für Badge-System
      updateAchievements();
      updateBadgeDisplay();
      assignBadgeToCards();
      updateHeaderBadgeFilter();

      function renderCommandModalContent(meta) {
        const commandModalDetail = document.getElementById(
          "command-modal-detail"
        );
        const commandModalSimpleExample = document.getElementById(
          "command-modal-simple-example"
        );
        const commandModalSimpleExampleSection = document.getElementById(
          "command-modal-simple-example-section"
        );
        const commandModalComplexExample = document.getElementById(
          "command-modal-complex-example"
        );
        const commandModalComplexExampleSection = document.getElementById(
          "command-modal-complex-example-section"
        );
        const commandModalAdditionalExamples = document.getElementById(
          "command-modal-additional-examples"
        );
        const commandModalAdditionalExamplesSection = document.getElementById(
          "command-modal-additional-examples-section"
        );

        if (commandModalTitle) {
          commandModalTitle.textContent = meta.title || "Befehl";
        }
        if (commandModalSubtitle) {
          commandModalSubtitle.textContent =
            meta.subtitle || "Kompaktüberblick";
        }
        if (commandModalSummary) {
          commandModalSummary.textContent =
            meta.summary || meta.explanation || meta.description || "";
        }

        // Detail (zusätzliche Informationen)
        if (commandModalDetail) {
          if (meta.detail) {
            commandModalDetail.style.display = "block";
            commandModalDetail.innerHTML = `<p style="margin: 0; color: #cbd5e1; line-height: 1.6;">${meta.detail}</p>`;
          } else {
            commandModalDetail.style.display = "none";
          }
        }

        // Flags
        if (commandModalFlags) {
          const isFlagsOverview = meta.quizId === "flags_overview" || meta.title === "Flags-Übersicht";

          // Für flags_overview: Suchleiste hinzufügen
          if (isFlagsOverview) {
            // Erstelle Suchleiste (wird bei jedem Öffnen neu erstellt)
            const searchContainer = document.createElement("div");
            searchContainer.id = "flags-search-container";
            searchContainer.className = "flags-search-container";

            const searchInput = document.createElement("input");
            searchInput.type = "text";
            searchInput.id = "flags-search-input";
            searchInput.className = "flags-search-input";
            searchInput.placeholder = "Suche nach FLAGs, Befehlen oder Begriffen (z.B. 'rekursiv', '-r', '--parents', 'ohne Symlinks')...";
            searchInput.setAttribute("aria-label", "Suche in Flags-Übersicht");

            const searchInfo = document.createElement("div");
            searchInfo.className = "flags-search-info";
            searchInfo.textContent = "Durchsucht FLAG-Namen, Befehle, Beschreibungen und Stichwörter";

            searchContainer.appendChild(searchInput);
            searchContainer.appendChild(searchInfo);

            // Suchleiste vor den Flags einfügen
            const flagsSection = commandModalFlags.parentElement;
            if (flagsSection) {
              flagsSection.insertBefore(searchContainer, commandModalFlags);
            }

            // Filterfunktion für Flags
            const filterFlags = (searchTerm) => {
              if (!meta.flags || !meta.flags.length) {
                commandModalFlags.innerHTML = "";
                return;
              }

              const normalizedSearch = searchTerm.toLowerCase().trim();

              // Wenn keine Suche, alle Flags anzeigen
              if (!normalizedSearch) {
                renderAllFlags(meta.flags);
                return;
              }

              // Filtere Flags basierend auf Suche
              const filteredFlags = meta.flags.filter((flag) => {
                // Überspringe Trennlinien (Flags mit "---" in der Beschreibung)
                if (flag.description && flag.description.includes("---")) {
                  return true; // Trennlinien immer anzeigen
                }

                const flagLower = (flag.flag || "").toLowerCase();
                const descLower = (flag.description || "").toLowerCase();
                const commandLower = (flag.command || "").toLowerCase();

                // Suche nach exakten FLAGs (z.B. "-P", "--parents", "-r", "-R")
                if (flagLower.includes(normalizedSearch)) {
                  return true;
                }

                // Suche nach Long-Optionen (z.B. "--parents", "--include")
                const longOptionMatch = flagLower.match(/--([a-z-]+)/);
                if (longOptionMatch && longOptionMatch[1].includes(normalizedSearch.replace(/^--?/, ""))) {
                  return true;
                }

                // Suche nach Short-Optionen (z.B. "-r", "-R", "-P")
                const shortOptionMatch = flagLower.match(/-([a-zA-Z])/g);
                if (shortOptionMatch) {
                  for (const opt of shortOptionMatch) {
                    if (opt.toLowerCase().includes(normalizedSearch)) {
                      return true;
                    }
                  }
                }

                // Suche nach Befehl (z.B. "ls", "grep", "find")
                if (commandLower && commandLower.includes(normalizedSearch)) {
                  return true;
                }

                // Extrahiere Befehl aus Flag-String (z.B. "ls -l" -> "ls", "grep -r" -> "grep")
                const commandMatch = flagLower.match(/^([a-z]+)\s/);
                if (commandMatch && commandMatch[1].includes(normalizedSearch)) {
                  return true;
                }

                // Suche in Beschreibung (vollständiger Text)
                if (descLower.includes(normalizedSearch)) {
                  return true;
                }

                // Suche nach einzelnen Wörtern in der Beschreibung
                const descWords = descLower.split(/\s+/);
                for (const word of descWords) {
                  if (word.includes(normalizedSearch) || normalizedSearch.includes(word)) {
                    return true;
                  }
                }

                // Suche nach Stichwörtern (wichtige Begriffe in Beschreibungen)
                const keywords = [
                  "rekursiv", "recursive", "symlinks", "symlink", "versteckt", "hidden",
                  "verzeichnis", "directory", "datei", "file", "pfad", "path",
                  "rechte", "permissions", "besitzer", "owner", "gruppe", "group",
                  "interaktiv", "interactive", "force", "ohne", "without", "mit", "with",
                  "anzeigen", "show", "zeigen", "display", "kopieren", "copy", "löschen", "delete",
                  "erstellen", "create", "entpacken", "extract", "komprimieren", "compress",
                  "physisch", "physical", "parents", "include", "exclude", "type", "maxdepth"
                ];

                for (const keyword of keywords) {
                  if (keyword.includes(normalizedSearch) || normalizedSearch.includes(keyword)) {
                    if (descLower.includes(keyword) || flagLower.includes(keyword)) {
                      return true;
                    }
                  }
                }

                return false;
              });

              // Rendere gefilterte Flags
              if (filteredFlags.length > 0) {
                renderAllFlags(filteredFlags);
              } else {
                commandModalFlags.innerHTML = '<div class="flags-no-results">Keine passenden FLAGS gefunden – Suchbegriff anpassen.</div>';
              }
            };

            // Render-Funktion für Flags
            const renderAllFlags = (flagsToRender) => {
              commandModalFlags.innerHTML = "";
              flagsToRender.forEach((flag) => {
                const pill = document.createElement("div");
                pill.className = "flag-pill";
                let flagText = `<span>${flag.flag}</span><small>${flag.description}</small>`;
                if (flag.utility) {
                  flagText += `<small style="display: block; margin-top: 0.2rem; color: #94a3b8;">Nützlichkeit: ${flag.utility}</small>`;
                }
                if (flag.risk) {
                  flagText += `<small style="display: block; color: #94a3b8;">Risiko: ${flag.risk}</small>`;
                }
                pill.innerHTML = flagText;
                commandModalFlags.appendChild(pill);
              });
            };

            // Event Listener für Live-Suche
            searchInput.addEventListener("input", (e) => {
              filterFlags(e.target.value);
            });

            // Initial: Alle Flags anzeigen
            renderAllFlags(meta.flags);
          } else {
            // Normale Darstellung für andere Befehle
            commandModalFlags.innerHTML = "";
            if (meta.flags && meta.flags.length) {
              meta.flags.forEach((flag) => {
                const pill = document.createElement("div");
                pill.className = "flag-pill";
                let flagText = `<span>${flag.flag}</span><small>${flag.description}</small>`;
                if (flag.utility) {
                  flagText += `<small style="display: block; margin-top: 0.2rem; color: #94a3b8;">Nützlichkeit: ${flag.utility}</small>`;
                }
                if (flag.risk) {
                  flagText += `<small style="display: block; color: #94a3b8;">Risiko: ${flag.risk}</small>`;
                }
                pill.innerHTML = flagText;
                commandModalFlags.appendChild(pill);
              });
            } else {
              commandModalFlags.textContent = "Keine besonderen Flags";
            }
          }
        }

        // Pitfalls
        if (commandModalPitfalls) {
          commandModalPitfalls.innerHTML = "";
          if (meta.pitfalls && meta.pitfalls.length) {
            meta.pitfalls.forEach((pit) => {
              const li = document.createElement("li");
              li.textContent = pit;
              commandModalPitfalls.appendChild(li);
            });
          } else {
            const li = document.createElement("li");
            li.textContent = "Keine bekannten Stolpersteine";
            commandModalPitfalls.appendChild(li);
          }
        }

        // Einfaches Beispiel
        if (commandModalSimpleExample && commandModalSimpleExampleSection) {
          if (meta.simpleExample) {
            commandModalSimpleExampleSection.style.display = "block";
            const codeEl = document.createElement("code");
            codeEl.textContent = meta.simpleExample;
            codeEl.style.display = "block";
            codeEl.style.padding = "0.75rem";
            codeEl.style.background = "rgba(59, 130, 246, 0.1)";
            codeEl.style.borderRadius = "0.5rem";
            codeEl.style.marginTop = "0.5rem";
            commandModalSimpleExample.innerHTML = "";
            commandModalSimpleExample.appendChild(codeEl);
          } else {
            commandModalSimpleExampleSection.style.display = "none";
          }
        }

        // Komplexes Beispiel mit Erklärungen
        if (commandModalComplexExample && commandModalComplexExampleSection) {
          if (meta.complexExample) {
            commandModalComplexExampleSection.style.display = "block";
            commandModalComplexExample.innerHTML = "";

            const codeEl = document.createElement("code");
            codeEl.textContent = meta.complexExample;
            codeEl.style.display = "block";
            codeEl.style.padding = "0.75rem";
            codeEl.style.background = "rgba(59, 130, 246, 0.1)";
            codeEl.style.borderRadius = "0.5rem";
            codeEl.style.marginTop = "0.5rem";
            codeEl.style.whiteSpace = "pre-wrap";
            commandModalComplexExample.appendChild(codeEl);

            if (
              meta.complexExampleExplanation &&
              meta.complexExampleExplanation.length > 0
            ) {
              const explanationDiv = document.createElement("div");
              explanationDiv.style.marginTop = "1rem";
              explanationDiv.style.padding = "0.75rem";
              explanationDiv.style.background = "rgba(255, 255, 255, 0.02)";
              explanationDiv.style.borderRadius = "0.5rem";
              explanationDiv.style.border =
                "1px solid rgba(255, 255, 255, 0.1)";

              const explanationTitle = document.createElement("div");
              explanationTitle.textContent = "Erklärung:";
              explanationTitle.style.fontWeight = "600";
              explanationTitle.style.marginBottom = "0.5rem";
              explanationTitle.style.color = "#c7d2fe";
              explanationDiv.appendChild(explanationTitle);

              meta.complexExampleExplanation.forEach((exp) => {
                const expItem = document.createElement("div");
                expItem.style.marginBottom = "0.75rem";

                if (exp.line) {
                  const lineCode = document.createElement("code");
                  lineCode.textContent = exp.line;
                  lineCode.style.display = "block";
                  lineCode.style.padding = "0.4rem 0.6rem";
                  lineCode.style.background = "rgba(59, 130, 246, 0.15)";
                  lineCode.style.borderRadius = "0.4rem";
                  lineCode.style.marginBottom = "0.3rem";
                  lineCode.style.fontSize = "0.9rem";
                  expItem.appendChild(lineCode);
                }

                if (exp.explanation) {
                  const expText = document.createElement("div");
                  expText.textContent = exp.explanation;
                  expText.style.color = "#cbd5e1";
                  expText.style.fontSize = "0.9rem";
                  expText.style.lineHeight = "1.5";
                  expItem.appendChild(expText);
                }

                explanationDiv.appendChild(expItem);
              });

              commandModalComplexExample.appendChild(explanationDiv);
            }
          } else {
            commandModalComplexExampleSection.style.display = "none";
          }
        }

        // Zusätzliche Beispiele (HTML)
        if (
          commandModalAdditionalExamples &&
          commandModalAdditionalExamplesSection
        ) {
          if (meta.additionalExamples) {
            commandModalAdditionalExamplesSection.style.display = "block";
            commandModalAdditionalExamples.innerHTML = meta.additionalExamples;
            // Style für die zusätzlichen Beispiele
            const style = document.createElement("style");
            style.textContent = `
                    #command-modal-additional-examples code {
                      display: block;
                      padding: 0.5rem;
                      background: rgba(59, 130, 246, 0.1);
                      border-radius: 0.4rem;
                      margin: 0.5rem 0;
                      font-size: 0.9rem;
                    }
                    #command-modal-additional-examples strong {
                      color: #c7d2fe;
                      display: block;
                      margin-top: 0.75rem;
                      margin-bottom: 0.25rem;
                    }
                  `;
            if (!document.getElementById("additional-examples-style")) {
              style.id = "additional-examples-style";
              document.head.appendChild(style);
            }
          } else {
            commandModalAdditionalExamplesSection.style.display = "none";
          }
        }

        // Legacy Examples (aus commandMeta)
        if (commandModalExamples) {
          commandModalExamples.innerHTML = "";
          if (meta.examples && meta.examples.length) {
            meta.examples.forEach((example) => {
              const item = document.createElement("div");
              item.className = "example-item";
              const cmd = document.createElement("code");
              cmd.textContent = example.command;
              const note = document.createElement("div");
              note.style.marginTop = "0.35rem";
              note.textContent = example.note || "";
              item.appendChild(cmd);
              item.appendChild(note);
              commandModalExamples.appendChild(item);
            });
          } else {
            // Nur anzeigen wenn keine anderen Beispiele vorhanden
            if (
              !meta.simpleExample &&
              !meta.complexExample &&
              !meta.additionalExamples
            ) {
              const item = document.createElement("div");
              item.textContent = "Noch keine Beispiele hinterlegt.";
              commandModalExamples.appendChild(item);
            } else {
              // Verstecke Legacy Examples Section wenn andere Beispiele vorhanden
              const examplesSection =
                commandModalExamples.closest(".command-section");
              if (examplesSection) {
                examplesSection.style.display = "none";
              }
            }
          }
        }
      }

      function openCommandModal(commandKey, quizId) {
        console.log("[CommandModal] openCommandModal called", { commandKey, quizId });
        const commandModal = modalController.getRoot("command");
        if (!commandModal) {
          console.warn("[CommandModal] Command modal root not found");
          return;
        }

        // Entferne alte Suchleiste, falls vorhanden
        const oldSearchContainer = document.getElementById("flags-search-container");
        if (oldSearchContainer) {
          oldSearchContainer.remove();
        }

        let meta = null;

        if (quizId && quizData[quizId]) {
          const quiz = quizData[quizId];
          const commandMetaData = commandMeta[commandKey] || commandMeta[quizId];

          meta = {
            title: quiz.title,
            subtitle: "Vollständige Informationen",
            summary: quiz.explanation || quiz.description || "",
            description: quiz.description,
            explanation: quiz.explanation,
            detail: quiz.detail,
            simpleExample: quiz.simpleExample,
            complexExample: quiz.complexExample,
            complexExampleExplanation: quiz.complexExampleExplanation,
            additionalExamples: quiz.additionalExamples,
            flags: quiz.flags || [],
            pitfalls: commandMetaData?.pitfalls || [],
            examples: commandMetaData?.examples || [],
            quizId: quizId,
          };
        } else {
          meta = commandMeta[commandKey] || commandMeta[quizId];

          if (!meta && commandKey) {
            const normalizedKey = commandKey.replace(/\s+/g, "_").toLowerCase();
            meta =
              commandMeta[normalizedKey] || commandMeta[commandKey.toLowerCase()];
          }
        }

        if (!meta) {
          console.warn("Keine Metadaten für", commandKey || quizId);
          return;
        }

        renderCommandModalContent(meta);

        if (commandModalFeedback) {
          commandModalFeedback.textContent =
            "ESC oder Klick auf den Hintergrund schließen das Modal.";
        }

        modalController.open("command");
      }

      function closeCommandModal() {
        console.log("[CommandModal] closeCommandModal called");
        modalController.close("command");
      }

      commandCards.forEach((card) => {
        const quizId = card.dataset.quizId;
        if (!quizId) return;
        card.addEventListener("click", () => {
          openCommandModal(card.dataset.command || quizId, quizId);
        });
      });
      commandCards.forEach((card) => {
        const quizId = card.dataset.quizId;
        if (!quizId) return;
        card.addEventListener("click", () => {
          openCommandModal(card.dataset.command || quizId, quizId);
        });
      });

      // Helper function to search in quiz data
      function searchInQuizData(quizId, query) {
        if (!query || !quizId) return false;

        const quiz = quizData[quizId];
        if (!quiz) return false;

        const queryLower = query.toLowerCase();

        // Search in all text fields of the quiz
        const searchFields = [
          quiz.title,
          quiz.description,
          quiz.explanation,
          quiz.detail,
          quiz.simpleExample,
          quiz.complexExample,
          quiz.additionalExamples,
        ];

        // Search in questions
        if (quiz.questions && Array.isArray(quiz.questions)) {
          quiz.questions.forEach((q) => {
            if (q.prompt) searchFields.push(q.prompt);
            if (q.explanation) searchFields.push(q.explanation);
            if (q.options && Array.isArray(q.options)) {
              q.options.forEach((opt) => searchFields.push(opt));
            }
          });
        }

        // Search in complex example explanations
        if (
          quiz.complexExampleExplanation &&
          Array.isArray(quiz.complexExampleExplanation)
        ) {
          quiz.complexExampleExplanation.forEach((exp) => {
            if (exp.line) searchFields.push(exp.line);
            if (exp.explanation) searchFields.push(exp.explanation);
          });
        }

        // Check if query matches any field
        return searchFields.some((field) => {
          if (!field) return false;
          // Remove HTML tags for searching
          const text =
            typeof field === "string"
              ? field.replace(/<[^>]*>/g, "").toLowerCase()
              : String(field).toLowerCase();
          return text.includes(queryLower);
        });
      }

      // Erweiterte Suchfunktion - durchsucht auch FAQ
      function searchInFaqData(query) {
        if (!faqData || !faqData.categories) return [];

        const queryLower = query.toLowerCase();
        const results = [];

        faqData.categories.forEach((category) => {
          category.questions.forEach((question) => {
            const searchText = [
              question.question,
              question.answer,
              ...(question.tags || []),
              ...(question.relatedCommands || []),
            ]
              .join(" ")
              .toLowerCase();

            if (searchText.includes(queryLower)) {
              results.push({
                id: question.id,
                question: question.question,
                answer: question.answer,
                category: category.name,
                categoryId: category.id,
              });
            }
          });
        });

        return results;
      }

      // Search functionality
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
        searchInput.addEventListener("input", (e) => {
          const query = e.target.value.toLowerCase().trim();

          // Finde das aktive Segment (falls vorhanden)
          const segment = activeFilterSegment
            ? badgeSegments.find((s) => s.id === activeFilterSegment)
            : null;

          // Finde Achievement-Quiz-IDs (falls Achievement-Filter aktiv)
          const achievementQuizIds = activeFilterAchievement
            ? getQuizIdsForAchievement(activeFilterAchievement)
            : null;

          // Suche in Command-Cards
          commandCards.forEach((card) => {
            const quizId = card.dataset.quizId;

            // Prüfe zuerst, ob die Karte zum aktiven Segment gehört
            let belongsToSegment = true;
            if (segment) {
              belongsToSegment = segment.quizIds.includes(quizId);
            }

            // Prüfe ob Karte zum Achievement-Filter gehört
            let belongsToAchievement = true;
            if (achievementQuizIds) {
              belongsToAchievement = achievementQuizIds.includes(quizId);
            }

            // Wenn Filter aktiv und Karte gehört nicht dazu, verstecken
            if (
              (segment && !belongsToSegment) ||
              (achievementQuizIds && !belongsToAchievement)
            ) {
              card.classList.add("hidden");
              return;
            }

            // Dann prüfe Suchanfrage
            const command = card.dataset.command?.toLowerCase() || "";
            const tag =
              card.querySelector(".command-tag")?.textContent.toLowerCase() ||
              "";
            const body =
              card.querySelector(".command-body")?.textContent.toLowerCase() ||
              "";

            // Search in card content
            const matchesCardContent =
              !query ||
              command.includes(query) ||
              tag.includes(query) ||
              body.includes(query);

            // Search in quiz data (explanations, examples, questions)
            const matchesQuizData = !query || searchInQuizData(quizId, query);

            const matches = matchesCardContent || matchesQuizData;

            // Karte verstecken, wenn sie nicht zur Suche passt
            if (!matches) {
              card.classList.add("hidden");
            } else if (!segment && !achievementQuizIds) {
              // Wenn kein Filter aktiv ist, Karte anzeigen
              card.classList.remove("hidden");
            } else if (
              (segment && belongsToSegment) ||
              (achievementQuizIds && belongsToAchievement)
            ) {
              // Wenn Filter aktiv und Karte gehört dazu, anzeigen
              card.classList.remove("hidden");
            }
          });

          // Suche auch in FAQ - die FAQ-Suchfunktion wird automatisch verwendet, wenn das FAQ-Modal geöffnet wird
          // Die FAQ-Suchfunktion im Modal durchsucht bereits alle FAQ-Inhalte inklusive Tags und Commands
        });
      }

      // Command-Validierung (flexibel)
      function validateCommand(input, correctCommand, acceptedVariants = []) {
        if (!input || !correctCommand) return false;

        // Normalisiere Input: trim und mehrere Leerzeichen zu einem
        const normalized = input.trim().replace(/\s+/g, " ");

        // Normalisiere korrekten Command
        const normalizedCorrect = correctCommand.replace(/\s+/g, " ");

        // Prüfe exakte Übereinstimmung (normalisiert)
        if (normalized === normalizedCorrect) return true;

        // Prüfe Varianten
        for (const variant of acceptedVariants) {
          const normalizedVariant = variant.replace(/\s+/g, " ");
          if (normalized === normalizedVariant) return true;
        }

        // Flexibler Check: Ignoriere Anführungszeichen-Unterschiede
        const inputNoQuotes = normalized.replace(/['"]/g, "");
        const correctNoQuotes = normalizedCorrect.replace(/['"]/g, "");
        if (inputNoQuotes === correctNoQuotes) return true;

        // Prüfe Varianten ohne Anführungszeichen
        for (const variant of acceptedVariants) {
          const normalizedVariant = variant.replace(/\s+/g, " ");
          const variantNoQuotes = normalizedVariant.replace(/['"]/g, "");
          if (inputNoQuotes === variantNoQuotes) return true;
        }

        return false;
      }

      // Validiere Command-Input und zeige Chicken-Button bei Fehler
      function validateCommandInput(inputElement, question) {
        const userInput = inputElement.value;
        const correctCommand = question.correctCommand;
        const acceptedVariants = question.acceptedVariants || [];

        const isValid = validateCommand(
          userInput,
          correctCommand,
          acceptedVariants
        );

        if (isValid) {
          inputElement.style.borderColor = "#22c55e";
          inputElement.style.boxShadow = "0 0 0 3px rgba(34, 197, 94, 0.1)";
          inputElement.dataset.isValid = "true";
        } else {
          inputElement.style.borderColor = "#ef4444";
          inputElement.style.boxShadow = "0 0 0 3px rgba(239, 68, 68, 0.1)";
          inputElement.dataset.isValid = "false";

          // Zeige Chicken-Button nach falscher Eingabe
          const chickenBtn = inputElement.parentElement.querySelector(
            ".quiz-chicken-btn-command"
          );
          if (chickenBtn) {
            chickenBtn.classList.add("visible");
          }
        }
      }

      // Zeige Command-Lösung kurz an (2-3 Sekunden)
      function showCommandSolution(button, correctCommand) {
        // Erstelle Overlay
        const overlay = document.createElement("div");
        overlay.className = "quiz-solution-preview";

        const title = document.createElement("div");
        title.textContent = "Korrekte Lösung:";
        title.style.color = "#93c5fd";
        title.style.fontWeight = "600";
        title.style.marginBottom = "0.5rem";

        const code = document.createElement("code");
        code.textContent = correctCommand;

        const countdown = document.createElement("div");
        countdown.className = "countdown";

        overlay.appendChild(title);
        overlay.appendChild(code);
        overlay.appendChild(countdown);

        // Füge Overlay zum Body hinzu
        document.body.appendChild(overlay);

        // Countdown: 3 Sekunden
        let seconds = 3;
        countdown.textContent = `Lösung verschwindet in ${seconds}...`;

        const countdownInterval = setInterval(() => {
          seconds--;
          if (seconds > 0) {
            countdown.textContent = `Lösung verschwindet in ${seconds}...`;
          } else {
            countdown.textContent = "Lösung verschwindet...";
          }
        }, 1000);

        // Entferne Overlay nach 3 Sekunden
        setTimeout(() => {
          overlay.style.animation = "solutionFadeOut 0.3s ease";
          setTimeout(() => {
            overlay.remove();
            clearInterval(countdownInterval);
          }, 300);
        }, 3000);

        // Button deaktivieren
        button.disabled = true;
        button.style.opacity = "0.5";
        button.style.cursor = "not-allowed";
      }

      // UI-Reset für das Quiz (wird vom Modal-Controller beim Schließen genutzt)
      function resetQuizUI({ clearState = true } = {}) {
        const modalInner = document.querySelector(".quiz-modal-inner");
        if (modalInner) {
          modalInner.classList.remove("flipped");
        }

        const feedbackEls = [
          document.getElementById("quiz-feedback"),
          document.getElementById("quiz-feedback-back"),
        ];
        feedbackEls.forEach((el) => {
          if (!el) return;
          el.textContent = "";
          el.style.color = "";
        });

        const quizBodyFront = document.getElementById("quiz-body");
        if (quizBodyFront) quizBodyFront.innerHTML = "";

        const quizBodyBack = document.getElementById("quiz-body-back");
        if (quizBodyBack) quizBodyBack.innerHTML = "";

        const quizSubmitBtnBack = document.getElementById(
          "quiz-submit-btn-back"
        );
        if (quizSubmitBtnBack) {
          quizSubmitBtnBack.disabled = false;
        }

        if (clearState) {
          currentQuizId = null;
        }
      }

      // Basis-Layout für Quiz-Vorder- und Rückseite füllen
      function prepareQuizShell(quiz) {
        const quizTitleEl = document.getElementById("quiz-title");
        const quizSubtitleEl = document.getElementById("quiz-subtitle");
        const quizFeedbackEl = document.getElementById("quiz-feedback");
        const quizBodyEl = document.getElementById("quiz-body");

        if (quizTitleEl) quizTitleEl.textContent = "Quiz zu " + quiz.title;
        if (quizSubtitleEl)
          quizSubtitleEl.textContent = "3 Fragen: leicht · mittel · schwer";
        if (quizFeedbackEl) quizFeedbackEl.textContent = "";
        if (quizBodyEl) quizBodyEl.innerHTML = "";

        const quizBodyBack = document.getElementById("quiz-body-back");
        const quizTitleBack = document.getElementById("quiz-title-back");
        const quizSubtitleBack = document.getElementById("quiz-subtitle-back");
        const quizFeedbackBack = document.getElementById("quiz-feedback-back");

        if (quizTitleBack) quizTitleBack.textContent = "Quiz zu " + quiz.title;
        if (quizSubtitleBack)
          quizSubtitleBack.textContent = "3 Fragen: leicht · mittel · schwer";
        if (quizFeedbackBack) {
          quizFeedbackBack.textContent = "";
          quizFeedbackBack.style.color = "";
        }
        if (quizBodyBack) quizBodyBack.innerHTML = "";
      }

      // Dynamisch alle Quizfragen rendern
      function renderQuizQuestions(quiz) {
        const quizBodyBack = document.getElementById("quiz-body-back");
        if (!quizBodyBack || !quiz.questions) return;

        quiz.questions.forEach((q, idx) => {
          const questionId = "q_back_" + idx;
          const wrapper = document.createElement("div");
          wrapper.className = "quiz-question";
          const title = document.createElement("div");
          title.className = "quiz-question-title";
          title.textContent = q.prompt;
          const meta = document.createElement("div");
          meta.className = "quiz-question-meta";
          meta.textContent = "Frage " + (idx + 1) + " · Level: " + q.level;

          if (q.type === "command") {
            const commandWrapper = document.createElement("div");
            commandWrapper.className = "quiz-command-wrapper";

            const commandInput = document.createElement("input");
            commandInput.type = "text";
            commandInput.className = "quiz-command-input";
            commandInput.placeholder = "Tippe den Befehl hier ein...";
            commandInput.dataset.questionIndex = idx;
            commandInput.dataset.correctCommand = q.correctCommand;
            commandInput.dataset.acceptedVariants = JSON.stringify(
              q.acceptedVariants || []
            );

            commandInput.addEventListener("keypress", function (e) {
              if (e.key === "Enter") {
                validateCommandInput(this, q);
              }
            });

            commandInput.addEventListener("blur", function () {
              if (this.value.trim()) {
                validateCommandInput(this, q);
              }
            });

            const chickenBtn = document.createElement("button");
            chickenBtn.type = "button";
            chickenBtn.className = "quiz-chicken-btn-command";
            chickenBtn.textContent = "🐔 Lösung zeigen";
            chickenBtn.dataset.questionIndex = idx;
            chickenBtn.dataset.correctCommand = q.correctCommand;
            chickenBtn.addEventListener("click", function () {
              showCommandSolution(this, q.correctCommand);
            });

            commandWrapper.appendChild(commandInput);
            commandWrapper.appendChild(chickenBtn);

            wrapper.dataset.quizQuestionIndex = idx;
            wrapper.dataset.questionType = "command";
            wrapper.appendChild(title);
            wrapper.appendChild(meta);
            wrapper.appendChild(commandWrapper);
            quizBodyBack.appendChild(wrapper);
          } else {
            const options = document.createElement("div");
            options.className = "quiz-options";
            (q.options || []).forEach((opt, optIdx) => {
              const label = document.createElement("label");
              label.className = "quiz-option";
              label.dataset.optionIndex = optIdx;
              const radio = document.createElement("input");
              radio.type = "radio";
              radio.name = questionId;
              radio.value = optIdx;
              const text = document.createElement("span");
              text.textContent = opt;
              label.appendChild(radio);
              label.appendChild(text);
              options.appendChild(label);
            });

            const chickenBtn = document.createElement("button");
            chickenBtn.type = "button";
            chickenBtn.className = "quiz-chicken-btn";
            chickenBtn.textContent = "🐔 Lösung zeigen";
            chickenBtn.dataset.questionIndex = idx;
            chickenBtn.dataset.correctIndex = q.correctIndex;
            chickenBtn.addEventListener("click", function () {
              const correctIdx = parseInt(this.dataset.correctIndex);
              const allLabels = options.querySelectorAll("label");
              allLabels.forEach((label, labelIdx) => {
                if (labelIdx === correctIdx) {
                  label.classList.add("highlight-correct");
                  const radio = label.querySelector("input[type=radio]");
                  if (radio) radio.checked = true;
                } else {
                  label.classList.remove("highlight-correct");
                }
              });
              this.disabled = true;
              this.style.opacity = "0.5";
              this.style.cursor = "not-allowed";
            });
            wrapper.dataset.quizQuestionIndex = idx;
            wrapper.appendChild(title);
            wrapper.appendChild(meta);
            wrapper.appendChild(options);
            wrapper.appendChild(chickenBtn);
            quizBodyBack.appendChild(wrapper);
          }
        });
      }

      // Quiz öffnen: Reset, Inhalte rendern und anzeigen
      function openQuiz(quizId) {
        console.log("[QuizModal] openQuiz called with quizId:", quizId);
        const quiz = quizData[quizId];
        if (!quiz) {
          console.warn("[QuizModal] Kein Quiz definiert für:", quizId);
          return;
        }

        resetQuizUI({ clearState: false });
        currentQuizId = quizId;
        prepareQuizShell(quiz);
        renderQuizQuestions(quiz);
        setupQuizSubmitHandler();

        modalController.open("quiz");

        const modalInner = document.querySelector(".quiz-modal-inner");
        if (modalInner) {
          modalInner.classList.add("flipped");
        }

        console.log(
          "[QuizModal] Quiz modal opened directly with questions, quizId:",
          quizId
        );
      }

      // Quiz auswerten (auf der Rückseite) - Event Handler Funktion
      let quizSubmitHandler = null;

      function setupQuizSubmitHandler() {
        const quizSubmitBtnBack = document.getElementById(
          "quiz-submit-btn-back"
        );
        if (!quizSubmitBtnBack) {
          console.warn("[QuizModal] quiz-submit-btn-back not found");
          return;
        }

        if (quizSubmitHandler) {
          quizSubmitBtnBack.removeEventListener("click", quizSubmitHandler);
          quizSubmitHandler = null;
        }

        quizSubmitHandler = (event) => {
          if (!event || event.type !== "click") {
            return;
          }

          if (!currentQuizId) {
            console.warn("[QuizModal] No currentQuizId, aborting submit");
            return;
          }

          const quizRoot = modalController.getRoot("quiz");
          if (!quizRoot || quizRoot.classList.contains("hidden")) {
            console.warn("[QuizModal] Quiz modal is hidden, aborting submit");
            return;
          }

          if (quizSubmitBtnBack.disabled) {
            console.warn(
              "[QuizModal] Submit button is disabled, aborting submit"
            );
            return;
          }

          const quiz = quizData[currentQuizId];
          const quizBodyBack = document.getElementById("quiz-body-back");
          const quizFeedbackBack =
            document.getElementById("quiz-feedback-back");

          if (!quizBodyBack || !quizFeedbackBack) return;

          const questionEls = Array.from(
            quizBodyBack.querySelectorAll(".quiz-question")
          );
          let correct = 0;
          let answered = 0;

          questionEls.forEach((qEl, idx) => {
            const question = quiz.questions[idx];

            if (question.type === "command") {
              const commandInput = qEl.querySelector(".quiz-command-input");
              if (commandInput && commandInput.value.trim()) {
                answered++;
                const userInput = commandInput.value;
                const isValid = validateCommand(
                  userInput,
                  question.correctCommand,
                  question.acceptedVariants || []
                );
                if (isValid) {
                  correct++;
                  commandInput.style.borderColor = "#22c55e";
                } else {
                  commandInput.style.borderColor = "#ef4444";
                }
              }
            } else {
              const radios = qEl.querySelectorAll("input[type=radio]");
              let selectedIndex = null;
              radios.forEach((r, rIdx) => {
                if (r.checked) selectedIndex = rIdx;
              });
              if (selectedIndex !== null) {
                answered++;
                if (selectedIndex === question.correctIndex) correct++;
              }
            }
          });

          if (answered < quiz.questions.length) {
            quizFeedbackBack.textContent = "Bitte alle 3 Fragen beantworten.";
            quizFeedbackBack.style.color = "#facc15";
            return;
          }

          quizSubmitBtnBack.disabled = true;

          if (correct === quiz.questions.length) {
            const previousTotal = getTotalCorrectAnswers();
            const isNewCompletion = saveQuizResult(currentQuizId, correct);

            quizFeedbackBack.textContent = "Stark! Alle Fragen korrekt. ✅";
            quizFeedbackBack.style.color = "#22c55e";
            markCardAsCompleted(currentQuizId);

            triggerCelebrationAnimation(quizRoot);

            if (isNewCompletion) {
              const newTotal = getTotalCorrectAnswers();
              const newAchievement = achievements.find(
                (a) => newTotal >= a.threshold && previousTotal < a.threshold
              );

              if (newAchievement) {
                setTimeout(() => {
                  alert(
                    `🏆 Achievement freigeschaltet: ${newAchievement.icon} ${newAchievement.name}!`
                  );
                }, 500);
              }

              updateAchievements();
              updateBadgeDisplay();
              updateHeaderBadgeFilter();

              badgeSegments.forEach((segment) => {
                if (segment.quizIds.includes(currentQuizId)) {
                  const progress = getSegmentProgress(segment.id);
                  if (
                    progress >= segment.quizIds.length &&
                    !isMasterQuizCompleted(segment.id)
                  ) {
                    updateBadgeDisplay();
                  }
                }
              });
            }

            console.log(
              "[QuizModal] Auto-close disabled — modal will remain open for review"
            );
          } else {
            quizFeedbackBack.textContent =
              "Du hast " +
              correct +
              "/" +
              quiz.questions.length +
              " richtig. Schau dir die Erklärungen noch einmal an.";
            quizFeedbackBack.style.color = "#f97316";

            triggerErrorFeedback(quizRoot);

            setTimeout(() => {
              quizSubmitBtnBack.disabled = false;
            }, 500);
          }
        };

        quizSubmitBtnBack.addEventListener("click", quizSubmitHandler);
      }

      function closeQuiz() {
        console.log("[QuizModal] closeQuiz invoked");
        modalController.close("quiz");
      }
      function markCardAsCompleted(quizId) {
        // WICHTIG: Nur das spezifische Quiz markieren, nicht alle
        if (!quizId) {
          console.warn("markCardAsCompleted: Keine quizId übergeben");
          return;
        }

        const card = commandCards.find((c) => c.dataset.quizId === quizId);
        if (!card) {
          console.warn(
            "markCardAsCompleted: Keine Karte gefunden für quizId:",
            quizId
          );
          return;
        }

        // Prüfe ob das Quiz tatsächlich gelöst ist
        if (!isQuizCompleted(quizId)) {
          console.warn("markCardAsCompleted: Quiz ist nicht gelöst:", quizId);
          return;
        }

        card.classList.add("quiz-done", "flash-once");
        setTimeout(() => {
          card.classList.remove("flash-once");
        }, 1000);
      }

      // Funktion zum Markieren aller bereits gelösten Quiz-Karten beim Laden der Seite
      function markCompletedQuizzesOnLoad() {
        const stored = localStorage.getItem("quizResults");
        if (!stored) return;

        try {
          const results = JSON.parse(stored);

          // Gehe durch alle Quiz-IDs und markiere nur die, die tatsächlich gelöst sind
          Object.keys(results).forEach((quizId) => {
            if (results[quizId] === 3) {
              // Prüfe nochmal explizit mit isQuizCompleted
              if (isQuizCompleted(quizId)) {
                const card = commandCards.find(
                  (c) => c.dataset.quizId === quizId
                );
                if (card && !card.classList.contains("quiz-done")) {
                  card.classList.add("quiz-done");
                }
              }
            }
          });
        } catch (e) {
          console.error("Fehler beim Markieren gelöster Quiz:", e);
        }
      }

      // Celebration Animation: Partikel brechen aus dem Modal heraus
      function triggerCelebrationAnimation(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Celebration-Klasse hinzu
        modalElement.classList.add("celebration");

        // Erstelle Partikel
        const rect = modalInner.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const particleCount = 20;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "celebration-particle";

          // Zufällige Richtung und Entfernung
          const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
          const distance = 100 + Math.random() * 150;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;

          particle.style.left = centerX + "px";
          particle.style.top = centerY + "px";
          particle.style.setProperty("--tx", tx + "px");
          particle.style.setProperty("--ty", ty + "px");

          // Zufällige Größe und Farbe
          const size = 6 + Math.random() * 6;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          // Zufällige Farbvariation
          const colors = [
            "radial-gradient(circle, #fbbf24, #f59e0b)",
            "radial-gradient(circle, #fcd34d, #fbbf24)",
            "radial-gradient(circle, #fde68a, #fcd34d)",
            "radial-gradient(circle, #34d399, #10b981)",
            "radial-gradient(circle, #60a5fa, #3b82f6)",
          ];
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];

          document.body.appendChild(particle);

          // Entferne Partikel nach Animation
          setTimeout(() => {
            particle.remove();
          }, 1500);
        }
      }

      // Fehler-Feedback: Roter Flash + Shake
      function triggerErrorFeedback(modalElement) {
        if (!modalElement) return;

        const modalInner =
          modalElement.querySelector(".quiz-modal-inner") ||
          modalElement.querySelector(".master-quiz-modal-inner");
        if (!modalInner) return;

        // Füge Shake-Klasse hinzu
        modalElement.classList.add("error-feedback");
        modalInner.classList.add("error-flash");

        // Entferne Klassen nach Animation
        setTimeout(() => {
          modalElement.classList.remove("error-feedback");
          modalInner.classList.remove("error-flash");
        }, 500);
      }

      // Master Quiz Submit Handler
      const masterQuizSubmitBtn = document.getElementById(
        "master-quiz-submit-btn"
      );
      const masterQuizCloseBtn = document.getElementById(
        "master-quiz-close-btn"
      );
      const masterQuizFeedbackEl = document.getElementById(
        "master-quiz-feedback"
      );

      if (masterQuizSubmitBtn) {
        masterQuizSubmitBtn.addEventListener("click", () => {
          if (!currentMasterQuizSegment) return;

          const masterQuiz = masterQuizData[currentMasterQuizSegment];
          if (!masterQuiz) return;

          const selectedOption = document.querySelector(
            'input[name="master-quiz-option"]:checked'
          );
          if (!selectedOption) {
            masterQuizFeedbackEl.textContent = "Bitte eine Antwort auswählen.";
            masterQuizFeedbackEl.style.color = "#facc15";
            return;
          }

          const selectedIndex = parseInt(selectedOption.value);

          if (selectedIndex === masterQuiz.correctIndex) {
            setMasterQuizCompleted(currentMasterQuizSegment);

            // Prüfe ob dieses Segment einem Achievement entspricht
            const achievementThreshold = getAchievementThresholdFromSegment(
              currentMasterQuizSegment
            );
            if (achievementThreshold) {
              setAchievementMasterCompleted(achievementThreshold);
            }

            masterQuizFeedbackEl.innerHTML = `<div style="color: #22c55e; font-weight: 600;">🎉 Perfekt! Masterquiz bestanden!${
              achievementThreshold ? " Badge vergoldet! 🏆" : ""
            }</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${
              masterQuiz.explanation
            }</div>`;

            // Celebration Animation
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerCelebrationAnimation(masterQuizRoot);
            }

            // Update badge display
            updateBadgeDisplay();
            updateAchievements();
            updateHeaderBadgeFilter();

            setTimeout(() => {
              closeMasterQuiz();
            }, 1200);
          } else {
            masterQuizFeedbackEl.innerHTML = `<div style="color: #f97316;">Falsch. Versuche es erneut.</div><div style="margin-top: 0.5rem; font-size: 0.85rem; color: #d1d5db;">${masterQuiz.explanation}</div>`;

            // Fehler-Feedback: Roter Flash + Shake
            const masterQuizRoot = document.getElementById("master-quiz-root");
            if (masterQuizRoot) {
              triggerErrorFeedback(masterQuizRoot);
            }
          }
        });
      }

      // Hotkeys Card Click Handler
      const hotkeysCard = document.getElementById("hotkeys-card");
      if (hotkeysCard) {
        hotkeysCard.addEventListener("click", openHotkeysModal);
      }

      const kaliToolsCard = document.getElementById("kali-tools-card");
      if (kaliToolsCard) {
        kaliToolsCard.addEventListener("click", openKaliToolsModal);
      }

      const mistakesCard = document.getElementById("mistakes-card");
      if (mistakesCard) {
        mistakesCard.addEventListener("click", openMistakesModal);
      }

      const faqCard = document.getElementById("faq-card");
      if (faqCard) {
        faqCard.addEventListener("click", () => openFaqModal());
      }

      function openMistakesModal() {
        const modal = modalController.getRoot("mistakes");
        const bodyEl = document.getElementById("mistakes-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";

        const list = document.createElement("div");
        list.className = "mistakes-list";

        beginnerMistakes.forEach((item, index) => {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "mistake-row";
          row.setAttribute("data-quiz-id", item.quizId);

          const header = document.createElement("div");
          header.className = "mistake-row-header";

          const idxEl = document.createElement("span");
          idxEl.className = "mistake-index";
          idxEl.textContent = String(index + 1).padStart(2, "0");
          header.appendChild(idxEl);

          const titleEl = document.createElement("span");
          titleEl.className = "mistake-title";
          titleEl.textContent = item.title;
          header.appendChild(titleEl);

          if (isQuizCompleted(item.quizId)) {
            const badge = document.createElement("span");
            badge.className = `badge-mini ${item.segmentClass || "segment-1"}`;
            badge.textContent = "✔";
            badge.title = "Thema abgeschlossen (3/3 Fragen)";
            header.appendChild(badge);
          }

          row.appendChild(header);

          const desc = document.createElement("p");
          desc.className = "mistake-description";
          desc.textContent = item.description;
          row.appendChild(desc);

          if (item.example) {
            const example = document.createElement("div");
            example.className = "mistake-example";
            example.innerHTML = `✅ Korrekt: <code>${item.example}</code>`;
            row.appendChild(example);
          }

          if (item.tip) {
            const meta = document.createElement("div");
            meta.className = "mistake-meta";
            meta.innerHTML = `💡 ${item.tip} · 🔗 Quiz-ID: <code>${item.quizId}</code>`;
            row.appendChild(meta);
          }

          row.addEventListener("click", () => {
            closeMistakesModal();
            openQuiz(item.quizId);
          });

          list.appendChild(row);
        });

        bodyEl.appendChild(list);

        modalController.open("mistakes");
      }

      function closeMistakesModal() {
        modalController.close("mistakes");
      }

      // FAQ Modal Functions - Agent 3
      let currentFaqCategory = null;
      let currentFaqSearch = "";
      let bookmarkedFaqs = JSON.parse(
        localStorage.getItem("faqBookmarks") || "[]"
      );

      function getBookmarkedFaqs() {
        try {
          return JSON.parse(localStorage.getItem("faqBookmarks") || "[]");
        } catch {
          return [];
        }
      }

      function saveBookmarkedFaqs(bookmarks) {
        localStorage.setItem("faqBookmarks", JSON.stringify(bookmarks));
        bookmarkedFaqs = bookmarks;
      }

      function toggleBookmark(faqId) {
        const bookmarks = getBookmarkedFaqs();
        const index = bookmarks.indexOf(faqId);
        if (index > -1) {
          bookmarks.splice(index, 1);
        } else {
          bookmarks.push(faqId);
        }
        saveBookmarkedFaqs(bookmarks);
        renderFaqContent(currentFaqCategory, currentFaqSearch);
      }

      function isBookmarked(faqId) {
        return bookmarkedFaqs.includes(faqId);
      }

      function highlightText(text, query) {
        if (!query || query.trim() === "") return text;
        const regex = new RegExp(
          `(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`,
          "gi"
        );
        return text.replace(regex, "<mark>$1</mark>");
      }

      function searchFaqs(query) {
        currentFaqSearch = query;
        renderFaqContent(currentFaqCategory, query);
      }

      function renderRelatedCommands(relatedCommands, container) {
        container.innerHTML = "";
        if (!relatedCommands || relatedCommands.length === 0) return;

        const label = document.createElement("span");
        label.className = "faq-related-commands-label";
        label.textContent = "Verwandte Commands:";
        container.appendChild(label);

        relatedCommands.forEach((cmdId) => {
          const badge = document.createElement("a");
          badge.className = "faq-related-command-badge";
          badge.href = "#";
          badge.textContent = cmdId;
          badge.addEventListener("click", (e) => {
            e.preventDefault();
            closeFaqModal();
            const card = commandCards.find(
              (c) => c.dataset.command === cmdId || c.dataset.quizId === cmdId
            );
            if (card) {
              card.scrollIntoView({ behavior: "smooth", block: "center" });
              card.style.boxShadow = "0 0 20px rgba(59, 130, 246, 0.5)";
              setTimeout(() => {
                card.style.boxShadow = "";
              }, 2000);
            }
          });
          container.appendChild(badge);
        });
      }

      function renderFaqContent(categoryFilter = null, searchQuery = "") {
        if (!faqData || !faqData.categories) return;

        const contentEl = document.getElementById("faq-content");
        const categoryListEl = document.getElementById("faq-category-list");
        if (!contentEl || !categoryListEl) return;

        currentFaqCategory = categoryFilter;
        currentFaqSearch = searchQuery;

        // Render Kategorien-Sidebar
        categoryListEl.innerHTML = "";
        faqData.categories.forEach((category) => {
          const categoryItem = document.createElement("div");
          categoryItem.className = `faq-category-item ${
            categoryFilter === category.id ? "active" : ""
          }`;
          categoryItem.innerHTML = `
                        <span class="faq-category-icon">${category.icon}</span>
                        <span class="faq-category-name">${category.name}</span>
                        <span class="faq-category-count">${category.questions.length}</span>
                      `;
          categoryItem.addEventListener("click", () => {
            renderFaqContent(category.id, searchQuery);
          });
          categoryListEl.appendChild(categoryItem);
        });

        // Filter FAQs - erweiterte Suche in Tags und relatedCommands
        let filteredQuestions = [];
        faqData.categories.forEach((category) => {
          if (categoryFilter && categoryFilter !== category.id) return;
          category.questions.forEach((question) => {
            if (searchQuery && searchQuery.trim() !== "") {
              const queryLower = searchQuery.toLowerCase();
              const searchText = [
                question.question,
                question.answer,
                ...(question.tags || []),
                ...(question.relatedCommands || []),
              ]
                .join(" ")
                .toLowerCase();

              if (!searchText.includes(queryLower)) {
                return;
              }
            }
            filteredQuestions.push({ ...question, category });
          });
        });

        // Render FAQ Content
        contentEl.innerHTML = "";

        if (filteredQuestions.length === 0) {
          const emptyState = document.createElement("div");
          emptyState.className = "faq-empty-state";
          emptyState.innerHTML = `
                        <div class="faq-empty-state-icon">🔍</div>
                        <div class="faq-empty-state-text">
                          ${
                            searchQuery
                              ? "Keine FAQs gefunden."
                              : "Wähle eine Kategorie aus der Sidebar."
                          }
                        </div>
                      `;
          contentEl.appendChild(emptyState);
          return;
        }

        // Gruppiere nach Kategorie
        const groupedByCategory = {};
        filteredQuestions.forEach((item) => {
          if (!groupedByCategory[item.category.id]) {
            groupedByCategory[item.category.id] = {
              category: item.category,
              questions: [],
            };
          }
          groupedByCategory[item.category.id].questions.push(item);
        });

        // Render jede Kategorie
        Object.values(groupedByCategory).forEach((group) => {
          if (!categoryFilter) {
            const categoryHeader = document.createElement("div");
            categoryHeader.className = "faq-category-header";
            categoryHeader.innerHTML = `
                          <h2>
                            <span class="faq-category-icon">${group.category.icon}</span>
                            ${group.category.name}
                          </h2>
                        `;
            contentEl.appendChild(categoryHeader);
          }

          group.questions.forEach((item) => {
            const accordionItem = document.createElement("div");
            accordionItem.className = "faq-accordion-item";
            accordionItem.id = `faq-item-${item.id}`;

            const questionDiv = document.createElement("div");
            questionDiv.className = "faq-question";
            questionDiv.innerHTML = `
                          <span class="faq-question-text">${highlightText(
                            item.question,
                            searchQuery
                          )}</span>
                          <div class="faq-question-actions">
                            <button
                              type="button"
                              class="faq-bookmark-btn ${
                                isBookmarked(item.id) ? "bookmarked" : ""
                              }"
                              data-faq-id="${item.id}"
                              aria-label="Bookmark"
                            >
                              ${isBookmarked(item.id) ? "⭐" : "☆"}
                            </button>
                            <span class="faq-expand-icon">▼</span>
                          </div>
                        `;

            const answerDiv = document.createElement("div");
            answerDiv.className = "faq-answer";
            const answerContent = document.createElement("div");
            answerContent.className = "faq-answer-content";

            // Formatierte Antwort mit hervorgehobenen Commands
            let formattedAnswer = highlightText(item.answer, searchQuery);

            // Erkenne Commands in der Antwort und formatiere sie
            formattedAnswer = formattedAnswer.replace(
              /`([^`]+)`/g,
              "<code>$1</code>"
            );

            // Erkenne Beispiel-Blöcke (Zeilen die mit "Beispiel:" beginnen oder Commands enthalten)
            formattedAnswer = formattedAnswer.replace(
              /(Beispiel:?\s*)([^\n]+)/gi,
              '<div class="faq-example-block"><span class="faq-example-label">$1</span><code>$2</code></div>'
            );

            answerContent.innerHTML = formattedAnswer;

            const relatedCommandsDiv = document.createElement("div");
            relatedCommandsDiv.className = "faq-related-commands";
            renderRelatedCommands(item.relatedCommands, relatedCommandsDiv);

            answerContent.appendChild(relatedCommandsDiv);
            answerDiv.appendChild(answerContent);

            questionDiv.addEventListener("click", (e) => {
              if (e.target.closest(".faq-bookmark-btn")) return;
              accordionItem.classList.toggle("expanded");
            });

            questionDiv
              .querySelector(".faq-bookmark-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                toggleBookmark(item.id);
              });

            accordionItem.appendChild(questionDiv);
            accordionItem.appendChild(answerDiv);
            contentEl.appendChild(accordionItem);
          });
        });
      }

      function scrollToFaq(questionId) {
        const item = document.getElementById(`faq-item-${questionId}`);
        if (item) {
          item.scrollIntoView({ behavior: "smooth", block: "center" });
          item.classList.add("expanded");
          setTimeout(() => {
            item.style.boxShadow = "0 0 20px rgba(59, 130, 246, 0.5)";
            setTimeout(() => {
              item.style.boxShadow = "";
            }, 2000);
          }, 300);
        }
      }

      function openFaqModal(categoryId = null, questionId = null) {
        const modal = modalController.getRoot("faq");
        if (!modal) return;

        // Übernehme Suchanfrage aus Hauptsuche, falls vorhanden
        const mainSearchInput = document.getElementById("search-input");
        if (mainSearchInput && mainSearchInput.value.trim()) {
          currentFaqSearch = mainSearchInput.value.trim();
          const faqSearchInput = document.getElementById("faq-search-input");
          if (faqSearchInput) {
            faqSearchInput.value = currentFaqSearch;
          }
        }

        renderFaqContent(categoryId, currentFaqSearch);

        modalController.open("faq");

        if (questionId) {
          setTimeout(() => scrollToFaq(questionId), 100);
        }
      }

      function closeFaqModal() {
        modalController.close("faq");
      }

      const faqSearchInput = document.getElementById("faq-search-input");
      if (faqSearchInput) {
        faqSearchInput.addEventListener("input", (e) => {
          searchFaqs(e.target.value);
        });
      }

      // Open Modern Tools Modal
      function openModernToolsModal() {
        const modal = modalController.getRoot("modernTools");
        const bodyEl = document.getElementById("modern-tools-body");

        if (!modal || !bodyEl) return;

        bodyEl.innerHTML = "";
        const content = parseModernToolsContent();

        // Installation Section
        const installSection = document.createElement("div");
        installSection.className = "modern-tools-section";
        const installTitle = document.createElement("div");
        installTitle.className = "modern-tools-section-title";
        installTitle.textContent = content.installation.title;
        installSection.appendChild(installTitle);

        const installDesc = document.createElement("p");
        installDesc.textContent = content.installation.description;
        installSection.appendChild(installDesc);

        const commandBox = document.createElement("div");
        commandBox.className = "modern-tools-command-box";
        const commandCode = document.createElement("code");
        commandCode.textContent = content.installation.command;
        commandBox.appendChild(commandCode);
        installSection.appendChild(commandBox);

        if (content.installation.note) {
          const note = document.createElement("p");
          note.style.cssText = "font-size: 0.875rem; color: #94a3b8; margin-top: 0.5rem;";
          note.textContent = content.installation.note;
          installSection.appendChild(note);
        }

        bodyEl.appendChild(installSection);

        // Tools Section
        content.tools.forEach((tool) => {
          const toolDiv = document.createElement("div");
          toolDiv.className = "modern-tools-tool";

          const toolHeader = document.createElement("div");
          toolHeader.className = "modern-tools-tool-header";

          const toolName = document.createElement("div");
          toolName.className = "modern-tools-tool-name";
          toolName.textContent = tool.name;

          const toolDesc = document.createElement("div");
          toolDesc.className = "modern-tools-tool-desc";
          toolDesc.textContent = tool.description;

          toolHeader.appendChild(toolName);
          toolHeader.appendChild(toolDesc);
          toolDiv.appendChild(toolHeader);

          // Examples
          if (tool.examples && tool.examples.length > 0) {
            tool.examples.forEach((example) => {
              const exampleDiv = document.createElement("div");
              exampleDiv.className = "modern-tools-example";

              const levelDiv = document.createElement("div");
              levelDiv.className = "modern-tools-example-level";
              levelDiv.textContent = example.level;
              exampleDiv.appendChild(levelDiv);

              const exampleRow = document.createElement("div");
              exampleRow.className = "modern-tools-example-row";

              if (example.new) {
                const newDiv = document.createElement("div");
                newDiv.className = "modern-tools-example-new";
                const newLabel = document.createElement("div");
                newLabel.className = "modern-tools-example-label";
                newLabel.textContent = "→ Neu";
                newDiv.appendChild(newLabel);
                const newCode = document.createElement("code");
                newCode.textContent = example.new;
                newDiv.appendChild(newCode);
                exampleRow.appendChild(newDiv);
              }

              if (example.old && example.old !== "-") {
                const oldDiv = document.createElement("div");
                oldDiv.className = "modern-tools-example-old";
                const oldLabel = document.createElement("div");
                oldLabel.className = "modern-tools-example-label";
                oldLabel.textContent = "Alt";
                oldDiv.appendChild(oldLabel);
                const oldCode = document.createElement("code");
                oldCode.textContent = example.old;
                oldDiv.appendChild(oldCode);
                exampleRow.appendChild(oldDiv);
              }

              exampleDiv.appendChild(exampleRow);

              if (example.note) {
                const noteDiv = document.createElement("div");
                noteDiv.className = "modern-tools-example-note";
                noteDiv.textContent = example.note;
                exampleDiv.appendChild(noteDiv);
              }

              toolDiv.appendChild(exampleDiv);
            });
          }

          bodyEl.appendChild(toolDiv);
        });

        // Syntax Section
        if (content.syntax) {
          const syntaxSection = document.createElement("div");
          syntaxSection.className = "modern-tools-section";
          const syntaxTitle = document.createElement("div");
          syntaxTitle.className = "modern-tools-section-title";
          syntaxTitle.textContent = content.syntax.title;
          syntaxSection.appendChild(syntaxTitle);

          if (content.syntax.description) {
            const syntaxDesc = document.createElement("p");
            syntaxDesc.textContent = content.syntax.description;
            syntaxSection.appendChild(syntaxDesc);
          }

          content.syntax.sections.forEach((section) => {
            const syntaxItem = document.createElement("div");
            syntaxItem.className = "modern-tools-syntax-item";

            const syntaxItemTitle = document.createElement("div");
            syntaxItemTitle.className = "modern-tools-syntax-title";
            syntaxItemTitle.textContent = section.title;
            syntaxItem.appendChild(syntaxItemTitle);

            if (section.content) {
              const syntaxContent = document.createElement("div");
              syntaxContent.className = "modern-tools-syntax-content";
              const syntaxCode = document.createElement("code");
              syntaxCode.textContent = section.content;
              syntaxContent.appendChild(syntaxCode);
              syntaxItem.appendChild(syntaxContent);
            }

            if (section.table) {
              const table = document.createElement("table");
              table.className = "modern-tools-table";
              const thead = document.createElement("thead");
              const headerRow = document.createElement("tr");
              section.table.headers.forEach((header) => {
                const th = document.createElement("th");
                th.textContent = header;
                headerRow.appendChild(th);
              });
              thead.appendChild(headerRow);
              table.appendChild(thead);

              const tbody = document.createElement("tbody");
              section.table.rows.forEach((row) => {
                const tr = document.createElement("tr");
                row.forEach((cell) => {
                  const td = document.createElement("td");
                  const code = document.createElement("code");
                  code.textContent = cell;
                  td.appendChild(code);
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
              table.appendChild(tbody);
              syntaxItem.appendChild(table);
            }

            if (section.examples && section.examples.length > 0) {
              const examplesDiv = document.createElement("div");
              examplesDiv.className = "modern-tools-examples";
              section.examples.forEach((example) => {
                const exampleCode = document.createElement("div");
                exampleCode.className = "modern-tools-example-code";
                const code = document.createElement("code");
                code.textContent = example;
                exampleCode.appendChild(code);
                examplesDiv.appendChild(exampleCode);
              });
              syntaxItem.appendChild(examplesDiv);
            }

            syntaxSection.appendChild(syntaxItem);
          });

          bodyEl.appendChild(syntaxSection);
        }

        modalController.open("modernTools");
      }

      // Modern Tools Card Click Handler
      const modernToolsCard = document.getElementById("modern-tools-card");
      if (modernToolsCard) {
        modernToolsCard.addEventListener("click", openModernToolsModal);
      }

      // Initialize page on load
      assignBadgeToCards();
      updateHeaderBadgeFilter();
      filterCardsBySegment();
      buildCheatSheetMap();
      // Markiere alle bereits gelösten Quiz-Karten beim Laden
      markCompletedQuizzesOnLoad();

      // Prüfe URL-Parameter für Badge-Highlighting
      const urlParams = new URLSearchParams(window.location.search);
      const highlightBadge = urlParams.get("highlight");
      if (highlightBadge) {
        // Entferne Highlight-Parameter aus URL ohne Reload
        const newUrl = window.location.pathname;
        window.history.replaceState({}, "", newUrl);

        // Markiere Badge als gesättigt
        let badgeSaturated = {};
        const stored = localStorage.getItem("badgeSaturated");
        if (stored) {
          try {
            badgeSaturated = JSON.parse(stored);
          } catch (e) {
            badgeSaturated = {};
          }
        }
        badgeSaturated[highlightBadge] = true;
        localStorage.setItem("badgeSaturated", JSON.stringify(badgeSaturated));

        // Aktualisiere Badge-Anzeige
        updateHeaderBadgeFilter();

        // Optional: Scroll zu Badge
        setTimeout(() => {
          const badgeWrapper = document.querySelector(`[data-segment-id="${highlightBadge}"]`);
          if (badgeWrapper) {
            badgeWrapper.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }, 100);
      }

      // ===== QUIZ AUTO-TEST =====
      async function runQuizAutoTest() {
        console.log("🧪 ===== QUIZ AUTO-TEST GESTARTET =====");
        const testReport = {
          startTime: new Date().toISOString(),
          tests: [],
          summary: {
            total: 0,
            passed: 0,
            failed: 0,
            errors: [],
          },
        };

        // Test-Quiz-IDs (2 verschiedene Quizzes)
        const testQuizIds = ["pwd", "cd"];

        for (const quizId of testQuizIds) {
          console.log(`\n📝 Teste Quiz: ${quizId}`);

          try {
            // Warte kurz zwischen Tests
            await sleep(500);

            // Öffne Quiz-Modal
            console.log(`  → Öffne Quiz-Modal für ${quizId}`);
            if (typeof openQuiz === "undefined") {
              throw new Error("openQuiz Funktion nicht gefunden");
            }
            openQuiz(quizId);

            // Warte bis Quiz gerendert ist
            await sleep(800);

            const quiz =
              typeof quizData !== "undefined" ? quizData[quizId] : null;
            if (!quiz) {
              throw new Error(`Quiz-Daten für ${quizId} nicht gefunden`);
            }

            // Lese Quiz-Fragen und beantworte sie
            const quizBodyBack = document.getElementById("quiz-body-back");
            if (!quizBodyBack) {
              throw new Error("quiz-body-back Element nicht gefunden");
            }

            const questionEls = Array.from(
              quizBodyBack.querySelectorAll(".quiz-question")
            );
            console.log(`  → Gefunden: ${questionEls.length} Fragen`);

            let questionsAnswered = 0;

            for (let idx = 0; idx < questionEls.length; idx++) {
              const questionEl = questionEls[idx];
              const question = quiz.questions[idx];

              if (!question) {
                console.warn(
                  `  ⚠️ Frage ${idx + 1} nicht in Quiz-Daten gefunden`
                );
                continue;
              }

              await sleep(200);

              if (question.type === "command") {
                // Command-Input-Frage
                const commandInput = questionEl.querySelector(
                  ".quiz-command-input"
                );
                if (commandInput) {
                  const correctCommand = question.correctCommand;
                  console.log(
                    `  → Frage ${idx + 1} (${question.level}): Command-Input`
                  );
                  console.log(`    Korrekte Antwort: ${correctCommand}`);

                  commandInput.value = correctCommand;
                  commandInput.dispatchEvent(
                    new Event("input", { bubbles: true })
                  );

                  // Validiere Input
                  if (typeof validateCommandInput === "function") {
                    validateCommandInput(commandInput, question);
                  }

                  questionsAnswered++;
                  await sleep(300);
                }
              } else {
                // Multiple-Choice-Frage
                const correctIndex = question.correctIndex;
                const radioInputs = questionEl.querySelectorAll(
                  'input[type="radio"]'
                );

                if (radioInputs.length > correctIndex) {
                  console.log(
                    `  → Frage ${idx + 1} (${question.level}): Multiple-Choice`
                  );
                  console.log(`    Korrekte Antwort: Index ${correctIndex}`);

                  const correctRadio = radioInputs[correctIndex];
                  correctRadio.checked = true;
                  correctRadio.dispatchEvent(
                    new Event("change", { bubbles: true })
                  );

                  questionsAnswered++;
                  await sleep(300);
                }
              }
            }

            // Warte kurz vor Submit
            await sleep(500);

            // Klicke Submit-Button
            const quizSubmitBtnBack = document.getElementById(
              "quiz-submit-btn-back"
            );
            if (quizSubmitBtnBack && !quizSubmitBtnBack.disabled) {
              console.log(`  → Klicke Submit-Button`);

              // Erstelle ein echtes Click-Event
              const clickEvent = new MouseEvent("click", {
                view: window,
                bubbles: true,
                cancelable: true,
              });
              quizSubmitBtnBack.dispatchEvent(clickEvent);

              questionsAnswered++;
            } else {
              console.warn(
                `  ⚠️ Submit-Button nicht gefunden oder deaktiviert`
              );
            }

            // Warte auf Feedback
            await sleep(1000);

            // Prüfe Feedback
            const quizFeedbackBack =
              document.getElementById("quiz-feedback-back");
            let feedback = "";
            if (quizFeedbackBack) {
              feedback = quizFeedbackBack.textContent || "";
            }

            const testResult = {
              quizId: quizId,
              quizTitle: quiz.title,
              questionsTotal: questionEls.length,
              questionsAnswered: questionsAnswered,
              feedback: feedback,
              success: feedback.includes("3/3") || feedback.includes("richtig"),
              timestamp: new Date().toISOString(),
            };

            if (testResult.success) {
              console.log(`  ✅ Quiz ${quizId} erfolgreich gelöst!`);
              testReport.summary.passed++;
            } else {
              console.log(
                `  ❌ Quiz ${quizId} fehlgeschlagen. Feedback: ${feedback}`
              );
              testReport.summary.failed++;
            }

            testReport.tests.push(testResult);
            testReport.summary.total++;

            // Warte vor nächstem Quiz
            await sleep(1000);
          } catch (error) {
            console.error(`  ❌ Fehler beim Testen von ${quizId}:`, error);
            testReport.summary.errors.push({
              quizId: quizId,
              error: error.message,
              stack: error.stack,
            });
            testReport.summary.failed++;
            testReport.summary.total++;
          }
        }

        // Finale Zusammenfassung
        testReport.endTime = new Date().toISOString();
        const duration =
          new Date(testReport.endTime) - new Date(testReport.startTime);

        console.log("\n📊 ===== TEST-ZUSAMMENFASSUNG =====");
        console.log(`Gesamt: ${testReport.summary.total} Tests`);
        console.log(`✅ Erfolgreich: ${testReport.summary.passed}`);
        console.log(`❌ Fehlgeschlagen: ${testReport.summary.failed}`);
        console.log(`⏱️  Dauer: ${(duration / 1000).toFixed(2)}s`);

        if (testReport.summary.errors.length > 0) {
          console.log("\n⚠️ Fehler:");
          testReport.summary.errors.forEach((err) => {
            console.log(`  - ${err.quizId}: ${err.error}`);
          });
        }

        console.log("\n📋 Detaillierter Bericht:");
        testReport.tests.forEach((test) => {
          console.log(`\n  Quiz: ${test.quizId} (${test.quizTitle})`);
          console.log(
            `    Fragen beantwortet: ${test.questionsAnswered}/${test.questionsTotal}`
          );
          console.log(
            `    Status: ${
              test.success ? "✅ Erfolgreich" : "❌ Fehlgeschlagen"
            }`
          );
          console.log(`    Feedback: ${test.feedback || "Kein Feedback"}`);
        });

        // Speichere Bericht global für spätere Inspektion
        window.quizTestReport = testReport;

        console.log(
          "\n✨ Test abgeschlossen! Bericht gespeichert in window.quizTestReport"
        );

        return testReport;
      }

      // Helper-Funktion für Delays
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // Test-Funktion global verfügbar machen
      window.runQuizAutoTest = runQuizAutoTest;
      console.log("🚀 Quiz-Auto-Test bereit. Führe aus mit: runQuizAutoTest()");
    </script>
  </body>
</html>
